{
  "version": 3,
  "sources": ["../../code-red/src/utils/id.js", "../../code-red/src/utils/comments.js", "../../code-red/src/utils/push_array.js", "../../code-red/src/print/handlers.js", "../../code-red/src/print/index.js", "../../code-red/src/index.js"],
  "sourcesContent": ["// generate an ID that is, to all intents and purposes, unique\nexport const id = Math.round(Math.random() * 1e20).toString(36);\nexport const re = new RegExp(`_${id}_(?:(\\\\d+)|(AT)|(HASH))_(\\\\w+)?`, 'g');\n", "import { re } from './id.js';\n\n/** @typedef {import('estree').Comment} Comment */\n/** @typedef {import('estree').Node} Node */\n\n/**\n * @typedef {Node & {\n *   start: number;\n *   end: number;\n *   has_trailing_newline?: boolean\n * }} NodeWithLocation\n */\n\n/**\n * @typedef {Comment & {\n *   start: number;\n *   end: number;\n *   has_trailing_newline?: boolean\n * }} CommentWithLocation\n */\n\n/**\n * @param {CommentWithLocation[]} comments\n * @param {string} raw\n */\nexport const get_comment_handlers = (comments, raw) => ({\n\t// pass to acorn options\n\t/**\n\t * @param {boolean} block\n\t * @param {string} value\n\t * @param {number} start\n\t * @param {number} end\n\t */\n\tonComment: (block, value, start, end) => {\n\t\tif (block && /\\n/.test(value)) {\n\t\t\tlet a = start;\n\t\t\twhile (a > 0 && raw[a - 1] !== '\\n') a -= 1;\n\n\t\t\tlet b = a;\n\t\t\twhile (/[ \\t]/.test(raw[b])) b += 1;\n\n\t\t\tconst indentation = raw.slice(a, b);\n\t\t\tvalue = value.replace(new RegExp(`^${indentation}`, 'gm'), '');\n\t\t}\n\n\t\tcomments.push({ type: block ? 'Block' : 'Line', value, start, end });\n\t},\n\n\t// pass to estree-walker options\n\t/** @param {NodeWithLocation} node */\n\tenter(node) {\n\t\tlet comment;\n\n\t\twhile (comments[0] && comments[0].start < node.start) {\n\t\t\tcomment = comments.shift();\n\n\t\t\tcomment.value = comment.value.replace(\n\t\t\t\tre,\n\t\t\t\t(match, id, at, hash, value) => {\n\t\t\t\t\tif (hash) return `#${value}`;\n\t\t\t\t\tif (at) return `@${value}`;\n\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tconst next = comments[0] || node;\n\t\t\tcomment.has_trailing_newline =\n\t\t\t\tcomment.type === 'Line' ||\n\t\t\t\t/\\n/.test(raw.slice(comment.end, next.start));\n\n\t\t\t(node.leadingComments || (node.leadingComments = [])).push(comment);\n\t\t}\n\t},\n\n\t/** @param {NodeWithLocation} node */\n\tleave(node) {\n\t\tif (comments[0]) {\n\t\t\tconst slice = raw.slice(node.end, comments[0].start);\n\n\t\t\tif (/^[,) \\t]*$/.test(slice)) {\n\t\t\t\tnode.trailingComments = [comments.shift()];\n\t\t\t}\n\t\t}\n\t}\n});\n", "/**\n * Does `array.push` for all `items`. Needed because `array.push(...items)` throws\n * \"Maximum call stack size exceeded\" when `items` is too big of an array.\n *\n * @param {any[]} array\n * @param {any[]} items\n */\nexport function push_array(array, items) {\n\tfor (let i = 0; i < items.length; i++) {\n\t\tarray.push(items[i]);\n\t}\n}\n", "// heavily based on https://github.com/davidbonnet/astring\n// released under MIT license https://github.com/davidbonnet/astring/blob/master/LICENSE\n\nimport { re } from '../utils/id.js';\nimport { push_array } from '../utils/push_array.js';\n\n/** @typedef {import('estree').ArrowFunctionExpression} ArrowFunctionExpression */\n/** @typedef {import('estree').BinaryExpression} BinaryExpression */\n/** @typedef {import('estree').CallExpression} CallExpression */\n/** @typedef {import('estree').Comment} Comment */\n/** @typedef {import('estree').ExportSpecifier} ExportSpecifier */\n/** @typedef {import('estree').Expression} Expression */\n/** @typedef {import('estree').FunctionDeclaration} FunctionDeclaration */\n/** @typedef {import('estree').ImportDeclaration} ImportDeclaration */\n/** @typedef {import('estree').ImportSpecifier} ImportSpecifier */\n/** @typedef {import('estree').Literal} Literal */\n/** @typedef {import('estree').LogicalExpression} LogicalExpression */\n/** @typedef {import('estree').NewExpression} NewExpression */\n/** @typedef {import('estree').Node} Node */\n/** @typedef {import('estree').ObjectExpression} ObjectExpression */\n/** @typedef {import('estree').Pattern} Pattern */\n/** @typedef {import('estree').Property} Property */\n/** @typedef {import('estree').PropertyDefinition} PropertyDefinition */\n/** @typedef {import('estree').SequenceExpression} SequenceExpression */\n/** @typedef {import('estree').SimpleCallExpression} SimpleCallExpression */\n/** @typedef {import('estree').SwitchStatement} SwitchStatement */\n/** @typedef {import('estree').VariableDeclaration} VariableDeclaration */\n/** @typedef {import('estree').StaticBlock} StaticBlock */\n/** @typedef {import('estree').PrivateIdentifier} PrivateIdenifier*/\n\n/**\n * @typedef {{\n *   content: string;\n *   loc?: {\n *     start: { line: number; column: number; };\n *     end: { line: number; column: number; };\n *   };\n *   has_newline: boolean;\n * }} Chunk\n */\n\n/**\n * @typedef {(node: any, state: State) => Chunk[]} Handler\n */\n\n/**\n * @typedef {{\n *   indent: string;\n *   scope: any; // TODO import from periscopic\n *   scope_map: WeakMap<Node, any>;\n *   getName: (name: string) => string;\n *   deconflicted: WeakMap<Node, Map<string, string>>;\n *   comments: Comment[];\n * }} State\n */\n\n/**\n * @param {Node} node\n * @param {State} state\n * @returns {Chunk[]}\n */\nexport function handle(node, state) {\n\tconst handler = handlers[node.type];\n\n\tif (!handler) {\n\t\tthrow new Error(`Not implemented ${node.type}`);\n\t}\n\n\tconst result = handler(node, state);\n\n\tif (node.leadingComments) {\n\t\tresult.unshift(\n\t\t\tc(\n\t\t\t\tnode.leadingComments\n\t\t\t\t\t.map((comment) =>\n\t\t\t\t\t\tcomment.type === 'Block'\n\t\t\t\t\t\t\t? `/*${comment.value}*/${\n\t\t\t\t\t\t\t\t\t/** @type {any} */ (comment).has_trailing_newline\n\t\t\t\t\t\t\t\t\t\t? `\\n${state.indent}`\n\t\t\t\t\t\t\t\t\t\t: ` `\n\t\t\t\t\t\t\t  }`\n\t\t\t\t\t\t\t: `//${comment.value}${\n\t\t\t\t\t\t\t\t\t/** @type {any} */ (comment).has_trailing_newline\n\t\t\t\t\t\t\t\t\t\t? `\\n${state.indent}`\n\t\t\t\t\t\t\t\t\t\t: ` `\n\t\t\t\t\t\t\t  }`\n\t\t\t\t\t)\n\t\t\t\t\t.join(``)\n\t\t\t)\n\t\t);\n\t}\n\n\tif (node.trailingComments) {\n\t\tstate.comments.push(node.trailingComments[0]); // there is only ever one\n\t}\n\n\treturn result;\n}\n\n/**\n * @param {string} content\n * @param {Node} [node]\n * @returns {Chunk}\n */\nfunction c(content, node) {\n\treturn {\n\t\tcontent,\n\t\tloc: node && node.loc,\n\t\thas_newline: /\\n/.test(content)\n\t};\n}\n\nconst OPERATOR_PRECEDENCE = {\n\t'||': 2,\n\t'&&': 3,\n\t'??': 4,\n\t'|': 5,\n\t'^': 6,\n\t'&': 7,\n\t'==': 8,\n\t'!=': 8,\n\t'===': 8,\n\t'!==': 8,\n\t'<': 9,\n\t'>': 9,\n\t'<=': 9,\n\t'>=': 9,\n\tin: 9,\n\tinstanceof: 9,\n\t'<<': 10,\n\t'>>': 10,\n\t'>>>': 10,\n\t'+': 11,\n\t'-': 11,\n\t'*': 12,\n\t'%': 12,\n\t'/': 12,\n\t'**': 13\n};\n\n/** @type {Record<string, number>} */\nconst EXPRESSIONS_PRECEDENCE = {\n\tArrayExpression: 20,\n\tTaggedTemplateExpression: 20,\n\tThisExpression: 20,\n\tIdentifier: 20,\n\tLiteral: 18,\n\tTemplateLiteral: 20,\n\tSuper: 20,\n\tSequenceExpression: 20,\n\tMemberExpression: 19,\n\tCallExpression: 19,\n\tNewExpression: 19,\n\tAwaitExpression: 17,\n\tClassExpression: 17,\n\tFunctionExpression: 17,\n\tObjectExpression: 17,\n\tUpdateExpression: 16,\n\tUnaryExpression: 15,\n\tBinaryExpression: 14,\n\tLogicalExpression: 13,\n\tConditionalExpression: 4,\n\tArrowFunctionExpression: 3,\n\tAssignmentExpression: 3,\n\tYieldExpression: 2,\n\tRestElement: 1\n};\n\n/**\n *\n * @param {Expression} node\n * @param {BinaryExpression | LogicalExpression} parent\n * @param {boolean} is_right\n * @returns\n */\nfunction needs_parens(node, parent, is_right) {\n\t// special case where logical expressions and coalesce expressions cannot be mixed,\n\t// either of them need to be wrapped with parentheses\n\tif (\n\t\tnode.type === 'LogicalExpression' &&\n\t\tparent.type === 'LogicalExpression' &&\n\t\t((parent.operator === '??' && node.operator !== '??') ||\n\t\t\t(parent.operator !== '??' && node.operator === '??'))\n\t) {\n\t\treturn true;\n\t}\n\n\tconst precedence = EXPRESSIONS_PRECEDENCE[node.type];\n\tconst parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];\n\n\tif (precedence !== parent_precedence) {\n\t\t// Different node types\n\t\treturn (\n\t\t\t(!is_right &&\n\t\t\t\tprecedence === 15 &&\n\t\t\t\tparent_precedence === 14 &&\n\t\t\t\tparent.operator === '**') ||\n\t\t\tprecedence < parent_precedence\n\t\t);\n\t}\n\n\tif (precedence !== 13 && precedence !== 14) {\n\t\t// Not a `LogicalExpression` or `BinaryExpression`\n\t\treturn false;\n\t}\n\n\tif (\n\t\t/** @type {BinaryExpression} */ (node).operator === '**' &&\n\t\tparent.operator === '**'\n\t) {\n\t\t// Exponentiation operator has right-to-left associativity\n\t\treturn !is_right;\n\t}\n\n\tif (is_right) {\n\t\t// Parenthesis are used if both operators have the same precedence\n\t\treturn (\n\t\t\tOPERATOR_PRECEDENCE[/** @type {BinaryExpression} */ (node).operator] <=\n\t\t\tOPERATOR_PRECEDENCE[parent.operator]\n\t\t);\n\t}\n\n\treturn (\n\t\tOPERATOR_PRECEDENCE[/** @type {BinaryExpression} */ (node).operator] <\n\t\tOPERATOR_PRECEDENCE[parent.operator]\n\t);\n}\n\n/** @param {Node} node */\nfunction has_call_expression(node) {\n\twhile (node) {\n\t\tif (node.type[0] === 'CallExpression') {\n\t\t\treturn true;\n\t\t} else if (node.type === 'MemberExpression') {\n\t\t\tnode = node.object;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\n/** @param {Chunk[]} chunks */\nconst has_newline = (chunks) => {\n\tfor (let i = 0; i < chunks.length; i += 1) {\n\t\tif (chunks[i].has_newline) return true;\n\t}\n\treturn false;\n};\n\n/** @param {Chunk[]} chunks */\nconst get_length = (chunks) => {\n\tlet total = 0;\n\tfor (let i = 0; i < chunks.length; i += 1) {\n\t\ttotal += chunks[i].content.length;\n\t}\n\treturn total;\n};\n\n/**\n * @param {number} a\n * @param {number} b\n */\nconst sum = (a, b) => a + b;\n\n/**\n * @param {Chunk[][]} nodes\n * @param {Chunk} separator\n * @returns {Chunk[]}\n */\nconst join = (nodes, separator) => {\n\tif (nodes.length === 0) return [];\n\n\tconst joined = [...nodes[0]];\n\tfor (let i = 1; i < nodes.length; i += 1) {\n\t\tjoined.push(separator);\n\t\tpush_array(joined, nodes[i]);\n\t}\n\treturn joined;\n};\n\n/**\n * @param {(node: any, state: State) => Chunk[]} fn\n */\nconst scoped = (fn) => {\n\t/**\n\t * @param {any} node\n\t * @param {State} state\n\t */\n\tconst scoped_fn = (node, state) => {\n\t\treturn fn(node, {\n\t\t\t...state,\n\t\t\tscope: state.scope_map.get(node)\n\t\t});\n\t};\n\n\treturn scoped_fn;\n};\n\n/**\n * @param {string} name\n * @param {Set<string>} names\n */\nconst deconflict = (name, names) => {\n\tconst original = name;\n\tlet i = 1;\n\n\twhile (names.has(name)) {\n\t\tname = `${original}$${i++}`;\n\t}\n\n\treturn name;\n};\n\n/**\n * @param {Node[]} nodes\n * @param {State} state\n */\nconst handle_body = (nodes, state) => {\n\tconst chunks = [];\n\n\tconst body = nodes.map((statement) => {\n\t\tconst chunks = handle(statement, {\n\t\t\t...state,\n\t\t\tindent: state.indent\n\t\t});\n\n\t\tlet add_newline = false;\n\n\t\twhile (state.comments.length) {\n\t\t\tconst comment = state.comments.shift();\n\t\t\tconst prefix = add_newline ? `\\n${state.indent}` : ` `;\n\n\t\t\tchunks.push(\n\t\t\t\tc(\n\t\t\t\t\tcomment.type === 'Block'\n\t\t\t\t\t\t? `${prefix}/*${comment.value}*/`\n\t\t\t\t\t\t: `${prefix}//${comment.value}`\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tadd_newline = comment.type === 'Line';\n\t\t}\n\n\t\treturn chunks;\n\t});\n\n\tlet needed_padding = false;\n\n\tfor (let i = 0; i < body.length; i += 1) {\n\t\tconst needs_padding = has_newline(body[i]);\n\n\t\tif (i > 0) {\n\t\t\tchunks.push(\n\t\t\t\tc(\n\t\t\t\t\tneeds_padding || needed_padding\n\t\t\t\t\t\t? `\\n\\n${state.indent}`\n\t\t\t\t\t\t: `\\n${state.indent}`\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tpush_array(chunks, body[i]);\n\n\t\tneeded_padding = needs_padding;\n\t}\n\n\treturn chunks;\n};\n\n/**\n * @param {VariableDeclaration} node\n * @param {State} state\n */\nconst handle_var_declaration = (node, state) => {\n\tconst chunks = [c(`${node.kind} `)];\n\n\tconst declarators = node.declarations.map((d) =>\n\t\thandle(d, {\n\t\t\t...state,\n\t\t\tindent: state.indent + (node.declarations.length === 1 ? '' : '\\t')\n\t\t})\n\t);\n\n\tconst multiple_lines =\n\t\tdeclarators.some(has_newline) ||\n\t\tdeclarators.map(get_length).reduce(sum, 0) +\n\t\t\t(state.indent.length + declarators.length - 1) * 2 >\n\t\t\t80;\n\n\tconst separator = c(multiple_lines ? `,\\n${state.indent}\\t` : ', ');\n\n\tpush_array(chunks, join(declarators, separator));\n\n\treturn chunks;\n};\n\n/** @type {Record<string, Handler>} */\nconst handlers = {\n\tProgram(node, state) {\n\t\treturn handle_body(node.body, state);\n\t},\n\n\tBlockStatement: scoped((node, state) => {\n\t\treturn [\n\t\t\tc(`{\\n${state.indent}\\t`),\n\t\t\t...handle_body(node.body, { ...state, indent: state.indent + '\\t' }),\n\t\t\tc(`\\n${state.indent}}`)\n\t\t];\n\t}),\n\n\tEmptyStatement(node, state) {\n\t\treturn [c(';')];\n\t},\n\n\tParenthesizedExpression(node, state) {\n\t\treturn handle(node.expression, state);\n\t},\n\n\tExpressionStatement(node, state) {\n\t\tif (\n\t\t\tnode.expression.type === 'AssignmentExpression' &&\n\t\t\tnode.expression.left.type === 'ObjectPattern'\n\t\t) {\n\t\t\t// is an AssignmentExpression to an ObjectPattern\n\t\t\treturn [c('('), ...handle(node.expression, state), c(');')];\n\t\t}\n\n\t\treturn [...handle(node.expression, state), c(';')];\n\t},\n\n\tIfStatement(node, state) {\n\t\tconst chunks = [\n\t\t\tc('if ('),\n\t\t\t...handle(node.test, state),\n\t\t\tc(') '),\n\t\t\t...handle(node.consequent, state)\n\t\t];\n\n\t\tif (node.alternate) {\n\t\t\tchunks.push(c(' else '));\n\t\t\tpush_array(chunks, handle(node.alternate, state));\n\t\t}\n\n\t\treturn chunks;\n\t},\n\n\tLabeledStatement(node, state) {\n\t\treturn [...handle(node.label, state), c(': '), ...handle(node.body, state)];\n\t},\n\n\tBreakStatement(node, state) {\n\t\treturn node.label\n\t\t\t? [c('break '), ...handle(node.label, state), c(';')]\n\t\t\t: [c('break;')];\n\t},\n\n\tContinueStatement(node, state) {\n\t\treturn node.label\n\t\t\t? [c('continue '), ...handle(node.label, state), c(';')]\n\t\t\t: [c('continue;')];\n\t},\n\n\tWithStatement(node, state) {\n\t\treturn [\n\t\t\tc('with ('),\n\t\t\t...handle(node.object, state),\n\t\t\tc(') '),\n\t\t\t...handle(node.body, state)\n\t\t];\n\t},\n\n\tSwitchStatement(/** @type {SwitchStatement} */ node, state) {\n\t\tconst chunks = [\n\t\t\tc('switch ('),\n\t\t\t...handle(node.discriminant, state),\n\t\t\tc(') {')\n\t\t];\n\n\t\tnode.cases.forEach((block) => {\n\t\t\tif (block.test) {\n\t\t\t\tchunks.push(c(`\\n${state.indent}\\tcase `));\n\t\t\t\tpush_array(\n\t\t\t\t\tchunks,\n\t\t\t\t\thandle(block.test, { ...state, indent: `${state.indent}\\t` })\n\t\t\t\t);\n\t\t\t\tchunks.push(c(':'));\n\t\t\t} else {\n\t\t\t\tchunks.push(c(`\\n${state.indent}\\tdefault:`));\n\t\t\t}\n\n\t\t\tblock.consequent.forEach((statement) => {\n\t\t\t\tchunks.push(c(`\\n${state.indent}\\t\\t`));\n\t\t\t\tpush_array(\n\t\t\t\t\tchunks,\n\t\t\t\t\thandle(statement, { ...state, indent: `${state.indent}\\t\\t` })\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tchunks.push(c(`\\n${state.indent}}`));\n\n\t\treturn chunks;\n\t},\n\n\tReturnStatement(node, state) {\n\t\tif (node.argument) {\n\t\t\tconst contains_comment =\n\t\t\t\tnode.argument.leadingComments &&\n\t\t\t\tnode.argument.leadingComments.some(\n\t\t\t\t\t(\n\t\t\t\t\t\t/** @type import('../utils/comments.js').CommentWithLocation */ comment\n\t\t\t\t\t) => comment.has_trailing_newline\n\t\t\t\t);\n\t\t\treturn [\n\t\t\t\tc(contains_comment ? 'return (' : 'return '),\n\t\t\t\t...handle(node.argument, state),\n\t\t\t\tc(contains_comment ? ');' : ';')\n\t\t\t];\n\t\t} else {\n\t\t\treturn [c('return;')];\n\t\t}\n\t},\n\n\tThrowStatement(node, state) {\n\t\treturn [c('throw '), ...handle(node.argument, state), c(';')];\n\t},\n\n\tTryStatement(node, state) {\n\t\tconst chunks = [c('try '), ...handle(node.block, state)];\n\n\t\tif (node.handler) {\n\t\t\tif (node.handler.param) {\n\t\t\t\tchunks.push(c(' catch('));\n\t\t\t\tpush_array(chunks, handle(node.handler.param, state));\n\t\t\t\tchunks.push(c(') '));\n\t\t\t} else {\n\t\t\t\tchunks.push(c(' catch '));\n\t\t\t}\n\n\t\t\tpush_array(chunks, handle(node.handler.body, state));\n\t\t}\n\n\t\tif (node.finalizer) {\n\t\t\tchunks.push(c(' finally '));\n\t\t\tpush_array(chunks, handle(node.finalizer, state));\n\t\t}\n\n\t\treturn chunks;\n\t},\n\n\tWhileStatement(node, state) {\n\t\treturn [\n\t\t\tc('while ('),\n\t\t\t...handle(node.test, state),\n\t\t\tc(') '),\n\t\t\t...handle(node.body, state)\n\t\t];\n\t},\n\n\tDoWhileStatement(node, state) {\n\t\treturn [\n\t\t\tc('do '),\n\t\t\t...handle(node.body, state),\n\t\t\tc(' while ('),\n\t\t\t...handle(node.test, state),\n\t\t\tc(');')\n\t\t];\n\t},\n\n\tForStatement: scoped((node, state) => {\n\t\tconst chunks = [c('for (')];\n\n\t\tif (node.init) {\n\t\t\tif (node.init.type === 'VariableDeclaration') {\n\t\t\t\tpush_array(chunks, handle_var_declaration(node.init, state));\n\t\t\t} else {\n\t\t\t\tpush_array(chunks, handle(node.init, state));\n\t\t\t}\n\t\t}\n\n\t\tchunks.push(c('; '));\n\t\tif (node.test) push_array(chunks, handle(node.test, state));\n\t\tchunks.push(c('; '));\n\t\tif (node.update) push_array(chunks, handle(node.update, state));\n\n\t\tchunks.push(c(') '));\n\t\tpush_array(chunks, handle(node.body, state));\n\n\t\treturn chunks;\n\t}),\n\n\tForInStatement: scoped((node, state) => {\n\t\tconst chunks = [c(`for ${node.await ? 'await ' : ''}(`)];\n\n\t\tif (node.left.type === 'VariableDeclaration') {\n\t\t\tpush_array(chunks, handle_var_declaration(node.left, state));\n\t\t} else {\n\t\t\tpush_array(chunks, handle(node.left, state));\n\t\t}\n\n\t\tchunks.push(c(node.type === 'ForInStatement' ? ` in ` : ` of `));\n\t\tpush_array(chunks, handle(node.right, state));\n\t\tchunks.push(c(') '));\n\t\tpush_array(chunks, handle(node.body, state));\n\n\t\treturn chunks;\n\t}),\n\n\tDebuggerStatement(node, state) {\n\t\treturn [c('debugger', node), c(';')];\n\t},\n\n\tFunctionDeclaration: scoped(\n\t\t(/** @type {FunctionDeclaration} */ node, state) => {\n\t\t\tconst chunks = [];\n\n\t\t\tif (node.async) chunks.push(c('async '));\n\t\t\tchunks.push(c(node.generator ? 'function* ' : 'function '));\n\t\t\tif (node.id) push_array(chunks, handle(node.id, state));\n\t\t\tchunks.push(c('('));\n\n\t\t\tconst params = node.params.map((p) =>\n\t\t\t\thandle(p, {\n\t\t\t\t\t...state,\n\t\t\t\t\tindent: state.indent + '\\t'\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tconst multiple_lines =\n\t\t\t\tparams.some(has_newline) ||\n\t\t\t\tparams.map(get_length).reduce(sum, 0) +\n\t\t\t\t\t(state.indent.length + params.length - 1) * 2 >\n\t\t\t\t\t80;\n\n\t\t\tconst separator = c(multiple_lines ? `,\\n${state.indent}` : ', ');\n\n\t\t\tif (multiple_lines) {\n\t\t\t\tchunks.push(c(`\\n${state.indent}\\t`));\n\t\t\t\tpush_array(chunks, join(params, separator));\n\t\t\t\tchunks.push(c(`\\n${state.indent}`));\n\t\t\t} else {\n\t\t\t\tpush_array(chunks, join(params, separator));\n\t\t\t}\n\n\t\t\tchunks.push(c(') '));\n\t\t\tpush_array(chunks, handle(node.body, state));\n\n\t\t\treturn chunks;\n\t\t}\n\t),\n\n\tVariableDeclaration(node, state) {\n\t\treturn handle_var_declaration(node, state).concat(c(';'));\n\t},\n\n\tVariableDeclarator(node, state) {\n\t\tif (node.init) {\n\t\t\treturn [...handle(node.id, state), c(' = '), ...handle(node.init, state)];\n\t\t} else {\n\t\t\treturn handle(node.id, state);\n\t\t}\n\t},\n\n\tClassDeclaration(node, state) {\n\t\tconst chunks = [c('class ')];\n\n\t\tif (node.id) {\n\t\t\tpush_array(chunks, handle(node.id, state));\n\t\t\tchunks.push(c(' '));\n\t\t}\n\n\t\tif (node.superClass) {\n\t\t\tchunks.push(c('extends '));\n\t\t\tpush_array(chunks, handle(node.superClass, state));\n\t\t\tchunks.push(c(' '));\n\t\t}\n\n\t\tpush_array(chunks, handle(node.body, state));\n\n\t\treturn chunks;\n\t},\n\n\tImportDeclaration(/** @type {ImportDeclaration} */ node, state) {\n\t\tconst chunks = [c('import ')];\n\n\t\tconst { length } = node.specifiers;\n\t\tconst source = handle(node.source, state);\n\n\t\tif (length > 0) {\n\t\t\tlet i = 0;\n\n\t\t\twhile (i < length) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tchunks.push(c(', '));\n\t\t\t\t}\n\n\t\t\t\tconst specifier = node.specifiers[i];\n\n\t\t\t\tif (specifier.type === 'ImportDefaultSpecifier') {\n\t\t\t\t\tchunks.push(c(specifier.local.name, specifier));\n\t\t\t\t\ti += 1;\n\t\t\t\t} else if (specifier.type === 'ImportNamespaceSpecifier') {\n\t\t\t\t\tchunks.push(c('* as ' + specifier.local.name, specifier));\n\t\t\t\t\ti += 1;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i < length) {\n\t\t\t\t// we have named specifiers\n\t\t\t\tconst specifiers = node.specifiers\n\t\t\t\t\t.slice(i)\n\t\t\t\t\t.map((/** @type {ImportSpecifier} */ specifier) => {\n\t\t\t\t\t\tconst name = handle(specifier.imported, state)[0];\n\t\t\t\t\t\tconst as = handle(specifier.local, state)[0];\n\n\t\t\t\t\t\tif (name.content === as.content) {\n\t\t\t\t\t\t\treturn [as];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [name, c(' as '), as];\n\t\t\t\t\t});\n\n\t\t\t\tconst width =\n\t\t\t\t\tget_length(chunks) +\n\t\t\t\t\tspecifiers.map(get_length).reduce(sum, 0) +\n\t\t\t\t\t2 * specifiers.length +\n\t\t\t\t\t6 +\n\t\t\t\t\tget_length(source);\n\n\t\t\t\tif (width > 80) {\n\t\t\t\t\tchunks.push(c(`{\\n\\t`));\n\t\t\t\t\tpush_array(chunks, join(specifiers, c(',\\n\\t')));\n\t\t\t\t\tchunks.push(c('\\n}'));\n\t\t\t\t} else {\n\t\t\t\t\tchunks.push(c(`{ `));\n\t\t\t\t\tpush_array(chunks, join(specifiers, c(', ')));\n\t\t\t\t\tchunks.push(c(' }'));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchunks.push(c(' from '));\n\t\t}\n\n\t\tpush_array(chunks, source);\n\t\tchunks.push(c(';'));\n\n\t\treturn chunks;\n\t},\n\n\tImportExpression(node, state) {\n\t\treturn [c('import('), ...handle(node.source, state), c(')')];\n\t},\n\n\tExportDefaultDeclaration(node, state) {\n\t\tconst chunks = [c(`export default `), ...handle(node.declaration, state)];\n\n\t\tif (node.declaration.type !== 'FunctionDeclaration') {\n\t\t\tchunks.push(c(';'));\n\t\t}\n\n\t\treturn chunks;\n\t},\n\n\tExportNamedDeclaration(node, state) {\n\t\tconst chunks = [c('export ')];\n\n\t\tif (node.declaration) {\n\t\t\tpush_array(chunks, handle(node.declaration, state));\n\t\t} else {\n\t\t\tconst specifiers = node.specifiers.map(\n\t\t\t\t(/** @type {ExportSpecifier} */ specifier) => {\n\t\t\t\t\tconst name = handle(specifier.local, state)[0];\n\t\t\t\t\tconst as = handle(specifier.exported, state)[0];\n\n\t\t\t\t\tif (name.content === as.content) {\n\t\t\t\t\t\treturn [name];\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [name, c(' as '), as];\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tconst width =\n\t\t\t\t7 + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length;\n\n\t\t\tif (width > 80) {\n\t\t\t\tchunks.push(c('{\\n\\t'));\n\t\t\t\tpush_array(chunks, join(specifiers, c(',\\n\\t')));\n\t\t\t\tchunks.push(c('\\n}'));\n\t\t\t} else {\n\t\t\t\tchunks.push(c('{ '));\n\t\t\t\tpush_array(chunks, join(specifiers, c(', ')));\n\t\t\t\tchunks.push(c(' }'));\n\t\t\t}\n\n\t\t\tif (node.source) {\n\t\t\t\tchunks.push(c(' from '));\n\t\t\t\tpush_array(chunks, handle(node.source, state));\n\t\t\t}\n\t\t}\n\n\t\tchunks.push(c(';'));\n\n\t\treturn chunks;\n\t},\n\n\tExportAllDeclaration(node, state) {\n\t\treturn [c(`export * from `), ...handle(node.source, state), c(`;`)];\n\t},\n\n\tMethodDefinition(node, state) {\n\t\tconst chunks = [];\n\n\t\tif (node.static) {\n\t\t\tchunks.push(c('static '));\n\t\t}\n\n\t\tif (node.kind === 'get' || node.kind === 'set') {\n\t\t\t// Getter or setter\n\t\t\tchunks.push(c(node.kind + ' '));\n\t\t}\n\n\t\tif (node.value.async) {\n\t\t\tchunks.push(c('async '));\n\t\t}\n\n\t\tif (node.value.generator) {\n\t\t\tchunks.push(c('*'));\n\t\t}\n\n\t\tif (node.computed) {\n\t\t\tchunks.push(c('['));\n\t\t\tpush_array(chunks, handle(node.key, state));\n\t\t\tchunks.push(c(']'));\n\t\t} else {\n\t\t\tpush_array(chunks, handle(node.key, state));\n\t\t}\n\n\t\tchunks.push(c('('));\n\n\t\tconst { params } = node.value;\n\t\tfor (let i = 0; i < params.length; i += 1) {\n\t\t\tpush_array(chunks, handle(params[i], state));\n\t\t\tif (i < params.length - 1) chunks.push(c(', '));\n\t\t}\n\n\t\tchunks.push(c(') '));\n\t\tpush_array(chunks, handle(node.value.body, state));\n\n\t\treturn chunks;\n\t},\n\n\tArrowFunctionExpression: scoped(\n\t\t(/** @type {ArrowFunctionExpression} */ node, state) => {\n\t\t\tconst chunks = [];\n\n\t\t\tif (node.async) chunks.push(c('async '));\n\n\t\t\tif (node.params.length === 1 && node.params[0].type === 'Identifier') {\n\t\t\t\tpush_array(chunks, handle(node.params[0], state));\n\t\t\t} else {\n\t\t\t\tconst params = node.params.map((param) =>\n\t\t\t\t\thandle(param, {\n\t\t\t\t\t\t...state,\n\t\t\t\t\t\tindent: state.indent + '\\t'\n\t\t\t\t\t})\n\t\t\t\t);\n\n\t\t\t\tchunks.push(c('('));\n\t\t\t\tpush_array(chunks, join(params, c(', ')));\n\t\t\t\tchunks.push(c(')'));\n\t\t\t}\n\n\t\t\tchunks.push(c(' => '));\n\n\t\t\tif (\n\t\t\t\tnode.body.type === 'ObjectExpression' ||\n\t\t\t\t(node.body.type === 'AssignmentExpression' &&\n\t\t\t\t\tnode.body.left.type === 'ObjectPattern')\n\t\t\t) {\n\t\t\t\tchunks.push(c('('));\n\t\t\t\tpush_array(chunks, handle(node.body, state));\n\t\t\t\tchunks.push(c(')'));\n\t\t\t} else {\n\t\t\t\tpush_array(chunks, handle(node.body, state));\n\t\t\t}\n\n\t\t\treturn chunks;\n\t\t}\n\t),\n\n\tThisExpression(node, state) {\n\t\treturn [c('this', node)];\n\t},\n\n\tSuper(node, state) {\n\t\treturn [c('super', node)];\n\t},\n\n\tRestElement(node, state) {\n\t\treturn [c('...'), ...handle(node.argument, state)];\n\t},\n\n\tYieldExpression(node, state) {\n\t\tif (node.argument) {\n\t\t\treturn [\n\t\t\t\tc(node.delegate ? `yield* ` : `yield `),\n\t\t\t\t...handle(node.argument, state)\n\t\t\t];\n\t\t}\n\n\t\treturn [c(node.delegate ? `yield*` : `yield`)];\n\t},\n\n\tAwaitExpression(node, state) {\n\t\tif (node.argument) {\n\t\t\tconst precedence = EXPRESSIONS_PRECEDENCE[node.argument.type];\n\n\t\t\tif (precedence && precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression) {\n\t\t\t\treturn [c('await ('), ...handle(node.argument, state), c(')')];\n\t\t\t} else {\n\t\t\t\treturn [c('await '), ...handle(node.argument, state)];\n\t\t\t}\n\t\t}\n\n\t\treturn [c('await')];\n\t},\n\n\tTemplateLiteral(node, state) {\n\t\tconst chunks = [c('`')];\n\n\t\tconst { quasis, expressions } = node;\n\n\t\tfor (let i = 0; i < expressions.length; i++) {\n\t\t\tchunks.push(c(quasis[i].value.raw), c('${'));\n\t\t\tpush_array(chunks, handle(expressions[i], state));\n\t\t\tchunks.push(c('}'));\n\t\t}\n\n\t\tchunks.push(c(quasis[quasis.length - 1].value.raw), c('`'));\n\n\t\treturn chunks;\n\t},\n\n\tTaggedTemplateExpression(node, state) {\n\t\treturn handle(node.tag, state).concat(handle(node.quasi, state));\n\t},\n\n\tArrayExpression(node, state) {\n\t\tconst chunks = [c('[')];\n\n\t\t/** @type {Chunk[][]} */\n\t\tconst elements = [];\n\n\t\t/** @type {Chunk[]} */\n\t\tlet sparse_commas = [];\n\n\t\tfor (let i = 0; i < node.elements.length; i += 1) {\n\t\t\t// can't use map/forEach because of sparse arrays\n\t\t\tconst element = node.elements[i];\n\t\t\tif (element) {\n\t\t\t\telements.push([\n\t\t\t\t\t...sparse_commas,\n\t\t\t\t\t...handle(element, {\n\t\t\t\t\t\t...state,\n\t\t\t\t\t\tindent: state.indent + '\\t'\n\t\t\t\t\t})\n\t\t\t\t]);\n\t\t\t\tsparse_commas = [];\n\t\t\t} else {\n\t\t\t\tsparse_commas.push(c(','));\n\t\t\t}\n\t\t}\n\n\t\tconst multiple_lines =\n\t\t\telements.some(has_newline) ||\n\t\t\telements.map(get_length).reduce(sum, 0) +\n\t\t\t\t(state.indent.length + elements.length - 1) * 2 >\n\t\t\t\t80;\n\n\t\tif (multiple_lines) {\n\t\t\tchunks.push(c(`\\n${state.indent}\\t`));\n\t\t\tpush_array(chunks, join(elements, c(`,\\n${state.indent}\\t`)));\n\t\t\tchunks.push(c(`\\n${state.indent}`));\n\t\t\tpush_array(chunks, sparse_commas);\n\t\t} else {\n\t\t\tpush_array(chunks, join(elements, c(', ')));\n\t\t\tpush_array(chunks, sparse_commas);\n\t\t}\n\n\t\tchunks.push(c(']'));\n\n\t\treturn chunks;\n\t},\n\n\tObjectExpression(/** @type {ObjectExpression} */ node, state) {\n\t\tif (node.properties.length === 0) {\n\t\t\treturn [c('{}')];\n\t\t}\n\n\t\tlet has_inline_comment = false;\n\n\t\t/** @type {Chunk[]} */\n\t\tconst chunks = [];\n\t\tconst separator = c(', ');\n\n\t\tnode.properties.forEach((p, i) => {\n\t\t\tpush_array(\n\t\t\t\tchunks,\n\t\t\t\thandle(p, {\n\t\t\t\t\t...state,\n\t\t\t\t\tindent: state.indent + '\\t'\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tif (state.comments.length) {\n\t\t\t\t// TODO generalise this, so it works with ArrayExpressions and other things.\n\t\t\t\t// At present, stuff will just get appended to the closest statement/declaration\n\t\t\t\tchunks.push(c(', '));\n\n\t\t\t\twhile (state.comments.length) {\n\t\t\t\t\tconst comment = state.comments.shift();\n\n\t\t\t\t\tchunks.push(\n\t\t\t\t\t\tc(\n\t\t\t\t\t\t\tcomment.type === 'Block'\n\t\t\t\t\t\t\t\t? `/*${comment.value}*/\\n${state.indent}\\t`\n\t\t\t\t\t\t\t\t: `//${comment.value}\\n${state.indent}\\t`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\tif (comment.type === 'Line') {\n\t\t\t\t\t\thas_inline_comment = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (i < node.properties.length - 1) {\n\t\t\t\t\tchunks.push(separator);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst multiple_lines =\n\t\t\thas_inline_comment || has_newline(chunks) || get_length(chunks) > 40;\n\n\t\tif (multiple_lines) {\n\t\t\tseparator.content = `,\\n${state.indent}\\t`;\n\t\t}\n\n\t\treturn [\n\t\t\tc(multiple_lines ? `{\\n${state.indent}\\t` : `{ `),\n\t\t\t...chunks,\n\t\t\tc(multiple_lines ? `\\n${state.indent}}` : ` }`)\n\t\t];\n\t},\n\n\tProperty(node, state) {\n\t\tconst value = handle(node.value, state);\n\n\t\tif (node.key === node.value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t// special case\n\t\tif (\n\t\t\t!node.computed &&\n\t\t\tnode.value.type === 'AssignmentPattern' &&\n\t\t\tnode.value.left.type === 'Identifier' &&\n\t\t\tnode.value.left.name === node.key.name\n\t\t) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (\n\t\t\t!node.computed &&\n\t\t\tnode.value.type === 'Identifier' &&\n\t\t\t((node.key.type === 'Identifier' && node.key.name === value[0].content) ||\n\t\t\t\t(node.key.type === 'Literal' && node.key.value === value[0].content))\n\t\t) {\n\t\t\treturn value;\n\t\t}\n\n\t\tconst key = handle(node.key, state);\n\n\t\tif (node.value.type === 'FunctionExpression' && !node.value.id) {\n\t\t\tstate = {\n\t\t\t\t...state,\n\t\t\t\tscope: state.scope_map.get(node.value)\n\t\t\t};\n\n\t\t\tconst chunks = node.kind !== 'init' ? [c(`${node.kind} `)] : [];\n\n\t\t\tif (node.value.async) {\n\t\t\t\tchunks.push(c('async '));\n\t\t\t}\n\t\t\tif (node.value.generator) {\n\t\t\t\tchunks.push(c('*'));\n\t\t\t}\n\n\t\t\tpush_array(chunks, node.computed ? [c('['), ...key, c(']')] : key);\n\t\t\tchunks.push(c('('));\n\t\t\tpush_array(\n\t\t\t\tchunks,\n\t\t\t\tjoin(\n\t\t\t\t\tnode.value.params.map((/** @type {Pattern} */ param) =>\n\t\t\t\t\t\thandle(param, state)\n\t\t\t\t\t),\n\t\t\t\t\tc(', ')\n\t\t\t\t)\n\t\t\t);\n\t\t\tchunks.push(c(') '));\n\t\t\tpush_array(chunks, handle(node.value.body, state));\n\n\t\t\treturn chunks;\n\t\t}\n\n\t\tif (node.computed) {\n\t\t\treturn [c('['), ...key, c(']: '), ...value];\n\t\t}\n\n\t\treturn [...key, c(': '), ...value];\n\t},\n\n\tObjectPattern(node, state) {\n\t\tconst chunks = [c('{ ')];\n\n\t\tfor (let i = 0; i < node.properties.length; i += 1) {\n\t\t\tpush_array(chunks, handle(node.properties[i], state));\n\t\t\tif (i < node.properties.length - 1) chunks.push(c(', '));\n\t\t}\n\n\t\tchunks.push(c(' }'));\n\n\t\treturn chunks;\n\t},\n\n\tSequenceExpression(/** @type {SequenceExpression} */ node, state) {\n\t\tconst expressions = node.expressions.map((e) => handle(e, state));\n\n\t\treturn [c('('), ...join(expressions, c(', ')), c(')')];\n\t},\n\n\tUnaryExpression(node, state) {\n\t\tconst chunks = [c(node.operator)];\n\n\t\tif (node.operator.length > 1) {\n\t\t\tchunks.push(c(' '));\n\t\t}\n\n\t\tif (\n\t\t\tEXPRESSIONS_PRECEDENCE[node.argument.type] <\n\t\t\tEXPRESSIONS_PRECEDENCE.UnaryExpression\n\t\t) {\n\t\t\tchunks.push(c('('));\n\t\t\tpush_array(chunks, handle(node.argument, state));\n\t\t\tchunks.push(c(')'));\n\t\t} else {\n\t\t\tpush_array(chunks, handle(node.argument, state));\n\t\t}\n\n\t\treturn chunks;\n\t},\n\n\tUpdateExpression(node, state) {\n\t\treturn node.prefix\n\t\t\t? [c(node.operator), ...handle(node.argument, state)]\n\t\t\t: [...handle(node.argument, state), c(node.operator)];\n\t},\n\n\tAssignmentExpression(node, state) {\n\t\treturn [\n\t\t\t...handle(node.left, state),\n\t\t\tc(` ${node.operator || '='} `),\n\t\t\t...handle(node.right, state)\n\t\t];\n\t},\n\n\tBinaryExpression(node, state) {\n\t\t/**\n\t\t * @type any[]\n\t\t */\n\t\tconst chunks = [];\n\n\t\t// TODO\n\t\t// const is_in = node.operator === 'in';\n\t\t// if (is_in) {\n\t\t// \t// Avoids confusion in `for` loops initializers\n\t\t// \tchunks.push(c('('));\n\t\t// }\n\n\t\tif (needs_parens(node.left, node, false)) {\n\t\t\tchunks.push(c('('));\n\t\t\tpush_array(chunks, handle(node.left, state));\n\t\t\tchunks.push(c(')'));\n\t\t} else {\n\t\t\tpush_array(chunks, handle(node.left, state));\n\t\t}\n\n\t\tchunks.push(c(` ${node.operator} `));\n\n\t\tif (needs_parens(node.right, node, true)) {\n\t\t\tchunks.push(c('('));\n\t\t\tpush_array(chunks, handle(node.right, state));\n\t\t\tchunks.push(c(')'));\n\t\t} else {\n\t\t\tpush_array(chunks, handle(node.right, state));\n\t\t}\n\n\t\treturn chunks;\n\t},\n\n\tConditionalExpression(node, state) {\n\t\t/**\n\t\t * @type any[]\n\t\t */\n\t\tconst chunks = [];\n\n\t\tif (\n\t\t\tEXPRESSIONS_PRECEDENCE[node.test.type] >\n\t\t\tEXPRESSIONS_PRECEDENCE.ConditionalExpression\n\t\t) {\n\t\t\tpush_array(chunks, handle(node.test, state));\n\t\t} else {\n\t\t\tchunks.push(c('('));\n\t\t\tpush_array(chunks, handle(node.test, state));\n\t\t\tchunks.push(c(')'));\n\t\t}\n\n\t\tconst child_state = { ...state, indent: state.indent + '\\t' };\n\n\t\tconst consequent = handle(node.consequent, child_state);\n\t\tconst alternate = handle(node.alternate, child_state);\n\n\t\tconst multiple_lines =\n\t\t\thas_newline(consequent) ||\n\t\t\thas_newline(alternate) ||\n\t\t\tget_length(chunks) + get_length(consequent) + get_length(alternate) > 50;\n\n\t\tif (multiple_lines) {\n\t\t\tchunks.push(c(`\\n${state.indent}? `));\n\t\t\tpush_array(chunks, consequent);\n\t\t\tchunks.push(c(`\\n${state.indent}: `));\n\t\t\tpush_array(chunks, alternate);\n\t\t} else {\n\t\t\tchunks.push(c(` ? `));\n\t\t\tpush_array(chunks, consequent);\n\t\t\tchunks.push(c(` : `));\n\t\t\tpush_array(chunks, alternate);\n\t\t}\n\n\t\treturn chunks;\n\t},\n\n\tNewExpression(/** @type {NewExpression} */ node, state) {\n\t\tconst chunks = [c('new ')];\n\n\t\tif (\n\t\t\tEXPRESSIONS_PRECEDENCE[node.callee.type] <\n\t\t\t\tEXPRESSIONS_PRECEDENCE.CallExpression ||\n\t\t\thas_call_expression(node.callee)\n\t\t) {\n\t\t\tchunks.push(c('('));\n\t\t\tpush_array(chunks, handle(node.callee, state));\n\t\t\tchunks.push(c(')'));\n\t\t} else {\n\t\t\tpush_array(chunks, handle(node.callee, state));\n\t\t}\n\n\t\t// TODO this is copied from CallExpression â€” DRY it out\n\t\tconst args = node.arguments.map((arg) =>\n\t\t\thandle(arg, {\n\t\t\t\t...state,\n\t\t\t\tindent: state.indent + '\\t'\n\t\t\t})\n\t\t);\n\n\t\tconst separator = args.some(has_newline) // TODO or length exceeds 80\n\t\t\t? c(',\\n' + state.indent)\n\t\t\t: c(', ');\n\n\t\tchunks.push(c('('));\n\t\tpush_array(chunks, join(args, separator));\n\t\tchunks.push(c(')'));\n\n\t\treturn chunks;\n\t},\n\n\tChainExpression(node, state) {\n\t\treturn handle(node.expression, state);\n\t},\n\n\tCallExpression(/** @type {CallExpression} */ node, state) {\n\t\t/**\n\t\t * @type any[]\n\t\t */\n\t\tconst chunks = [];\n\n\t\tif (\n\t\t\tEXPRESSIONS_PRECEDENCE[node.callee.type] <\n\t\t\tEXPRESSIONS_PRECEDENCE.CallExpression\n\t\t) {\n\t\t\tchunks.push(c('('));\n\t\t\tpush_array(chunks, handle(node.callee, state));\n\t\t\tchunks.push(c(')'));\n\t\t} else {\n\t\t\tpush_array(chunks, handle(node.callee, state));\n\t\t}\n\n\t\tif (/** @type {SimpleCallExpression} */ (node).optional) {\n\t\t\tchunks.push(c('?.'));\n\t\t}\n\n\t\tlet has_inline_comment = false;\n\t\tlet arg_chunks = [];\n\t\touter: for (const arg of node.arguments) {\n\t\t\tconst chunks = [];\n\t\t\twhile (state.comments.length) {\n\t\t\t\tconst comment = state.comments.shift();\n\t\t\t\tif (comment.type === 'Line') {\n\t\t\t\t\thas_inline_comment = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tchunks.push(\n\t\t\t\t\tc(\n\t\t\t\t\t\tcomment.type === 'Block'\n\t\t\t\t\t\t\t? `/*${comment.value}*/ `\n\t\t\t\t\t\t\t: `//${comment.value}`\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tpush_array(chunks, handle(arg, state));\n\t\t\targ_chunks.push(chunks);\n\t\t}\n\n\t\tconst multiple_lines =\n\t\t\thas_inline_comment || arg_chunks.slice(0, -1).some(has_newline); // TODO or length exceeds 80\n\t\tif (multiple_lines) {\n\t\t\t// need to handle args again. TODO find alternative approach?\n\t\t\tconst args = node.arguments.map((arg, i) => {\n\t\t\t\tconst chunks = handle(arg, {\n\t\t\t\t\t...state,\n\t\t\t\t\tindent: `${state.indent}\\t`\n\t\t\t\t});\n\t\t\t\tif (i < node.arguments.length - 1) chunks.push(c(','));\n\t\t\t\twhile (state.comments.length) {\n\t\t\t\t\tconst comment = state.comments.shift();\n\t\t\t\t\tchunks.push(\n\t\t\t\t\t\tc(\n\t\t\t\t\t\t\tcomment.type === 'Block'\n\t\t\t\t\t\t\t\t? ` /*${comment.value}*/ `\n\t\t\t\t\t\t\t\t: ` //${comment.value}`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn chunks;\n\t\t\t});\n\n\t\t\tchunks.push(c(`(\\n${state.indent}\\t`));\n\t\t\tpush_array(chunks, join(args, c(`\\n${state.indent}\\t`)));\n\t\t\tchunks.push(c(`\\n${state.indent})`));\n\t\t} else {\n\t\t\tchunks.push(c('('));\n\t\t\tpush_array(chunks, join(arg_chunks, c(', ')));\n\t\t\tchunks.push(c(')'));\n\t\t}\n\n\t\treturn chunks;\n\t},\n\n\tMemberExpression(node, state) {\n\t\t/**\n\t\t * @type any[]\n\t\t */\n\t\tconst chunks = [];\n\n\t\tif (\n\t\t\tEXPRESSIONS_PRECEDENCE[node.object.type] <\n\t\t\tEXPRESSIONS_PRECEDENCE.MemberExpression\n\t\t) {\n\t\t\tchunks.push(c('('));\n\t\t\tpush_array(chunks, handle(node.object, state));\n\t\t\tchunks.push(c(')'));\n\t\t} else {\n\t\t\tpush_array(chunks, handle(node.object, state));\n\t\t}\n\n\t\tif (node.computed) {\n\t\t\tif (node.optional) {\n\t\t\t\tchunks.push(c('?.'));\n\t\t\t}\n\t\t\tchunks.push(c('['));\n\t\t\tpush_array(chunks, handle(node.property, state));\n\t\t\tchunks.push(c(']'));\n\t\t} else {\n\t\t\tchunks.push(c(node.optional ? '?.' : '.'));\n\t\t\tpush_array(chunks, handle(node.property, state));\n\t\t}\n\n\t\treturn chunks;\n\t},\n\n\tMetaProperty(node, state) {\n\t\treturn [\n\t\t\t...handle(node.meta, state),\n\t\t\tc('.'),\n\t\t\t...handle(node.property, state)\n\t\t];\n\t},\n\n\tIdentifier(node, state) {\n\t\tlet name = node.name;\n\n\t\tif (name[0] === '@') {\n\t\t\tname = state.getName(name.slice(1));\n\t\t} else if (node.name[0] === '#') {\n\t\t\tconst owner = state.scope.find_owner(node.name);\n\n\t\t\tif (!owner) {\n\t\t\t\tthrow new Error(`Could not find owner for node`);\n\t\t\t}\n\n\t\t\tif (!state.deconflicted.has(owner)) {\n\t\t\t\tstate.deconflicted.set(owner, new Map());\n\t\t\t}\n\n\t\t\tconst deconflict_map = state.deconflicted.get(owner);\n\n\t\t\tif (!deconflict_map.has(node.name)) {\n\t\t\t\tdeconflict_map.set(\n\t\t\t\t\tnode.name,\n\t\t\t\t\tdeconflict(node.name.slice(1), owner.references)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tname = deconflict_map.get(node.name);\n\t\t}\n\n\t\treturn [c(name, node)];\n\t},\n\n\tLiteral(/** @type {Literal} */ node, state) {\n\t\tif (typeof node.value === 'string') {\n\t\t\treturn [\n\t\t\t\t// TODO do we need to handle weird unicode characters somehow?\n\t\t\t\t// str.replace(/\\\\u(\\d{4})/g, (m, n) => String.fromCharCode(+n))\n\t\t\t\tc(\n\t\t\t\t\t(node.raw || JSON.stringify(node.value)).replace(\n\t\t\t\t\t\tre,\n\t\t\t\t\t\t(_m, _i, at, hash, name) => {\n\t\t\t\t\t\t\tif (at) return '@' + name;\n\t\t\t\t\t\t\tif (hash) return '#' + name;\n\t\t\t\t\t\t\tthrow new Error(`this shouldn't happen`);\n\t\t\t\t\t\t}\n\t\t\t\t\t),\n\t\t\t\t\tnode\n\t\t\t\t)\n\t\t\t];\n\t\t}\n\n\t\treturn [c(node.raw || String(node.value), node)];\n\t},\n\n\tPropertyDefinition(/** @type {PropertyDefinition} */ node, state) {\n\t\tconst chunks = [];\n\n\t\tif (node.static) {\n\t\t\tchunks.push(c('static '));\n\t\t}\n\n\t\tif (node.computed) {\n\t\t\tchunks.push(c('['), ...handle(node.key, state), c(']'));\n\t\t} else {\n\t\t\tchunks.push(...handle(node.key, state));\n\t\t}\n\n\t\tif (node.value) {\n\t\t\tchunks.push(c(' = '));\n\n\t\t\tchunks.push(...handle(node.value, state));\n\t\t}\n\n\t\tchunks.push(c(';'));\n\n\t\treturn chunks;\n\t},\n\n\tStaticBlock(/** @type {StaticBlock} */ node, state) {\n\t\tconst chunks = [c('static ')];\n\n\t\tpush_array(chunks, handlers.BlockStatement(node, state));\n\n\t\treturn chunks;\n\t},\n\n\tPrivateIdentifier(/** @type {PrivateIdenifier} */ node, state) {\n\t\tconst chunks = [c('#')];\n\n\t\tpush_array(chunks, [c(node.name, node)]);\n\n\t\treturn chunks;\n\t}\n};\n\nhandlers.ForOfStatement = handlers.ForInStatement;\nhandlers.FunctionExpression = handlers.FunctionDeclaration;\nhandlers.ClassExpression = handlers.ClassDeclaration;\nhandlers.ClassBody = handlers.BlockStatement;\nhandlers.SpreadElement = handlers.RestElement;\nhandlers.ArrayPattern = handlers.ArrayExpression;\nhandlers.LogicalExpression = handlers.BinaryExpression;\nhandlers.AssignmentPattern = handlers.AssignmentExpression;\n", "import * as perisopic from 'periscopic';\nimport { handle } from './handlers.js';\nimport { encode } from '@jridgewell/sourcemap-codec';\n\n/** @type {(str?: string) => string} str */\nlet btoa = () => {\n\tthrow new Error(\n\t\t'Unsupported environment: `window.btoa` or `Buffer` should be supported.'\n\t);\n};\n\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\tbtoa = (str) => window.btoa(unescape(encodeURIComponent(str)));\n} else if (typeof Buffer === 'function') {\n\tbtoa = (str) => Buffer.from(str, 'utf-8').toString('base64');\n}\n\n/** @typedef {import('estree').Node} Node */\n\n/**\n * @typedef {{\n *   file?: string;\n *   sourceMapSource?: string;\n *   sourceMapContent?: string;\n *   sourceMapEncodeMappings?: boolean; // default true\n *   getName?: (name: string) => string;\n * }} PrintOptions\n */\n\n/**\n * @param {Node} node\n * @param {PrintOptions} opts\n * @returns {{ code: string, map: any }} // TODO\n */\nexport function print(node, opts = {}) {\n\tif (Array.isArray(node)) {\n\t\treturn print(\n\t\t\t{\n\t\t\t\ttype: 'Program',\n\t\t\t\tbody: node,\n\t\t\t\tsourceType: 'module'\n\t\t\t},\n\t\t\topts\n\t\t);\n\t}\n\n\tconst {\n\t\tgetName = /** @param {string} x */ (x) => {\n\t\t\tthrow new Error(`Unhandled sigil @${x}`);\n\t\t}\n\t} = opts;\n\n\tlet { map: scope_map, scope } = perisopic.analyze(node);\n\tconst deconflicted = new WeakMap();\n\n\tconst chunks = handle(node, {\n\t\tindent: '',\n\t\tgetName,\n\t\tscope,\n\t\tscope_map,\n\t\tdeconflicted,\n\t\tcomments: []\n\t});\n\n\t/** @typedef {[number, number, number, number]} Segment */\n\n\tlet code = '';\n\tlet current_column = 0;\n\n\t/** @type {Segment[][]} */\n\tlet mappings = [];\n\n\t/** @type {Segment[]} */\n\tlet current_line = [];\n\n\tfor (let i = 0; i < chunks.length; i += 1) {\n\t\tconst chunk = chunks[i];\n\n\t\tcode += chunk.content;\n\n\t\tif (chunk.loc) {\n\t\t\tcurrent_line.push([\n\t\t\t\tcurrent_column,\n\t\t\t\t0, // source index is always zero\n\t\t\t\tchunk.loc.start.line - 1,\n\t\t\t\tchunk.loc.start.column\n\t\t\t]);\n\t\t}\n\n\t\tfor (let i = 0; i < chunk.content.length; i += 1) {\n\t\t\tif (chunk.content[i] === '\\n') {\n\t\t\t\tmappings.push(current_line);\n\t\t\t\tcurrent_line = [];\n\t\t\t\tcurrent_column = 0;\n\t\t\t} else {\n\t\t\t\tcurrent_column += 1;\n\t\t\t}\n\t\t}\n\n\t\tif (chunk.loc) {\n\t\t\tcurrent_line.push([\n\t\t\t\tcurrent_column,\n\t\t\t\t0, // source index is always zero\n\t\t\t\tchunk.loc.end.line - 1,\n\t\t\t\tchunk.loc.end.column\n\t\t\t]);\n\t\t}\n\t}\n\n\tmappings.push(current_line);\n\n\tconst map = {\n\t\tversion: 3,\n\t\t/** @type {string[]} */\n\t\tnames: [],\n\t\tsources: [opts.sourceMapSource || null],\n\t\tsourcesContent: [opts.sourceMapContent || null],\n\t\tmappings:\n\t\t\topts.sourceMapEncodeMappings == undefined || opts.sourceMapEncodeMappings\n\t\t\t\t? encode(mappings)\n\t\t\t\t: mappings\n\t};\n\n\tObject.defineProperties(map, {\n\t\ttoString: {\n\t\t\tenumerable: false,\n\t\t\tvalue: function toString() {\n\t\t\t\treturn JSON.stringify(this);\n\t\t\t}\n\t\t},\n\t\ttoUrl: {\n\t\t\tenumerable: false,\n\t\t\tvalue: function toUrl() {\n\t\t\t\treturn (\n\t\t\t\t\t'data:application/json;charset=utf-8;base64,' + btoa(this.toString())\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn {\n\t\tcode,\n\t\tmap\n\t};\n}\n", "import * as acorn from 'acorn';\nimport { walk } from 'estree-walker';\nimport { id, re } from './utils/id.js';\nimport { get_comment_handlers } from './utils/comments.js';\n\n/** @typedef {import('estree').Expression} Expression */\n/** @typedef {import('estree').Node} Node */\n/** @typedef {import('estree').ObjectExpression} ObjectExpression */\n/** @typedef {import('estree').Property} Property */\n/** @typedef {import('estree').SpreadElement} SpreadElement */\n\n/** @typedef {import('./utils/comments').CommentWithLocation} CommentWithLocation */\n\n/** @type {Record<string, string>} */\nconst sigils = {\n\t'@': 'AT',\n\t'#': 'HASH'\n};\n\n/** @param {TemplateStringsArray} strings */\nconst join = (strings) => {\n\tlet str = strings[0];\n\tfor (let i = 1; i < strings.length; i += 1) {\n\t\tstr += `_${id}_${i - 1}_${strings[i]}`;\n\t}\n\treturn str.replace(\n\t\t/([@#])(\\w+)/g,\n\t\t(_m, sigil, name) => `_${id}_${sigils[sigil]}_${name}`\n\t);\n};\n\n/**\n * @param {any[]} array\n * @param {any[]} target\n */\nconst flatten_body = (array, target) => {\n\tfor (let i = 0; i < array.length; i += 1) {\n\t\tconst statement = array[i];\n\t\tif (Array.isArray(statement)) {\n\t\t\tflatten_body(statement, target);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (statement.type === 'ExpressionStatement') {\n\t\t\tif (statement.expression === EMPTY) continue;\n\n\t\t\tif (Array.isArray(statement.expression)) {\n\t\t\t\t// TODO this is hacktacular\n\t\t\t\tlet node = statement.expression[0];\n\t\t\t\twhile (Array.isArray(node)) node = node[0];\n\t\t\t\tif (node) node.leadingComments = statement.leadingComments;\n\n\t\t\t\tflatten_body(statement.expression, target);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (/(Expression|Literal)$/.test(statement.expression.type)) {\n\t\t\t\ttarget.push(statement);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (statement.leadingComments)\n\t\t\t\tstatement.expression.leadingComments = statement.leadingComments;\n\t\t\tif (statement.trailingComments)\n\t\t\t\tstatement.expression.trailingComments = statement.trailingComments;\n\n\t\t\ttarget.push(statement.expression);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttarget.push(statement);\n\t}\n\n\treturn target;\n};\n\n/**\n * @param {any[]} array\n * @param {any[]} target\n */\nconst flatten_properties = (array, target) => {\n\tfor (let i = 0; i < array.length; i += 1) {\n\t\tconst property = array[i];\n\n\t\tif (property.value === EMPTY) continue;\n\n\t\tif (property.key === property.value && Array.isArray(property.key)) {\n\t\t\tflatten_properties(property.key, target);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttarget.push(property);\n\t}\n\n\treturn target;\n};\n\n/**\n * @param {any[]} nodes\n * @param {any[]} target\n */\nconst flatten = (nodes, target) => {\n\tfor (let i = 0; i < nodes.length; i += 1) {\n\t\tconst node = nodes[i];\n\n\t\tif (node === EMPTY) continue;\n\n\t\tif (Array.isArray(node)) {\n\t\t\tflatten(node, target);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttarget.push(node);\n\t}\n\n\treturn target;\n};\n\nconst EMPTY = { type: 'Empty' };\n\n/**\n *\n * @param {CommentWithLocation[]} comments\n * @param {string} raw\n * @returns {any}\n */\nconst acorn_opts = (comments, raw) => {\n\tconst { onComment } = get_comment_handlers(comments, raw);\n\treturn {\n\t\tecmaVersion: 2022,\n\t\tsourceType: 'module',\n\t\tallowAwaitOutsideFunction: true,\n\t\tallowImportExportEverywhere: true,\n\t\tallowReturnOutsideFunction: true,\n\t\tonComment\n\t};\n};\n\n/**\n * @param {string} raw\n * @param {Node} node\n * @param {any[]} values\n * @param {CommentWithLocation[]} comments\n */\nconst inject = (raw, node, values, comments) => {\n\tcomments.forEach((comment) => {\n\t\tcomment.value = comment.value.replace(re, (m, i) =>\n\t\t\t+i in values ? values[+i] : m\n\t\t);\n\t});\n\n\tconst { enter, leave } = get_comment_handlers(comments, raw);\n\n\treturn walk(node, {\n\t\tenter,\n\n\t\t/** @param {any} node */\n\t\tleave(node) {\n\t\t\tif (node.type === 'Identifier') {\n\t\t\t\tre.lastIndex = 0;\n\t\t\t\tconst match = re.exec(node.name);\n\n\t\t\t\tif (match) {\n\t\t\t\t\tif (match[1]) {\n\t\t\t\t\t\tif (+match[1] in values) {\n\t\t\t\t\t\t\tlet value = values[+match[1]];\n\n\t\t\t\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\t\t\t\tvalue = {\n\t\t\t\t\t\t\t\t\ttype: 'Identifier',\n\t\t\t\t\t\t\t\t\tname: value,\n\t\t\t\t\t\t\t\t\tleadingComments: node.leadingComments,\n\t\t\t\t\t\t\t\t\ttrailingComments: node.trailingComments\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t} else if (typeof value === 'number') {\n\t\t\t\t\t\t\t\tvalue = {\n\t\t\t\t\t\t\t\t\ttype: 'Literal',\n\t\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t\t\tleadingComments: node.leadingComments,\n\t\t\t\t\t\t\t\t\ttrailingComments: node.trailingComments\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.replace(value || EMPTY);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.name = `${match[2] ? `@` : `#`}${match[4]}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (node.type === 'Literal') {\n\t\t\t\tif (typeof node.value === 'string') {\n\t\t\t\t\tre.lastIndex = 0;\n\t\t\t\t\tconst new_value = /** @type {string} */ (node.value).replace(\n\t\t\t\t\t\tre,\n\t\t\t\t\t\t(m, i) => (+i in values ? values[+i] : m)\n\t\t\t\t\t);\n\t\t\t\t\tconst has_changed = new_value !== node.value;\n\t\t\t\t\tnode.value = new_value;\n\t\t\t\t\tif (has_changed && node.raw) {\n\t\t\t\t\t\t// preserve the quotes\n\t\t\t\t\t\tnode.raw = `${node.raw[0]}${JSON.stringify(node.value).slice(\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t-1\n\t\t\t\t\t\t)}${node.raw[node.raw.length - 1]}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (node.type === 'TemplateElement') {\n\t\t\t\tre.lastIndex = 0;\n\t\t\t\tnode.value.raw = /** @type {string} */ (node.value.raw).replace(\n\t\t\t\t\tre,\n\t\t\t\t\t(m, i) => (+i in values ? values[+i] : m)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (node.type === 'Program' || node.type === 'BlockStatement') {\n\t\t\t\tnode.body = flatten_body(node.body, []);\n\t\t\t}\n\n\t\t\tif (node.type === 'ObjectExpression' || node.type === 'ObjectPattern') {\n\t\t\t\tnode.properties = flatten_properties(node.properties, []);\n\t\t\t}\n\n\t\t\tif (node.type === 'ArrayExpression' || node.type === 'ArrayPattern') {\n\t\t\t\tnode.elements = flatten(node.elements, []);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tnode.type === 'FunctionExpression' ||\n\t\t\t\tnode.type === 'FunctionDeclaration' ||\n\t\t\t\tnode.type === 'ArrowFunctionExpression'\n\t\t\t) {\n\t\t\t\tnode.params = flatten(node.params, []);\n\t\t\t}\n\n\t\t\tif (node.type === 'CallExpression' || node.type === 'NewExpression') {\n\t\t\t\tnode.arguments = flatten(node.arguments, []);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tnode.type === 'ImportDeclaration' ||\n\t\t\t\tnode.type === 'ExportNamedDeclaration'\n\t\t\t) {\n\t\t\t\tnode.specifiers = flatten(node.specifiers, []);\n\t\t\t}\n\n\t\t\tif (node.type === 'ForStatement') {\n\t\t\t\tnode.init = node.init === EMPTY ? null : node.init;\n\t\t\t\tnode.test = node.test === EMPTY ? null : node.test;\n\t\t\t\tnode.update = node.update === EMPTY ? null : node.update;\n\t\t\t}\n\n\t\t\tleave(node);\n\t\t}\n\t});\n};\n\n/**\n *\n * @param {TemplateStringsArray} strings\n * @param  {any[]} values\n * @returns {Node[]}\n */\nexport function b(strings, ...values) {\n\tconst str = join(strings);\n\n\t/** @type {CommentWithLocation[]} */\n\tconst comments = [];\n\n\ttry {\n\t\tlet ast = /** @type {any} */ (acorn.parse(str, acorn_opts(comments, str)));\n\n\t\tast = inject(str, ast, values, comments);\n\n\t\treturn ast.body;\n\t} catch (err) {\n\t\thandle_error(str, err);\n\t}\n}\n\n/**\n *\n * @param {TemplateStringsArray} strings\n * @param  {any[]} values\n * @returns {Expression & { start: Number, end: number }}\n */\nexport function x(strings, ...values) {\n\tconst str = join(strings);\n\n\t/** @type {CommentWithLocation[]} */\n\tconst comments = [];\n\n\ttry {\n\t\tlet expression =\n\t\t\t/** @type {Expression & { start: Number, end: number }} */ (\n\t\t\t\tacorn.parseExpressionAt(str, 0, acorn_opts(comments, str))\n\t\t\t);\n\t\tconst match = /\\S+/.exec(str.slice(expression.end));\n\t\tif (match) {\n\t\t\tthrow new Error(`Unexpected token '${match[0]}'`);\n\t\t}\n\n\t\texpression = /** @type {Expression & { start: Number, end: number }} */ (\n\t\t\tinject(str, expression, values, comments)\n\t\t);\n\n\t\treturn expression;\n\t} catch (err) {\n\t\thandle_error(str, err);\n\t}\n}\n\n/**\n *\n * @param {TemplateStringsArray} strings\n * @param  {any[]} values\n * @returns {(Property | SpreadElement) & { start: Number, end: number }}\n */\nexport function p(strings, ...values) {\n\tconst str = `{${join(strings)}}`;\n\n\t/** @type {CommentWithLocation[]} */\n\tconst comments = [];\n\n\ttry {\n\t\tlet expression = /** @type {any} */ (\n\t\t\tacorn.parseExpressionAt(str, 0, acorn_opts(comments, str))\n\t\t);\n\n\t\texpression = inject(str, expression, values, comments);\n\n\t\treturn expression.properties[0];\n\t} catch (err) {\n\t\thandle_error(str, err);\n\t}\n}\n\n/**\n * @param {string} str\n * @param {Error} err\n */\nfunction handle_error(str, err) {\n\t// TODO location/code frame\n\n\tre.lastIndex = 0;\n\n\tstr = str.replace(re, (m, i, at, hash, name) => {\n\t\tif (at) return `@${name}`;\n\t\tif (hash) return `#${name}`;\n\n\t\treturn '${...}';\n\t});\n\n\tconsole.log(`failed to parse:\\n${str}`);\n\tthrow err;\n}\n\nexport { print } from './print/index.js';\n\n/**\n * @param {string} source\n * @param {any} opts\n */\nexport const parse = (source, opts) => {\n\t/** @type {CommentWithLocation[]} */\n\tconst comments = [];\n\tconst { onComment, enter, leave } = get_comment_handlers(comments, source);\n\tconst ast = /** @type {any} */ (acorn.parse(source, { onComment, ...opts }));\n\twalk(ast, { enter, leave });\n\treturn ast;\n};\n\n/**\n * @param {string} source\n * @param {number} index\n * @param {any} opts\n */\nexport const parseExpressionAt = (source, index, opts) => {\n\t/** @type {CommentWithLocation[]} */\n\tconst comments = [];\n\tconst { onComment, enter, leave } = get_comment_handlers(comments, source);\n\tconst ast = /** @type {any} */ (\n\t\tacorn.parseExpressionAt(source, index, { onComment, ...opts })\n\t);\n\twalk(ast, { enter, leave });\n\treturn ast;\n};\n"],
  "mappings": "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",
  "names": ["b", "id", "b", "chunks", "p", "x", "i", "join", "node", "parse", "parseExpressionAt"]
}
