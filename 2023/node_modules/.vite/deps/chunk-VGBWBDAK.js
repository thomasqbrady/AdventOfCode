import {
  parse,
  parseExpressionAt
} from "./chunk-VC7IVDBA.js";
import {
  analyze
} from "./chunk-XVISMPHF.js";
import {
  walk
} from "./chunk-A2ECB5VU.js";
import {
  require_sourcemap_codec_umd
} from "./chunk-CKUFBTIG.js";
import {
  __toESM
} from "./chunk-ZC22LKFR.js";

// node_modules/code-red/src/utils/id.js
var id = Math.round(Math.random() * 1e20).toString(36);
var re = new RegExp(`_${id}_(?:(\\d+)|(AT)|(HASH))_(\\w+)?`, "g");

// node_modules/code-red/src/utils/comments.js
var get_comment_handlers = (comments, raw) => ({
  // pass to acorn options
  /**
   * @param {boolean} block
   * @param {string} value
   * @param {number} start
   * @param {number} end
   */
  onComment: (block, value, start, end) => {
    if (block && /\n/.test(value)) {
      let a = start;
      while (a > 0 && raw[a - 1] !== "\n")
        a -= 1;
      let b2 = a;
      while (/[ \t]/.test(raw[b2]))
        b2 += 1;
      const indentation = raw.slice(a, b2);
      value = value.replace(new RegExp(`^${indentation}`, "gm"), "");
    }
    comments.push({ type: block ? "Block" : "Line", value, start, end });
  },
  // pass to estree-walker options
  /** @param {NodeWithLocation} node */
  enter(node) {
    let comment;
    while (comments[0] && comments[0].start < node.start) {
      comment = comments.shift();
      comment.value = comment.value.replace(
        re,
        (match, id2, at, hash, value) => {
          if (hash)
            return `#${value}`;
          if (at)
            return `@${value}`;
          return match;
        }
      );
      const next = comments[0] || node;
      comment.has_trailing_newline = comment.type === "Line" || /\n/.test(raw.slice(comment.end, next.start));
      (node.leadingComments || (node.leadingComments = [])).push(comment);
    }
  },
  /** @param {NodeWithLocation} node */
  leave(node) {
    if (comments[0]) {
      const slice = raw.slice(node.end, comments[0].start);
      if (/^[,) \t]*$/.test(slice)) {
        node.trailingComments = [comments.shift()];
      }
    }
  }
});

// node_modules/code-red/src/utils/push_array.js
function push_array(array, items) {
  for (let i = 0; i < items.length; i++) {
    array.push(items[i]);
  }
}

// node_modules/code-red/src/print/handlers.js
function handle(node, state) {
  const handler = handlers[node.type];
  if (!handler) {
    throw new Error(`Not implemented ${node.type}`);
  }
  const result = handler(node, state);
  if (node.leadingComments) {
    result.unshift(
      c(
        node.leadingComments.map(
          (comment) => comment.type === "Block" ? `/*${comment.value}*/${/** @type {any} */
          comment.has_trailing_newline ? `
${state.indent}` : ` `}` : `//${comment.value}${/** @type {any} */
          comment.has_trailing_newline ? `
${state.indent}` : ` `}`
        ).join(``)
      )
    );
  }
  if (node.trailingComments) {
    state.comments.push(node.trailingComments[0]);
  }
  return result;
}
function c(content, node) {
  return {
    content,
    loc: node && node.loc,
    has_newline: /\n/.test(content)
  };
}
var OPERATOR_PRECEDENCE = {
  "||": 2,
  "&&": 3,
  "??": 4,
  "|": 5,
  "^": 6,
  "&": 7,
  "==": 8,
  "!=": 8,
  "===": 8,
  "!==": 8,
  "<": 9,
  ">": 9,
  "<=": 9,
  ">=": 9,
  in: 9,
  instanceof: 9,
  "<<": 10,
  ">>": 10,
  ">>>": 10,
  "+": 11,
  "-": 11,
  "*": 12,
  "%": 12,
  "/": 12,
  "**": 13
};
var EXPRESSIONS_PRECEDENCE = {
  ArrayExpression: 20,
  TaggedTemplateExpression: 20,
  ThisExpression: 20,
  Identifier: 20,
  Literal: 18,
  TemplateLiteral: 20,
  Super: 20,
  SequenceExpression: 20,
  MemberExpression: 19,
  CallExpression: 19,
  NewExpression: 19,
  AwaitExpression: 17,
  ClassExpression: 17,
  FunctionExpression: 17,
  ObjectExpression: 17,
  UpdateExpression: 16,
  UnaryExpression: 15,
  BinaryExpression: 14,
  LogicalExpression: 13,
  ConditionalExpression: 4,
  ArrowFunctionExpression: 3,
  AssignmentExpression: 3,
  YieldExpression: 2,
  RestElement: 1
};
function needs_parens(node, parent, is_right) {
  if (node.type === "LogicalExpression" && parent.type === "LogicalExpression" && (parent.operator === "??" && node.operator !== "??" || parent.operator !== "??" && node.operator === "??")) {
    return true;
  }
  const precedence = EXPRESSIONS_PRECEDENCE[node.type];
  const parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];
  if (precedence !== parent_precedence) {
    return !is_right && precedence === 15 && parent_precedence === 14 && parent.operator === "**" || precedence < parent_precedence;
  }
  if (precedence !== 13 && precedence !== 14) {
    return false;
  }
  if (
    /** @type {BinaryExpression} */
    node.operator === "**" && parent.operator === "**"
  ) {
    return !is_right;
  }
  if (is_right) {
    return OPERATOR_PRECEDENCE[
      /** @type {BinaryExpression} */
      node.operator
    ] <= OPERATOR_PRECEDENCE[parent.operator];
  }
  return OPERATOR_PRECEDENCE[
    /** @type {BinaryExpression} */
    node.operator
  ] < OPERATOR_PRECEDENCE[parent.operator];
}
function has_call_expression(node) {
  while (node) {
    if (node.type[0] === "CallExpression") {
      return true;
    } else if (node.type === "MemberExpression") {
      node = node.object;
    } else {
      return false;
    }
  }
}
var has_newline = (chunks) => {
  for (let i = 0; i < chunks.length; i += 1) {
    if (chunks[i].has_newline)
      return true;
  }
  return false;
};
var get_length = (chunks) => {
  let total = 0;
  for (let i = 0; i < chunks.length; i += 1) {
    total += chunks[i].content.length;
  }
  return total;
};
var sum = (a, b2) => a + b2;
var join = (nodes, separator) => {
  if (nodes.length === 0)
    return [];
  const joined = [...nodes[0]];
  for (let i = 1; i < nodes.length; i += 1) {
    joined.push(separator);
    push_array(joined, nodes[i]);
  }
  return joined;
};
var scoped = (fn) => {
  const scoped_fn = (node, state) => {
    return fn(node, {
      ...state,
      scope: state.scope_map.get(node)
    });
  };
  return scoped_fn;
};
var deconflict = (name, names) => {
  const original = name;
  let i = 1;
  while (names.has(name)) {
    name = `${original}$${i++}`;
  }
  return name;
};
var handle_body = (nodes, state) => {
  const chunks = [];
  const body = nodes.map((statement) => {
    const chunks2 = handle(statement, {
      ...state,
      indent: state.indent
    });
    let add_newline = false;
    while (state.comments.length) {
      const comment = state.comments.shift();
      const prefix = add_newline ? `
${state.indent}` : ` `;
      chunks2.push(
        c(
          comment.type === "Block" ? `${prefix}/*${comment.value}*/` : `${prefix}//${comment.value}`
        )
      );
      add_newline = comment.type === "Line";
    }
    return chunks2;
  });
  let needed_padding = false;
  for (let i = 0; i < body.length; i += 1) {
    const needs_padding = has_newline(body[i]);
    if (i > 0) {
      chunks.push(
        c(
          needs_padding || needed_padding ? `

${state.indent}` : `
${state.indent}`
        )
      );
    }
    push_array(chunks, body[i]);
    needed_padding = needs_padding;
  }
  return chunks;
};
var handle_var_declaration = (node, state) => {
  const chunks = [c(`${node.kind} `)];
  const declarators = node.declarations.map(
    (d) => handle(d, {
      ...state,
      indent: state.indent + (node.declarations.length === 1 ? "" : "	")
    })
  );
  const multiple_lines = declarators.some(has_newline) || declarators.map(get_length).reduce(sum, 0) + (state.indent.length + declarators.length - 1) * 2 > 80;
  const separator = c(multiple_lines ? `,
${state.indent}	` : ", ");
  push_array(chunks, join(declarators, separator));
  return chunks;
};
var handlers = {
  Program(node, state) {
    return handle_body(node.body, state);
  },
  BlockStatement: scoped((node, state) => {
    return [
      c(`{
${state.indent}	`),
      ...handle_body(node.body, { ...state, indent: state.indent + "	" }),
      c(`
${state.indent}}`)
    ];
  }),
  EmptyStatement(node, state) {
    return [c(";")];
  },
  ParenthesizedExpression(node, state) {
    return handle(node.expression, state);
  },
  ExpressionStatement(node, state) {
    if (node.expression.type === "AssignmentExpression" && node.expression.left.type === "ObjectPattern") {
      return [c("("), ...handle(node.expression, state), c(");")];
    }
    return [...handle(node.expression, state), c(";")];
  },
  IfStatement(node, state) {
    const chunks = [
      c("if ("),
      ...handle(node.test, state),
      c(") "),
      ...handle(node.consequent, state)
    ];
    if (node.alternate) {
      chunks.push(c(" else "));
      push_array(chunks, handle(node.alternate, state));
    }
    return chunks;
  },
  LabeledStatement(node, state) {
    return [...handle(node.label, state), c(": "), ...handle(node.body, state)];
  },
  BreakStatement(node, state) {
    return node.label ? [c("break "), ...handle(node.label, state), c(";")] : [c("break;")];
  },
  ContinueStatement(node, state) {
    return node.label ? [c("continue "), ...handle(node.label, state), c(";")] : [c("continue;")];
  },
  WithStatement(node, state) {
    return [
      c("with ("),
      ...handle(node.object, state),
      c(") "),
      ...handle(node.body, state)
    ];
  },
  SwitchStatement(node, state) {
    const chunks = [
      c("switch ("),
      ...handle(node.discriminant, state),
      c(") {")
    ];
    node.cases.forEach((block) => {
      if (block.test) {
        chunks.push(c(`
${state.indent}	case `));
        push_array(
          chunks,
          handle(block.test, { ...state, indent: `${state.indent}	` })
        );
        chunks.push(c(":"));
      } else {
        chunks.push(c(`
${state.indent}	default:`));
      }
      block.consequent.forEach((statement) => {
        chunks.push(c(`
${state.indent}		`));
        push_array(
          chunks,
          handle(statement, { ...state, indent: `${state.indent}		` })
        );
      });
    });
    chunks.push(c(`
${state.indent}}`));
    return chunks;
  },
  ReturnStatement(node, state) {
    if (node.argument) {
      const contains_comment = node.argument.leadingComments && node.argument.leadingComments.some(
        (comment) => comment.has_trailing_newline
      );
      return [
        c(contains_comment ? "return (" : "return "),
        ...handle(node.argument, state),
        c(contains_comment ? ");" : ";")
      ];
    } else {
      return [c("return;")];
    }
  },
  ThrowStatement(node, state) {
    return [c("throw "), ...handle(node.argument, state), c(";")];
  },
  TryStatement(node, state) {
    const chunks = [c("try "), ...handle(node.block, state)];
    if (node.handler) {
      if (node.handler.param) {
        chunks.push(c(" catch("));
        push_array(chunks, handle(node.handler.param, state));
        chunks.push(c(") "));
      } else {
        chunks.push(c(" catch "));
      }
      push_array(chunks, handle(node.handler.body, state));
    }
    if (node.finalizer) {
      chunks.push(c(" finally "));
      push_array(chunks, handle(node.finalizer, state));
    }
    return chunks;
  },
  WhileStatement(node, state) {
    return [
      c("while ("),
      ...handle(node.test, state),
      c(") "),
      ...handle(node.body, state)
    ];
  },
  DoWhileStatement(node, state) {
    return [
      c("do "),
      ...handle(node.body, state),
      c(" while ("),
      ...handle(node.test, state),
      c(");")
    ];
  },
  ForStatement: scoped((node, state) => {
    const chunks = [c("for (")];
    if (node.init) {
      if (node.init.type === "VariableDeclaration") {
        push_array(chunks, handle_var_declaration(node.init, state));
      } else {
        push_array(chunks, handle(node.init, state));
      }
    }
    chunks.push(c("; "));
    if (node.test)
      push_array(chunks, handle(node.test, state));
    chunks.push(c("; "));
    if (node.update)
      push_array(chunks, handle(node.update, state));
    chunks.push(c(") "));
    push_array(chunks, handle(node.body, state));
    return chunks;
  }),
  ForInStatement: scoped((node, state) => {
    const chunks = [c(`for ${node.await ? "await " : ""}(`)];
    if (node.left.type === "VariableDeclaration") {
      push_array(chunks, handle_var_declaration(node.left, state));
    } else {
      push_array(chunks, handle(node.left, state));
    }
    chunks.push(c(node.type === "ForInStatement" ? ` in ` : ` of `));
    push_array(chunks, handle(node.right, state));
    chunks.push(c(") "));
    push_array(chunks, handle(node.body, state));
    return chunks;
  }),
  DebuggerStatement(node, state) {
    return [c("debugger", node), c(";")];
  },
  FunctionDeclaration: scoped(
    (node, state) => {
      const chunks = [];
      if (node.async)
        chunks.push(c("async "));
      chunks.push(c(node.generator ? "function* " : "function "));
      if (node.id)
        push_array(chunks, handle(node.id, state));
      chunks.push(c("("));
      const params = node.params.map(
        (p2) => handle(p2, {
          ...state,
          indent: state.indent + "	"
        })
      );
      const multiple_lines = params.some(has_newline) || params.map(get_length).reduce(sum, 0) + (state.indent.length + params.length - 1) * 2 > 80;
      const separator = c(multiple_lines ? `,
${state.indent}` : ", ");
      if (multiple_lines) {
        chunks.push(c(`
${state.indent}	`));
        push_array(chunks, join(params, separator));
        chunks.push(c(`
${state.indent}`));
      } else {
        push_array(chunks, join(params, separator));
      }
      chunks.push(c(") "));
      push_array(chunks, handle(node.body, state));
      return chunks;
    }
  ),
  VariableDeclaration(node, state) {
    return handle_var_declaration(node, state).concat(c(";"));
  },
  VariableDeclarator(node, state) {
    if (node.init) {
      return [...handle(node.id, state), c(" = "), ...handle(node.init, state)];
    } else {
      return handle(node.id, state);
    }
  },
  ClassDeclaration(node, state) {
    const chunks = [c("class ")];
    if (node.id) {
      push_array(chunks, handle(node.id, state));
      chunks.push(c(" "));
    }
    if (node.superClass) {
      chunks.push(c("extends "));
      push_array(chunks, handle(node.superClass, state));
      chunks.push(c(" "));
    }
    push_array(chunks, handle(node.body, state));
    return chunks;
  },
  ImportDeclaration(node, state) {
    const chunks = [c("import ")];
    const { length } = node.specifiers;
    const source = handle(node.source, state);
    if (length > 0) {
      let i = 0;
      while (i < length) {
        if (i > 0) {
          chunks.push(c(", "));
        }
        const specifier = node.specifiers[i];
        if (specifier.type === "ImportDefaultSpecifier") {
          chunks.push(c(specifier.local.name, specifier));
          i += 1;
        } else if (specifier.type === "ImportNamespaceSpecifier") {
          chunks.push(c("* as " + specifier.local.name, specifier));
          i += 1;
        } else {
          break;
        }
      }
      if (i < length) {
        const specifiers = node.specifiers.slice(i).map((specifier) => {
          const name = handle(specifier.imported, state)[0];
          const as = handle(specifier.local, state)[0];
          if (name.content === as.content) {
            return [as];
          }
          return [name, c(" as "), as];
        });
        const width = get_length(chunks) + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length + 6 + get_length(source);
        if (width > 80) {
          chunks.push(c(`{
	`));
          push_array(chunks, join(specifiers, c(",\n	")));
          chunks.push(c("\n}"));
        } else {
          chunks.push(c(`{ `));
          push_array(chunks, join(specifiers, c(", ")));
          chunks.push(c(" }"));
        }
      }
      chunks.push(c(" from "));
    }
    push_array(chunks, source);
    chunks.push(c(";"));
    return chunks;
  },
  ImportExpression(node, state) {
    return [c("import("), ...handle(node.source, state), c(")")];
  },
  ExportDefaultDeclaration(node, state) {
    const chunks = [c(`export default `), ...handle(node.declaration, state)];
    if (node.declaration.type !== "FunctionDeclaration") {
      chunks.push(c(";"));
    }
    return chunks;
  },
  ExportNamedDeclaration(node, state) {
    const chunks = [c("export ")];
    if (node.declaration) {
      push_array(chunks, handle(node.declaration, state));
    } else {
      const specifiers = node.specifiers.map(
        (specifier) => {
          const name = handle(specifier.local, state)[0];
          const as = handle(specifier.exported, state)[0];
          if (name.content === as.content) {
            return [name];
          }
          return [name, c(" as "), as];
        }
      );
      const width = 7 + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length;
      if (width > 80) {
        chunks.push(c("{\n	"));
        push_array(chunks, join(specifiers, c(",\n	")));
        chunks.push(c("\n}"));
      } else {
        chunks.push(c("{ "));
        push_array(chunks, join(specifiers, c(", ")));
        chunks.push(c(" }"));
      }
      if (node.source) {
        chunks.push(c(" from "));
        push_array(chunks, handle(node.source, state));
      }
    }
    chunks.push(c(";"));
    return chunks;
  },
  ExportAllDeclaration(node, state) {
    return [c(`export * from `), ...handle(node.source, state), c(`;`)];
  },
  MethodDefinition(node, state) {
    const chunks = [];
    if (node.static) {
      chunks.push(c("static "));
    }
    if (node.kind === "get" || node.kind === "set") {
      chunks.push(c(node.kind + " "));
    }
    if (node.value.async) {
      chunks.push(c("async "));
    }
    if (node.value.generator) {
      chunks.push(c("*"));
    }
    if (node.computed) {
      chunks.push(c("["));
      push_array(chunks, handle(node.key, state));
      chunks.push(c("]"));
    } else {
      push_array(chunks, handle(node.key, state));
    }
    chunks.push(c("("));
    const { params } = node.value;
    for (let i = 0; i < params.length; i += 1) {
      push_array(chunks, handle(params[i], state));
      if (i < params.length - 1)
        chunks.push(c(", "));
    }
    chunks.push(c(") "));
    push_array(chunks, handle(node.value.body, state));
    return chunks;
  },
  ArrowFunctionExpression: scoped(
    (node, state) => {
      const chunks = [];
      if (node.async)
        chunks.push(c("async "));
      if (node.params.length === 1 && node.params[0].type === "Identifier") {
        push_array(chunks, handle(node.params[0], state));
      } else {
        const params = node.params.map(
          (param) => handle(param, {
            ...state,
            indent: state.indent + "	"
          })
        );
        chunks.push(c("("));
        push_array(chunks, join(params, c(", ")));
        chunks.push(c(")"));
      }
      chunks.push(c(" => "));
      if (node.body.type === "ObjectExpression" || node.body.type === "AssignmentExpression" && node.body.left.type === "ObjectPattern") {
        chunks.push(c("("));
        push_array(chunks, handle(node.body, state));
        chunks.push(c(")"));
      } else {
        push_array(chunks, handle(node.body, state));
      }
      return chunks;
    }
  ),
  ThisExpression(node, state) {
    return [c("this", node)];
  },
  Super(node, state) {
    return [c("super", node)];
  },
  RestElement(node, state) {
    return [c("..."), ...handle(node.argument, state)];
  },
  YieldExpression(node, state) {
    if (node.argument) {
      return [
        c(node.delegate ? `yield* ` : `yield `),
        ...handle(node.argument, state)
      ];
    }
    return [c(node.delegate ? `yield*` : `yield`)];
  },
  AwaitExpression(node, state) {
    if (node.argument) {
      const precedence = EXPRESSIONS_PRECEDENCE[node.argument.type];
      if (precedence && precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression) {
        return [c("await ("), ...handle(node.argument, state), c(")")];
      } else {
        return [c("await "), ...handle(node.argument, state)];
      }
    }
    return [c("await")];
  },
  TemplateLiteral(node, state) {
    const chunks = [c("`")];
    const { quasis, expressions } = node;
    for (let i = 0; i < expressions.length; i++) {
      chunks.push(c(quasis[i].value.raw), c("${"));
      push_array(chunks, handle(expressions[i], state));
      chunks.push(c("}"));
    }
    chunks.push(c(quasis[quasis.length - 1].value.raw), c("`"));
    return chunks;
  },
  TaggedTemplateExpression(node, state) {
    return handle(node.tag, state).concat(handle(node.quasi, state));
  },
  ArrayExpression(node, state) {
    const chunks = [c("[")];
    const elements = [];
    let sparse_commas = [];
    for (let i = 0; i < node.elements.length; i += 1) {
      const element = node.elements[i];
      if (element) {
        elements.push([
          ...sparse_commas,
          ...handle(element, {
            ...state,
            indent: state.indent + "	"
          })
        ]);
        sparse_commas = [];
      } else {
        sparse_commas.push(c(","));
      }
    }
    const multiple_lines = elements.some(has_newline) || elements.map(get_length).reduce(sum, 0) + (state.indent.length + elements.length - 1) * 2 > 80;
    if (multiple_lines) {
      chunks.push(c(`
${state.indent}	`));
      push_array(chunks, join(elements, c(`,
${state.indent}	`)));
      chunks.push(c(`
${state.indent}`));
      push_array(chunks, sparse_commas);
    } else {
      push_array(chunks, join(elements, c(", ")));
      push_array(chunks, sparse_commas);
    }
    chunks.push(c("]"));
    return chunks;
  },
  ObjectExpression(node, state) {
    if (node.properties.length === 0) {
      return [c("{}")];
    }
    let has_inline_comment = false;
    const chunks = [];
    const separator = c(", ");
    node.properties.forEach((p2, i) => {
      push_array(
        chunks,
        handle(p2, {
          ...state,
          indent: state.indent + "	"
        })
      );
      if (state.comments.length) {
        chunks.push(c(", "));
        while (state.comments.length) {
          const comment = state.comments.shift();
          chunks.push(
            c(
              comment.type === "Block" ? `/*${comment.value}*/
${state.indent}	` : `//${comment.value}
${state.indent}	`
            )
          );
          if (comment.type === "Line") {
            has_inline_comment = true;
          }
        }
      } else {
        if (i < node.properties.length - 1) {
          chunks.push(separator);
        }
      }
    });
    const multiple_lines = has_inline_comment || has_newline(chunks) || get_length(chunks) > 40;
    if (multiple_lines) {
      separator.content = `,
${state.indent}	`;
    }
    return [
      c(multiple_lines ? `{
${state.indent}	` : `{ `),
      ...chunks,
      c(multiple_lines ? `
${state.indent}}` : ` }`)
    ];
  },
  Property(node, state) {
    const value = handle(node.value, state);
    if (node.key === node.value) {
      return value;
    }
    if (!node.computed && node.value.type === "AssignmentPattern" && node.value.left.type === "Identifier" && node.value.left.name === node.key.name) {
      return value;
    }
    if (!node.computed && node.value.type === "Identifier" && (node.key.type === "Identifier" && node.key.name === value[0].content || node.key.type === "Literal" && node.key.value === value[0].content)) {
      return value;
    }
    const key = handle(node.key, state);
    if (node.value.type === "FunctionExpression" && !node.value.id) {
      state = {
        ...state,
        scope: state.scope_map.get(node.value)
      };
      const chunks = node.kind !== "init" ? [c(`${node.kind} `)] : [];
      if (node.value.async) {
        chunks.push(c("async "));
      }
      if (node.value.generator) {
        chunks.push(c("*"));
      }
      push_array(chunks, node.computed ? [c("["), ...key, c("]")] : key);
      chunks.push(c("("));
      push_array(
        chunks,
        join(
          node.value.params.map(
            (param) => handle(param, state)
          ),
          c(", ")
        )
      );
      chunks.push(c(") "));
      push_array(chunks, handle(node.value.body, state));
      return chunks;
    }
    if (node.computed) {
      return [c("["), ...key, c("]: "), ...value];
    }
    return [...key, c(": "), ...value];
  },
  ObjectPattern(node, state) {
    const chunks = [c("{ ")];
    for (let i = 0; i < node.properties.length; i += 1) {
      push_array(chunks, handle(node.properties[i], state));
      if (i < node.properties.length - 1)
        chunks.push(c(", "));
    }
    chunks.push(c(" }"));
    return chunks;
  },
  SequenceExpression(node, state) {
    const expressions = node.expressions.map((e) => handle(e, state));
    return [c("("), ...join(expressions, c(", ")), c(")")];
  },
  UnaryExpression(node, state) {
    const chunks = [c(node.operator)];
    if (node.operator.length > 1) {
      chunks.push(c(" "));
    }
    if (EXPRESSIONS_PRECEDENCE[node.argument.type] < EXPRESSIONS_PRECEDENCE.UnaryExpression) {
      chunks.push(c("("));
      push_array(chunks, handle(node.argument, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node.argument, state));
    }
    return chunks;
  },
  UpdateExpression(node, state) {
    return node.prefix ? [c(node.operator), ...handle(node.argument, state)] : [...handle(node.argument, state), c(node.operator)];
  },
  AssignmentExpression(node, state) {
    return [
      ...handle(node.left, state),
      c(` ${node.operator || "="} `),
      ...handle(node.right, state)
    ];
  },
  BinaryExpression(node, state) {
    const chunks = [];
    if (needs_parens(node.left, node, false)) {
      chunks.push(c("("));
      push_array(chunks, handle(node.left, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node.left, state));
    }
    chunks.push(c(` ${node.operator} `));
    if (needs_parens(node.right, node, true)) {
      chunks.push(c("("));
      push_array(chunks, handle(node.right, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node.right, state));
    }
    return chunks;
  },
  ConditionalExpression(node, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node.test.type] > EXPRESSIONS_PRECEDENCE.ConditionalExpression) {
      push_array(chunks, handle(node.test, state));
    } else {
      chunks.push(c("("));
      push_array(chunks, handle(node.test, state));
      chunks.push(c(")"));
    }
    const child_state = { ...state, indent: state.indent + "	" };
    const consequent = handle(node.consequent, child_state);
    const alternate = handle(node.alternate, child_state);
    const multiple_lines = has_newline(consequent) || has_newline(alternate) || get_length(chunks) + get_length(consequent) + get_length(alternate) > 50;
    if (multiple_lines) {
      chunks.push(c(`
${state.indent}? `));
      push_array(chunks, consequent);
      chunks.push(c(`
${state.indent}: `));
      push_array(chunks, alternate);
    } else {
      chunks.push(c(` ? `));
      push_array(chunks, consequent);
      chunks.push(c(` : `));
      push_array(chunks, alternate);
    }
    return chunks;
  },
  NewExpression(node, state) {
    const chunks = [c("new ")];
    if (EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression || has_call_expression(node.callee)) {
      chunks.push(c("("));
      push_array(chunks, handle(node.callee, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node.callee, state));
    }
    const args = node.arguments.map(
      (arg) => handle(arg, {
        ...state,
        indent: state.indent + "	"
      })
    );
    const separator = args.some(has_newline) ? c(",\n" + state.indent) : c(", ");
    chunks.push(c("("));
    push_array(chunks, join(args, separator));
    chunks.push(c(")"));
    return chunks;
  },
  ChainExpression(node, state) {
    return handle(node.expression, state);
  },
  CallExpression(node, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression) {
      chunks.push(c("("));
      push_array(chunks, handle(node.callee, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node.callee, state));
    }
    if (
      /** @type {SimpleCallExpression} */
      node.optional
    ) {
      chunks.push(c("?."));
    }
    let has_inline_comment = false;
    let arg_chunks = [];
    outer:
      for (const arg of node.arguments) {
        const chunks2 = [];
        while (state.comments.length) {
          const comment = state.comments.shift();
          if (comment.type === "Line") {
            has_inline_comment = true;
            break outer;
          }
          chunks2.push(
            c(
              comment.type === "Block" ? `/*${comment.value}*/ ` : `//${comment.value}`
            )
          );
        }
        push_array(chunks2, handle(arg, state));
        arg_chunks.push(chunks2);
      }
    const multiple_lines = has_inline_comment || arg_chunks.slice(0, -1).some(has_newline);
    if (multiple_lines) {
      const args = node.arguments.map((arg, i) => {
        const chunks2 = handle(arg, {
          ...state,
          indent: `${state.indent}	`
        });
        if (i < node.arguments.length - 1)
          chunks2.push(c(","));
        while (state.comments.length) {
          const comment = state.comments.shift();
          chunks2.push(
            c(
              comment.type === "Block" ? ` /*${comment.value}*/ ` : ` //${comment.value}`
            )
          );
        }
        return chunks2;
      });
      chunks.push(c(`(
${state.indent}	`));
      push_array(chunks, join(args, c(`
${state.indent}	`)));
      chunks.push(c(`
${state.indent})`));
    } else {
      chunks.push(c("("));
      push_array(chunks, join(arg_chunks, c(", ")));
      chunks.push(c(")"));
    }
    return chunks;
  },
  MemberExpression(node, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {
      chunks.push(c("("));
      push_array(chunks, handle(node.object, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node.object, state));
    }
    if (node.computed) {
      if (node.optional) {
        chunks.push(c("?."));
      }
      chunks.push(c("["));
      push_array(chunks, handle(node.property, state));
      chunks.push(c("]"));
    } else {
      chunks.push(c(node.optional ? "?." : "."));
      push_array(chunks, handle(node.property, state));
    }
    return chunks;
  },
  MetaProperty(node, state) {
    return [
      ...handle(node.meta, state),
      c("."),
      ...handle(node.property, state)
    ];
  },
  Identifier(node, state) {
    let name = node.name;
    if (name[0] === "@") {
      name = state.getName(name.slice(1));
    } else if (node.name[0] === "#") {
      const owner = state.scope.find_owner(node.name);
      if (!owner) {
        throw new Error(`Could not find owner for node`);
      }
      if (!state.deconflicted.has(owner)) {
        state.deconflicted.set(owner, /* @__PURE__ */ new Map());
      }
      const deconflict_map = state.deconflicted.get(owner);
      if (!deconflict_map.has(node.name)) {
        deconflict_map.set(
          node.name,
          deconflict(node.name.slice(1), owner.references)
        );
      }
      name = deconflict_map.get(node.name);
    }
    return [c(name, node)];
  },
  Literal(node, state) {
    if (typeof node.value === "string") {
      return [
        // TODO do we need to handle weird unicode characters somehow?
        // str.replace(/\\u(\d{4})/g, (m, n) => String.fromCharCode(+n))
        c(
          (node.raw || JSON.stringify(node.value)).replace(
            re,
            (_m, _i, at, hash, name) => {
              if (at)
                return "@" + name;
              if (hash)
                return "#" + name;
              throw new Error(`this shouldn't happen`);
            }
          ),
          node
        )
      ];
    }
    return [c(node.raw || String(node.value), node)];
  },
  PropertyDefinition(node, state) {
    const chunks = [];
    if (node.static) {
      chunks.push(c("static "));
    }
    if (node.computed) {
      chunks.push(c("["), ...handle(node.key, state), c("]"));
    } else {
      chunks.push(...handle(node.key, state));
    }
    if (node.value) {
      chunks.push(c(" = "));
      chunks.push(...handle(node.value, state));
    }
    chunks.push(c(";"));
    return chunks;
  },
  StaticBlock(node, state) {
    const chunks = [c("static ")];
    push_array(chunks, handlers.BlockStatement(node, state));
    return chunks;
  },
  PrivateIdentifier(node, state) {
    const chunks = [c("#")];
    push_array(chunks, [c(node.name, node)]);
    return chunks;
  }
};
handlers.ForOfStatement = handlers.ForInStatement;
handlers.FunctionExpression = handlers.FunctionDeclaration;
handlers.ClassExpression = handlers.ClassDeclaration;
handlers.ClassBody = handlers.BlockStatement;
handlers.SpreadElement = handlers.RestElement;
handlers.ArrayPattern = handlers.ArrayExpression;
handlers.LogicalExpression = handlers.BinaryExpression;
handlers.AssignmentPattern = handlers.AssignmentExpression;

// node_modules/code-red/src/print/index.js
var import_sourcemap_codec = __toESM(require_sourcemap_codec_umd(), 1);
var btoa = () => {
  throw new Error(
    "Unsupported environment: `window.btoa` or `Buffer` should be supported."
  );
};
if (typeof window !== "undefined" && typeof window.btoa === "function") {
  btoa = (str) => window.btoa(unescape(encodeURIComponent(str)));
} else if (typeof Buffer === "function") {
  btoa = (str) => Buffer.from(str, "utf-8").toString("base64");
}
function print(node, opts = {}) {
  if (Array.isArray(node)) {
    return print(
      {
        type: "Program",
        body: node,
        sourceType: "module"
      },
      opts
    );
  }
  const {
    getName = (
      /** @param {string} x */
      (x2) => {
        throw new Error(`Unhandled sigil @${x2}`);
      }
    )
  } = opts;
  let { map: scope_map, scope } = analyze(node);
  const deconflicted = /* @__PURE__ */ new WeakMap();
  const chunks = handle(node, {
    indent: "",
    getName,
    scope,
    scope_map,
    deconflicted,
    comments: []
  });
  let code = "";
  let current_column = 0;
  let mappings = [];
  let current_line = [];
  for (let i = 0; i < chunks.length; i += 1) {
    const chunk = chunks[i];
    code += chunk.content;
    if (chunk.loc) {
      current_line.push([
        current_column,
        0,
        // source index is always zero
        chunk.loc.start.line - 1,
        chunk.loc.start.column
      ]);
    }
    for (let i2 = 0; i2 < chunk.content.length; i2 += 1) {
      if (chunk.content[i2] === "\n") {
        mappings.push(current_line);
        current_line = [];
        current_column = 0;
      } else {
        current_column += 1;
      }
    }
    if (chunk.loc) {
      current_line.push([
        current_column,
        0,
        // source index is always zero
        chunk.loc.end.line - 1,
        chunk.loc.end.column
      ]);
    }
  }
  mappings.push(current_line);
  const map = {
    version: 3,
    /** @type {string[]} */
    names: [],
    sources: [opts.sourceMapSource || null],
    sourcesContent: [opts.sourceMapContent || null],
    mappings: opts.sourceMapEncodeMappings == void 0 || opts.sourceMapEncodeMappings ? (0, import_sourcemap_codec.encode)(mappings) : mappings
  };
  Object.defineProperties(map, {
    toString: {
      enumerable: false,
      value: function toString() {
        return JSON.stringify(this);
      }
    },
    toUrl: {
      enumerable: false,
      value: function toUrl() {
        return "data:application/json;charset=utf-8;base64," + btoa(this.toString());
      }
    }
  });
  return {
    code,
    map
  };
}

// node_modules/code-red/src/index.js
var sigils = {
  "@": "AT",
  "#": "HASH"
};
var join2 = (strings) => {
  let str = strings[0];
  for (let i = 1; i < strings.length; i += 1) {
    str += `_${id}_${i - 1}_${strings[i]}`;
  }
  return str.replace(
    /([@#])(\w+)/g,
    (_m, sigil, name) => `_${id}_${sigils[sigil]}_${name}`
  );
};
var flatten_body = (array, target) => {
  for (let i = 0; i < array.length; i += 1) {
    const statement = array[i];
    if (Array.isArray(statement)) {
      flatten_body(statement, target);
      continue;
    }
    if (statement.type === "ExpressionStatement") {
      if (statement.expression === EMPTY)
        continue;
      if (Array.isArray(statement.expression)) {
        let node = statement.expression[0];
        while (Array.isArray(node))
          node = node[0];
        if (node)
          node.leadingComments = statement.leadingComments;
        flatten_body(statement.expression, target);
        continue;
      }
      if (/(Expression|Literal)$/.test(statement.expression.type)) {
        target.push(statement);
        continue;
      }
      if (statement.leadingComments)
        statement.expression.leadingComments = statement.leadingComments;
      if (statement.trailingComments)
        statement.expression.trailingComments = statement.trailingComments;
      target.push(statement.expression);
      continue;
    }
    target.push(statement);
  }
  return target;
};
var flatten_properties = (array, target) => {
  for (let i = 0; i < array.length; i += 1) {
    const property = array[i];
    if (property.value === EMPTY)
      continue;
    if (property.key === property.value && Array.isArray(property.key)) {
      flatten_properties(property.key, target);
      continue;
    }
    target.push(property);
  }
  return target;
};
var flatten = (nodes, target) => {
  for (let i = 0; i < nodes.length; i += 1) {
    const node = nodes[i];
    if (node === EMPTY)
      continue;
    if (Array.isArray(node)) {
      flatten(node, target);
      continue;
    }
    target.push(node);
  }
  return target;
};
var EMPTY = { type: "Empty" };
var acorn_opts = (comments, raw) => {
  const { onComment } = get_comment_handlers(comments, raw);
  return {
    ecmaVersion: 2022,
    sourceType: "module",
    allowAwaitOutsideFunction: true,
    allowImportExportEverywhere: true,
    allowReturnOutsideFunction: true,
    onComment
  };
};
var inject = (raw, node, values, comments) => {
  comments.forEach((comment) => {
    comment.value = comment.value.replace(
      re,
      (m, i) => +i in values ? values[+i] : m
    );
  });
  const { enter, leave } = get_comment_handlers(comments, raw);
  return walk(node, {
    enter,
    /** @param {any} node */
    leave(node2) {
      if (node2.type === "Identifier") {
        re.lastIndex = 0;
        const match = re.exec(node2.name);
        if (match) {
          if (match[1]) {
            if (+match[1] in values) {
              let value = values[+match[1]];
              if (typeof value === "string") {
                value = {
                  type: "Identifier",
                  name: value,
                  leadingComments: node2.leadingComments,
                  trailingComments: node2.trailingComments
                };
              } else if (typeof value === "number") {
                value = {
                  type: "Literal",
                  value,
                  leadingComments: node2.leadingComments,
                  trailingComments: node2.trailingComments
                };
              }
              this.replace(value || EMPTY);
            }
          } else {
            node2.name = `${match[2] ? `@` : `#`}${match[4]}`;
          }
        }
      }
      if (node2.type === "Literal") {
        if (typeof node2.value === "string") {
          re.lastIndex = 0;
          const new_value = (
            /** @type {string} */
            node2.value.replace(
              re,
              (m, i) => +i in values ? values[+i] : m
            )
          );
          const has_changed = new_value !== node2.value;
          node2.value = new_value;
          if (has_changed && node2.raw) {
            node2.raw = `${node2.raw[0]}${JSON.stringify(node2.value).slice(
              1,
              -1
            )}${node2.raw[node2.raw.length - 1]}`;
          }
        }
      }
      if (node2.type === "TemplateElement") {
        re.lastIndex = 0;
        node2.value.raw = /** @type {string} */
        node2.value.raw.replace(
          re,
          (m, i) => +i in values ? values[+i] : m
        );
      }
      if (node2.type === "Program" || node2.type === "BlockStatement") {
        node2.body = flatten_body(node2.body, []);
      }
      if (node2.type === "ObjectExpression" || node2.type === "ObjectPattern") {
        node2.properties = flatten_properties(node2.properties, []);
      }
      if (node2.type === "ArrayExpression" || node2.type === "ArrayPattern") {
        node2.elements = flatten(node2.elements, []);
      }
      if (node2.type === "FunctionExpression" || node2.type === "FunctionDeclaration" || node2.type === "ArrowFunctionExpression") {
        node2.params = flatten(node2.params, []);
      }
      if (node2.type === "CallExpression" || node2.type === "NewExpression") {
        node2.arguments = flatten(node2.arguments, []);
      }
      if (node2.type === "ImportDeclaration" || node2.type === "ExportNamedDeclaration") {
        node2.specifiers = flatten(node2.specifiers, []);
      }
      if (node2.type === "ForStatement") {
        node2.init = node2.init === EMPTY ? null : node2.init;
        node2.test = node2.test === EMPTY ? null : node2.test;
        node2.update = node2.update === EMPTY ? null : node2.update;
      }
      leave(node2);
    }
  });
};
function b(strings, ...values) {
  const str = join2(strings);
  const comments = [];
  try {
    let ast = (
      /** @type {any} */
      parse(str, acorn_opts(comments, str))
    );
    ast = inject(str, ast, values, comments);
    return ast.body;
  } catch (err) {
    handle_error(str, err);
  }
}
function x(strings, ...values) {
  const str = join2(strings);
  const comments = [];
  try {
    let expression = (
      /** @type {Expression & { start: Number, end: number }} */
      parseExpressionAt(str, 0, acorn_opts(comments, str))
    );
    const match = /\S+/.exec(str.slice(expression.end));
    if (match) {
      throw new Error(`Unexpected token '${match[0]}'`);
    }
    expression = /** @type {Expression & { start: Number, end: number }} */
    inject(str, expression, values, comments);
    return expression;
  } catch (err) {
    handle_error(str, err);
  }
}
function p(strings, ...values) {
  const str = `{${join2(strings)}}`;
  const comments = [];
  try {
    let expression = (
      /** @type {any} */
      parseExpressionAt(str, 0, acorn_opts(comments, str))
    );
    expression = inject(str, expression, values, comments);
    return expression.properties[0];
  } catch (err) {
    handle_error(str, err);
  }
}
function handle_error(str, err) {
  re.lastIndex = 0;
  str = str.replace(re, (m, i, at, hash, name) => {
    if (at)
      return `@${name}`;
    if (hash)
      return `#${name}`;
    return "${...}";
  });
  console.log(`failed to parse:
${str}`);
  throw err;
}
var parse2 = (source, opts) => {
  const comments = [];
  const { onComment, enter, leave } = get_comment_handlers(comments, source);
  const ast = (
    /** @type {any} */
    parse(source, { onComment, ...opts })
  );
  walk(ast, { enter, leave });
  return ast;
};
var parseExpressionAt2 = (source, index, opts) => {
  const comments = [];
  const { onComment, enter, leave } = get_comment_handlers(comments, source);
  const ast = (
    /** @type {any} */
    parseExpressionAt(source, index, { onComment, ...opts })
  );
  walk(ast, { enter, leave });
  return ast;
};

export {
  print,
  b,
  x,
  p,
  parse2 as parse,
  parseExpressionAt2 as parseExpressionAt
};
//# sourceMappingURL=chunk-VGBWBDAK.js.map
