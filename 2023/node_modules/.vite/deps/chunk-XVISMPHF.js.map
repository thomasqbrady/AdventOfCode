{
  "version": 3,
  "sources": ["../../periscopic/src/index.js"],
  "sourcesContent": ["import { walk } from 'estree-walker';\nimport is_reference from 'is-reference';\n\n/** @param {import('estree').Node} expression */\nexport function analyze(expression) {\n\t/** @typedef {import('estree').Node} Node */\n\n\t/** @type {WeakMap<Node, Scope>} */\n\tconst map = new WeakMap();\n\n\t/** @type {Map<string, Node>} */\n\tconst globals = new Map();\n\n\tconst scope = new Scope(null, false);\n\n\t/** @type {[Scope, import('estree').Identifier][]} */\n\tconst references = [];\n\t/** @type {Scope} */\n\tlet current_scope = scope;\n\n\twalk(expression, {\n\t\tenter(node, parent) {\n\t\t\tswitch (node.type) {\n\t\t\t\tcase 'Identifier':\n\t\t\t\t\tif (parent && is_reference(node, parent)) {\n\t\t\t\t\t\treferences.push([current_scope, node]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ImportDeclaration':\n\t\t\t\t\tnode.specifiers.forEach((specifier) => {\n\t\t\t\t\t\tcurrent_scope.declarations.set(specifier.local.name, specifier);\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'FunctionExpression':\n\t\t\t\tcase 'FunctionDeclaration':\n\t\t\t\tcase 'ArrowFunctionExpression':\n\t\t\t\t\tif (node.type === 'FunctionDeclaration') {\n\t\t\t\t\t\tif (node.id) {\n\t\t\t\t\t\t\tcurrent_scope.declarations.set(node.id.name, node);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmap.set(node, current_scope = new Scope(current_scope, false));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap.set(node, current_scope = new Scope(current_scope, false));\n\n\t\t\t\t\t\tif (node.type === 'FunctionExpression' && node.id) {\n\t\t\t\t\t\t\tcurrent_scope.declarations.set(node.id.name, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tnode.params.forEach(param => {\n\t\t\t\t\t\textract_names(param).forEach(name => {\n\t\t\t\t\t\t\tcurrent_scope.declarations.set(name, node);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ForStatement':\n\t\t\t\tcase 'ForInStatement':\n\t\t\t\tcase 'ForOfStatement':\n\t\t\t\t\tmap.set(node, current_scope = new Scope(current_scope, true));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'BlockStatement':\n\t\t\t\t\tmap.set(node, current_scope = new Scope(current_scope, true));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ClassDeclaration':\n\t\t\t\tcase 'VariableDeclaration':\n\t\t\t\t\tcurrent_scope.add_declaration(node);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'CatchClause':\n\t\t\t\t\tmap.set(node, current_scope = new Scope(current_scope, true));\n\n\t\t\t\t\tif (node.param) {\n\t\t\t\t\t\textract_names(node.param).forEach(name => {\n\t\t\t\t\t\t\tif (node.param) {\n\t\t\t\t\t\t\t\tcurrent_scope.declarations.set(name, node.param);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\n\t\tleave(node) {\n\t\t\tif (map.has(node) && current_scope !== null && current_scope.parent) {\n\t\t\t\tcurrent_scope = current_scope.parent;\n\t\t\t}\n\t\t}\n\t});\n\n\tfor (let i = references.length - 1; i >= 0; --i) {\n\t\tconst [scope, reference] = references[i];\n\n\t\tif (!scope.references.has(reference.name)) {\n\t\t\tadd_reference(scope, reference.name);\n\t\t}\n\t\tif (!scope.find_owner(reference.name)) {\n\t\t\tglobals.set(reference.name, reference);\n\t\t}\n\t}\n\n\treturn { map, scope, globals };\n}\n\n/**\n * @param {Scope} scope\n * @param {string} name\n */\nfunction add_reference(scope, name) {\n\tscope.references.add(name);\n\tif (scope.parent) add_reference(scope.parent, name);\n}\n\nexport class Scope {\n\t/**\n\t * @param {Scope | null} parent \n\t * @param {boolean} block \n\t */\n\tconstructor(parent, block) {\n\t\t/** @type {Scope | null} */\n\t\tthis.parent = parent;\n\n\t\t/** @type {boolean} */\n\t\tthis.block = block;\n\n\t\t/** @type {Map<string, import('estree').Node>} */\n\t\tthis.declarations = new Map();\n\n\t\t/** @type {Set<string>} */\n\t\tthis.initialised_declarations = new Set();\n\n\t\t/** @type {Set<string>} */\n\t\tthis.references = new Set();\n\t}\n\n\t/**\n\t * @param {import('estree').VariableDeclaration | import('estree').ClassDeclaration} node\n\t */\n\tadd_declaration(node) {\n\t\tif (node.type === 'VariableDeclaration') {\n\t\t\tif (node.kind === 'var' && this.block && this.parent) {\n\t\t\t\tthis.parent.add_declaration(node);\n\t\t\t} else {\n\t\t\t\t/** @param {import('estree').VariableDeclarator} declarator */\n\t\t\t\tconst handle_declarator = (declarator) => {\n\t\t\t\t\textract_names(declarator.id).forEach(name => {\n\t\t\t\t\t\tthis.declarations.set(name, node);\n\t\t\t\t\t\tif (declarator.init) this.initialised_declarations.add(name);\n\t\t\t\t\t});;\n\t\t\t\t}\n\n\t\t\t\tnode.declarations.forEach(handle_declarator);\n\t\t\t}\n\t\t} else if (node.id) {\n\t\t\tthis.declarations.set(node.id.name, node);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @returns {Scope | null}\n\t */\n\tfind_owner(name) {\n\t\tif (this.declarations.has(name)) return this;\n\t\treturn this.parent && this.parent.find_owner(name);\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @returns {boolean}\n\t */\n\thas(name) {\n\t\treturn (\n\t\t\tthis.declarations.has(name) || (!!this.parent && this.parent.has(name))\n\t\t);\n\t}\n}\n\n/**\n * @param {import('estree').Node} param\n * @returns {string[]}\n */\nexport function extract_names(param) {\n\treturn extract_identifiers(param).map(node => node.name);\n}\n\n/**\n * @param {import('estree').Node} param\n * @param {import('estree').Identifier[]} nodes\n * @returns {import('estree').Identifier[]}\n */\nexport function extract_identifiers(param, nodes = []) {\n\tswitch (param.type) {\n\t\tcase 'Identifier':\n\t\t\tnodes.push(param);\n\t\t\tbreak;\n\n\t\tcase 'MemberExpression':\n\t\t\tlet object = param;\n\t\t\twhile (object.type === 'MemberExpression') {\n\t\t\t\tobject = /** @type {any} */ (object.object);\n\t\t\t}\n\t\t\tnodes.push(/** @type {any} */ (object));\n\t\t\tbreak;\n\n\t\tcase 'ObjectPattern':\n\t\t\t/** @param {import('estree').Property | import('estree').RestElement} prop */\n\t\t\tconst handle_prop = (prop) => {\n\t\t\t\tif (prop.type === 'RestElement') {\n\t\t\t\t\textract_identifiers(prop.argument, nodes);\n\t\t\t\t} else {\n\t\t\t\t\textract_identifiers(prop.value, nodes);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tparam.properties.forEach(handle_prop);\n\t\t\tbreak;\n\n\t\tcase 'ArrayPattern':\n\t\t\t/** @param {import('estree').Node} element */\n\t\t\tconst handle_element = (element) => {\n\t\t\t\tif (element) extract_identifiers(element, nodes);\n\t\t\t};\n\n\t\t\tparam.elements.forEach((element) => {\n\t\t\t\tif (element) {\n\t\t\t\t\thandle_element(element)\n\t\t\t\t}\n\t\t\t});\n\t\t\tbreak;\n\n\t\tcase 'RestElement':\n\t\t\textract_identifiers(param.argument, nodes);\n\t\t\tbreak;\n\n\t\tcase 'AssignmentPattern':\n\t\t\textract_identifiers(param.left, nodes);\n\t\t\tbreak;\n\t}\n\n\treturn nodes;\n}\n"],
  "mappings": "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",
  "names": ["scope"]
}
