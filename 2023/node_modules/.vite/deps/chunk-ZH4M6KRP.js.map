{
  "version": 3,
  "sources": ["../../css-tree/lib/tokenizer/types.js", "../../css-tree/lib/tokenizer/char-code-definitions.js", "../../css-tree/lib/tokenizer/utils.js", "../../css-tree/lib/tokenizer/names.js", "../../css-tree/lib/tokenizer/adopt-buffer.js", "../../css-tree/lib/tokenizer/OffsetToLocation.js", "../../css-tree/lib/tokenizer/TokenStream.js", "../../css-tree/lib/tokenizer/index.js"],
  "sourcesContent": ["// CSS Syntax Module Level 3\n// https://www.w3.org/TR/css-syntax-3/\nexport const EOF = 0;                 // <EOF-token>\nexport const Ident = 1;               // <ident-token>\nexport const Function = 2;            // <function-token>\nexport const AtKeyword = 3;           // <at-keyword-token>\nexport const Hash = 4;                // <hash-token>\nexport const String = 5;              // <string-token>\nexport const BadString = 6;           // <bad-string-token>\nexport const Url = 7;                 // <url-token>\nexport const BadUrl = 8;              // <bad-url-token>\nexport const Delim = 9;               // <delim-token>\nexport const Number = 10;             // <number-token>\nexport const Percentage = 11;         // <percentage-token>\nexport const Dimension = 12;          // <dimension-token>\nexport const WhiteSpace = 13;         // <whitespace-token>\nexport const CDO = 14;                // <CDO-token>\nexport const CDC = 15;                // <CDC-token>\nexport const Colon = 16;              // <colon-token>     :\nexport const Semicolon = 17;          // <semicolon-token> ;\nexport const Comma = 18;              // <comma-token>     ,\nexport const LeftSquareBracket = 19;  // <[-token>\nexport const RightSquareBracket = 20; // <]-token>\nexport const LeftParenthesis = 21;    // <(-token>\nexport const RightParenthesis = 22;   // <)-token>\nexport const LeftCurlyBracket = 23;   // <{-token>\nexport const RightCurlyBracket = 24;  // <}-token>\nexport const Comment = 25;\n", "const EOF = 0;\n\n// https://drafts.csswg.org/css-syntax-3/\n// § 4.2. Definitions\n\n// digit\n// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).\nexport function isDigit(code) {\n    return code >= 0x0030 && code <= 0x0039;\n}\n\n// hex digit\n// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),\n// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).\nexport function isHexDigit(code) {\n    return (\n        isDigit(code) || // 0 .. 9\n        (code >= 0x0041 && code <= 0x0046) || // A .. F\n        (code >= 0x0061 && code <= 0x0066)    // a .. f\n    );\n}\n\n// uppercase letter\n// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).\nexport function isUppercaseLetter(code) {\n    return code >= 0x0041 && code <= 0x005A;\n}\n\n// lowercase letter\n// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).\nexport function isLowercaseLetter(code) {\n    return code >= 0x0061 && code <= 0x007A;\n}\n\n// letter\n// An uppercase letter or a lowercase letter.\nexport function isLetter(code) {\n    return isUppercaseLetter(code) || isLowercaseLetter(code);\n}\n\n// non-ASCII code point\n// A code point with a value equal to or greater than U+0080 <control>.\nexport function isNonAscii(code) {\n    return code >= 0x0080;\n}\n\n// name-start code point\n// A letter, a non-ASCII code point, or U+005F LOW LINE (_).\nexport function isNameStart(code) {\n    return isLetter(code) || isNonAscii(code) || code === 0x005F;\n}\n\n// name code point\n// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).\nexport function isName(code) {\n    return isNameStart(code) || isDigit(code) || code === 0x002D;\n}\n\n// non-printable code point\n// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,\n// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.\nexport function isNonPrintable(code) {\n    return (\n        (code >= 0x0000 && code <= 0x0008) ||\n        (code === 0x000B) ||\n        (code >= 0x000E && code <= 0x001F) ||\n        (code === 0x007F)\n    );\n}\n\n// newline\n// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,\n// as they are converted to U+000A LINE FEED during preprocessing.\n// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED\nexport function isNewline(code) {\n    return code === 0x000A || code === 0x000D || code === 0x000C;\n}\n\n// whitespace\n// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.\nexport function isWhiteSpace(code) {\n    return isNewline(code) || code === 0x0020 || code === 0x0009;\n}\n\n// § 4.3.8. Check if two code points are a valid escape\nexport function isValidEscape(first, second) {\n    // If the first code point is not U+005C REVERSE SOLIDUS (\\), return false.\n    if (first !== 0x005C) {\n        return false;\n    }\n\n    // Otherwise, if the second code point is a newline or EOF, return false.\n    if (isNewline(second) || second === EOF) {\n        return false;\n    }\n\n    // Otherwise, return true.\n    return true;\n}\n\n// § 4.3.9. Check if three code points would start an identifier\nexport function isIdentifierStart(first, second, third) {\n    // Look at the first code point:\n\n    // U+002D HYPHEN-MINUS\n    if (first === 0x002D) {\n        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,\n        // or the second and third code points are a valid escape, return true. Otherwise, return false.\n        return (\n            isNameStart(second) ||\n            second === 0x002D ||\n            isValidEscape(second, third)\n        );\n    }\n\n    // name-start code point\n    if (isNameStart(first)) {\n        // Return true.\n        return true;\n    }\n\n    // U+005C REVERSE SOLIDUS (\\)\n    if (first === 0x005C) {\n        // If the first and second code points are a valid escape, return true. Otherwise, return false.\n        return isValidEscape(first, second);\n    }\n\n    // anything else\n    // Return false.\n    return false;\n}\n\n// § 4.3.10. Check if three code points would start a number\nexport function isNumberStart(first, second, third) {\n    // Look at the first code point:\n\n    // U+002B PLUS SIGN (+)\n    // U+002D HYPHEN-MINUS (-)\n    if (first === 0x002B || first === 0x002D) {\n        // If the second code point is a digit, return true.\n        if (isDigit(second)) {\n            return 2;\n        }\n\n        // Otherwise, if the second code point is a U+002E FULL STOP (.)\n        // and the third code point is a digit, return true.\n        // Otherwise, return false.\n        return second === 0x002E && isDigit(third) ? 3 : 0;\n    }\n\n    // U+002E FULL STOP (.)\n    if (first === 0x002E) {\n        // If the second code point is a digit, return true. Otherwise, return false.\n        return isDigit(second) ? 2 : 0;\n    }\n\n    // digit\n    if (isDigit(first)) {\n        // Return true.\n        return 1;\n    }\n\n    // anything else\n    // Return false.\n    return 0;\n}\n\n//\n// Misc\n//\n\n// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)\nexport function isBOM(code) {\n    // UTF-16BE\n    if (code === 0xFEFF) {\n        return 1;\n    }\n\n    // UTF-16LE\n    if (code === 0xFFFE) {\n        return 1;\n    }\n\n    return 0;\n}\n\n// Fast code category\n// Only ASCII code points has a special meaning, that's why we define a maps for 0..127 codes only\nconst CATEGORY = new Array(0x80);\nexport const EofCategory = 0x80;\nexport const WhiteSpaceCategory = 0x82;\nexport const DigitCategory = 0x83;\nexport const NameStartCategory = 0x84;\nexport const NonPrintableCategory = 0x85;\n\nfor (let i = 0; i < CATEGORY.length; i++) {\n    CATEGORY[i] =\n        isWhiteSpace(i) && WhiteSpaceCategory ||\n        isDigit(i) && DigitCategory ||\n        isNameStart(i) && NameStartCategory ||\n        isNonPrintable(i) && NonPrintableCategory ||\n        i || EofCategory;\n}\n\nexport function charCodeCategory(code) {\n    return code < 0x80 ? CATEGORY[code] : NameStartCategory;\n}\n", "import {\n    isDigit,\n    isHexDigit,\n    isUppercaseLetter,\n    isName,\n    isWhiteSpace,\n    isValidEscape\n} from './char-code-definitions.js';\n\nfunction getCharCode(source, offset) {\n    return offset < source.length ? source.charCodeAt(offset) : 0;\n}\n\nexport function getNewlineLength(source, offset, code) {\n    if (code === 13 /* \\r */ && getCharCode(source, offset + 1) === 10 /* \\n */) {\n        return 2;\n    }\n\n    return 1;\n}\n\nexport function cmpChar(testStr, offset, referenceCode) {\n    let code = testStr.charCodeAt(offset);\n\n    // code.toLowerCase() for A..Z\n    if (isUppercaseLetter(code)) {\n        code = code | 32;\n    }\n\n    return code === referenceCode;\n}\n\nexport function cmpStr(testStr, start, end, referenceStr) {\n    if (end - start !== referenceStr.length) {\n        return false;\n    }\n\n    if (start < 0 || end > testStr.length) {\n        return false;\n    }\n\n    for (let i = start; i < end; i++) {\n        const referenceCode = referenceStr.charCodeAt(i - start);\n        let testCode = testStr.charCodeAt(i);\n\n        // testCode.toLowerCase() for A..Z\n        if (isUppercaseLetter(testCode)) {\n            testCode = testCode | 32;\n        }\n\n        if (testCode !== referenceCode) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function findWhiteSpaceStart(source, offset) {\n    for (; offset >= 0; offset--) {\n        if (!isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset + 1;\n}\n\nexport function findWhiteSpaceEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\nexport function findDecimalNumberEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!isDigit(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.7. Consume an escaped code point\nexport function consumeEscaped(source, offset) {\n    // It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and\n    // that the next input code point has already been verified to be part of a valid escape.\n    offset += 2;\n\n    // hex digit\n    if (isHexDigit(getCharCode(source, offset - 1))) {\n        // Consume as many hex digits as possible, but no more than 5.\n        // Note that this means 1-6 hex digits have been consumed in total.\n        for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {\n            if (!isHexDigit(getCharCode(source, offset))) {\n                break;\n            }\n        }\n\n        // If the next input code point is whitespace, consume it as well.\n        const code = getCharCode(source, offset);\n        if (isWhiteSpace(code)) {\n            offset += getNewlineLength(source, offset, code);\n        }\n    }\n\n    return offset;\n}\n\n// §4.3.11. Consume a name\n// Note: This algorithm does not do the verification of the first few code points that are necessary\n// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,\n// ensure that the stream starts with an identifier before calling this algorithm.\nexport function consumeName(source, offset) {\n    // Let result initially be an empty string.\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        const code = source.charCodeAt(offset);\n\n        // name code point\n        if (isName(code)) {\n            // Append the code point to result.\n            continue;\n        }\n\n        // the stream starts with a valid escape\n        if (isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point. Append the returned code point to result.\n            offset = consumeEscaped(source, offset) - 1;\n            continue;\n        }\n\n        // anything else\n        // Reconsume the current input code point. Return result.\n        break;\n    }\n\n    return offset;\n}\n\n// §4.3.12. Consume a number\nexport function consumeNumber(source, offset) {\n    let code = source.charCodeAt(offset);\n\n    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n    // consume it and append it to repr.\n    if (code === 0x002B || code === 0x002D) {\n        code = source.charCodeAt(offset += 1);\n    }\n\n    // 3. While the next input code point is a digit, consume it and append it to repr.\n    if (isDigit(code)) {\n        offset = findDecimalNumberEnd(source, offset + 1);\n        code = source.charCodeAt(offset);\n    }\n\n    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n    if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {\n        // 4.1 Consume them.\n        // 4.2 Append them to repr.\n        offset += 2;\n\n        // 4.3 Set type to \"number\".\n        // TODO\n\n        // 4.4 While the next input code point is a digit, consume it and append it to repr.\n\n        offset = findDecimalNumberEnd(source, offset);\n    }\n\n    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n    if (cmpChar(source, offset, 101 /* e */)) {\n        let sign = 0;\n        code = source.charCodeAt(offset + 1);\n\n        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n        if (code === 0x002D || code === 0x002B) {\n            sign = 1;\n            code = source.charCodeAt(offset + 2);\n        }\n\n        // ... followed by a digit\n        if (isDigit(code)) {\n            // 5.1 Consume them.\n            // 5.2 Append them to repr.\n\n            // 5.3 Set type to \"number\".\n            // TODO\n\n            // 5.4 While the next input code point is a digit, consume it and append it to repr.\n            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.14. Consume the remnants of a bad url\n// ... its sole use is to consume enough of the input stream to reach a recovery point\n// where normal tokenizing can resume.\nexport function consumeBadUrlRemnants(source, offset) {\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        const code = source.charCodeAt(offset);\n\n        // U+0029 RIGHT PARENTHESIS ())\n        // EOF\n        if (code === 0x0029) {\n            // Return.\n            offset++;\n            break;\n        }\n\n        if (isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point.\n            // Note: This allows an escaped right parenthesis (\"\\)\") to be encountered\n            // without ending the <bad-url-token>. This is otherwise identical to\n            // the \"anything else\" clause.\n            offset = consumeEscaped(source, offset);\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.7. Consume an escaped code point\n// Note: This algorithm assumes that escaped is valid without leading U+005C REVERSE SOLIDUS (\\)\nexport function decodeEscaped(escaped) {\n    // Single char escaped that's not a hex digit\n    if (escaped.length === 1 && !isHexDigit(escaped.charCodeAt(0))) {\n        return escaped[0];\n    }\n\n    // Interpret the hex digits as a hexadecimal number.\n    let code = parseInt(escaped, 16);\n\n    if (\n        (code === 0) ||                       // If this number is zero,\n        (code >= 0xD800 && code <= 0xDFFF) || // or is for a surrogate,\n        (code > 0x10FFFF)                     // or is greater than the maximum allowed code point\n    ) {\n        // ... return U+FFFD REPLACEMENT CHARACTER\n        code = 0xFFFD;\n    }\n\n    // Otherwise, return the code point with that value.\n    return String.fromCodePoint(code);\n}\n", "export default [\n    'EOF-token',\n    'ident-token',\n    'function-token',\n    'at-keyword-token',\n    'hash-token',\n    'string-token',\n    'bad-string-token',\n    'url-token',\n    'bad-url-token',\n    'delim-token',\n    'number-token',\n    'percentage-token',\n    'dimension-token',\n    'whitespace-token',\n    'CDO-token',\n    'CDC-token',\n    'colon-token',\n    'semicolon-token',\n    'comma-token',\n    '[-token',\n    ']-token',\n    '(-token',\n    ')-token',\n    '{-token',\n    '}-token'\n];\n", "const MIN_SIZE = 16 * 1024;\n\nexport function adoptBuffer(buffer = null, size) {\n    if (buffer === null || buffer.length < size) {\n        return new Uint32Array(Math.max(size + 1024, MIN_SIZE));\n    }\n\n    return buffer;\n};\n", "import { adoptBuffer } from './adopt-buffer.js';\nimport { isBOM } from './char-code-definitions.js';\n\nconst N = 10;\nconst F = 12;\nconst R = 13;\n\nfunction computeLinesAndColumns(host) {\n    const source = host.source;\n    const sourceLength = source.length;\n    const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;\n    const lines = adoptBuffer(host.lines, sourceLength);\n    const columns = adoptBuffer(host.columns, sourceLength);\n    let line = host.startLine;\n    let column = host.startColumn;\n\n    for (let i = startOffset; i < sourceLength; i++) {\n        const code = source.charCodeAt(i);\n\n        lines[i] = line;\n        columns[i] = column++;\n\n        if (code === N || code === R || code === F) {\n            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {\n                i++;\n                lines[i] = line;\n                columns[i] = column;\n            }\n\n            line++;\n            column = 1;\n        }\n    }\n\n    lines[sourceLength] = line;\n    columns[sourceLength] = column;\n\n    host.lines = lines;\n    host.columns = columns;\n    host.computed = true;\n}\n\nexport class OffsetToLocation {\n    constructor() {\n        this.lines = null;\n        this.columns = null;\n        this.computed = false;\n    }\n    setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {\n        this.source = source;\n        this.startOffset = startOffset;\n        this.startLine = startLine;\n        this.startColumn = startColumn;\n        this.computed = false;\n    }\n    getLocation(offset, filename) {\n        if (!this.computed) {\n            computeLinesAndColumns(this);\n        }\n\n        return {\n            source: filename,\n            offset: this.startOffset + offset,\n            line: this.lines[offset],\n            column: this.columns[offset]\n        };\n    }\n    getLocationRange(start, end, filename) {\n        if (!this.computed) {\n            computeLinesAndColumns(this);\n        }\n\n        return {\n            source: filename,\n            start: {\n                offset: this.startOffset + start,\n                line: this.lines[start],\n                column: this.columns[start]\n            },\n            end: {\n                offset: this.startOffset + end,\n                line: this.lines[end],\n                column: this.columns[end]\n            }\n        };\n    }\n};\n", "import { adoptBuffer } from './adopt-buffer.js';\nimport { cmpStr } from './utils.js';\nimport tokenNames from './names.js';\nimport {\n    WhiteSpace,\n    Comment,\n    Delim,\n    EOF,\n    Function as FunctionToken,\n    LeftParenthesis,\n    RightParenthesis,\n    LeftSquareBracket,\n    RightSquareBracket,\n    LeftCurlyBracket,\n    RightCurlyBracket\n} from './types.js';\n\nconst OFFSET_MASK = 0x00FFFFFF;\nconst TYPE_SHIFT = 24;\nconst balancePair = new Map([\n    [FunctionToken, RightParenthesis],\n    [LeftParenthesis, RightParenthesis],\n    [LeftSquareBracket, RightSquareBracket],\n    [LeftCurlyBracket, RightCurlyBracket]\n]);\n\nexport class TokenStream {\n    constructor(source, tokenize) {\n        this.setSource(source, tokenize);\n    }\n    reset() {\n        this.eof = false;\n        this.tokenIndex = -1;\n        this.tokenType = 0;\n        this.tokenStart = this.firstCharOffset;\n        this.tokenEnd = this.firstCharOffset;\n    }\n    setSource(source = '', tokenize = () => {}) {\n        source = String(source || '');\n\n        const sourceLength = source.length;\n        const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1); // +1 because of eof-token\n        const balance = adoptBuffer(this.balance, source.length + 1);\n        let tokenCount = 0;\n        let balanceCloseType = 0;\n        let balanceStart = 0;\n        let firstCharOffset = -1;\n\n        // capture buffers\n        this.offsetAndType = null;\n        this.balance = null;\n\n        tokenize(source, (type, start, end) => {\n            switch (type) {\n                default:\n                    balance[tokenCount] = sourceLength;\n                    break;\n\n                case balanceCloseType: {\n                    let balancePrev = balanceStart & OFFSET_MASK;\n                    balanceStart = balance[balancePrev];\n                    balanceCloseType = balanceStart >> TYPE_SHIFT;\n                    balance[tokenCount] = balancePrev;\n                    balance[balancePrev++] = tokenCount;\n                    for (; balancePrev < tokenCount; balancePrev++) {\n                        if (balance[balancePrev] === sourceLength) {\n                            balance[balancePrev] = tokenCount;\n                        }\n                    }\n                    break;\n                }\n\n                case LeftParenthesis:\n                case FunctionToken:\n                case LeftSquareBracket:\n                case LeftCurlyBracket:\n                    balance[tokenCount] = balanceStart;\n                    balanceCloseType = balancePair.get(type);\n                    balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;\n                    break;\n            }\n\n            offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | end;\n            if (firstCharOffset === -1) {\n                firstCharOffset = start;\n            }\n        });\n\n        // finalize buffers\n        offsetAndType[tokenCount] = (EOF << TYPE_SHIFT) | sourceLength; // <EOF-token>\n        balance[tokenCount] = sourceLength;\n        balance[sourceLength] = sourceLength; // prevents false positive balance match with any token\n        while (balanceStart !== 0) {\n            const balancePrev = balanceStart & OFFSET_MASK;\n            balanceStart = balance[balancePrev];\n            balance[balancePrev] = sourceLength;\n        }\n\n        this.source = source;\n        this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;\n        this.tokenCount = tokenCount;\n        this.offsetAndType = offsetAndType;\n        this.balance = balance;\n\n        this.reset();\n        this.next();\n    }\n\n    lookupType(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset] >> TYPE_SHIFT;\n        }\n\n        return EOF;\n    }\n    lookupOffset(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset - 1] & OFFSET_MASK;\n        }\n\n        return this.source.length;\n    }\n    lookupValue(offset, referenceStr) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return cmpStr(\n                this.source,\n                this.offsetAndType[offset - 1] & OFFSET_MASK,\n                this.offsetAndType[offset] & OFFSET_MASK,\n                referenceStr\n            );\n        }\n\n        return false;\n    }\n    getTokenStart(tokenIndex) {\n        if (tokenIndex === this.tokenIndex) {\n            return this.tokenStart;\n        }\n\n        if (tokenIndex > 0) {\n            return tokenIndex < this.tokenCount\n                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK\n                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;\n        }\n\n        return this.firstCharOffset;\n    }\n    substrToCursor(start) {\n        return this.source.substring(start, this.tokenStart);\n    }\n\n    isBalanceEdge(pos) {\n        return this.balance[this.tokenIndex] < pos;\n    }\n    isDelim(code, offset) {\n        if (offset) {\n            return (\n                this.lookupType(offset) === Delim &&\n                this.source.charCodeAt(this.lookupOffset(offset)) === code\n            );\n        }\n\n        return (\n            this.tokenType === Delim &&\n            this.source.charCodeAt(this.tokenStart) === code\n        );\n    }\n\n    skip(tokenCount) {\n        let next = this.tokenIndex + tokenCount;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.tokenIndex = this.tokenCount;\n            this.next();\n        }\n    }\n    next() {\n        let next = this.tokenIndex + 1;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.tokenEnd;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.eof = true;\n            this.tokenIndex = this.tokenCount;\n            this.tokenType = EOF;\n            this.tokenStart = this.tokenEnd = this.source.length;\n        }\n    }\n    skipSC() {\n        while (this.tokenType === WhiteSpace || this.tokenType === Comment) {\n            this.next();\n        }\n    }\n    skipUntilBalanced(startToken, stopConsume) {\n        let cursor = startToken;\n        let balanceEnd;\n        let offset;\n\n        loop:\n        for (; cursor < this.tokenCount; cursor++) {\n            balanceEnd = this.balance[cursor];\n\n            // stop scanning on balance edge that points to offset before start token\n            if (balanceEnd < startToken) {\n                break loop;\n            }\n\n            offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;\n\n            // check stop condition\n            switch (stopConsume(this.source.charCodeAt(offset))) {\n                case 1: // just stop\n                    break loop;\n\n                case 2: // stop & included\n                    cursor++;\n                    break loop;\n\n                default:\n                    // fast forward to the end of balanced block\n                    if (this.balance[balanceEnd] === cursor) {\n                        cursor = balanceEnd;\n                    }\n            }\n        }\n\n        this.skip(cursor - this.tokenIndex);\n    }\n\n    forEachToken(fn) {\n        for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {\n            const start = offset;\n            const item = this.offsetAndType[i];\n            const end = item & OFFSET_MASK;\n            const type = item >> TYPE_SHIFT;\n\n            offset = end;\n\n            fn(type, start, end, i);\n        }\n    }\n    dump() {\n        const tokens = new Array(this.tokenCount);\n\n        this.forEachToken((type, start, end, index) => {\n            tokens[index] = {\n                idx: index,\n                type: tokenNames[type],\n                chunk: this.source.substring(start, end),\n                balance: this.balance[index]\n            };\n        });\n\n        return tokens;\n    }\n};\n", "import * as TYPE from './types.js';\nimport {\n    isNewline,\n    isName,\n    isValidEscape,\n    isNumberStart,\n    isIdentifierStart,\n    isBOM,\n    charCodeCategory,\n    WhiteSpaceCategory,\n    DigitCategory,\n    NameStartCategory,\n    NonPrintableCategory\n} from './char-code-definitions.js';\nimport {\n    cmpStr,\n    getNewlineLength,\n    findWhiteSpaceEnd,\n    consumeEscaped,\n    consumeName,\n    consumeNumber,\n    consumeBadUrlRemnants\n} from './utils.js';\n\nexport function tokenize(source, onToken) {\n    function getCharCode(offset) {\n        return offset < sourceLength ? source.charCodeAt(offset) : 0;\n    }\n\n    // § 4.3.3. Consume a numeric token\n    function consumeNumericToken() {\n        // Consume a number and let number be the result.\n        offset = consumeNumber(source, offset);\n\n        // If the next 3 input code points would start an identifier, then:\n        if (isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {\n            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.\n            // Consume a name. Set the <dimension-token>’s unit to the returned value.\n            // Return the <dimension-token>.\n            type = TYPE.Dimension;\n            offset = consumeName(source, offset);\n            return;\n        }\n\n        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.\n        if (getCharCode(offset) === 0x0025) {\n            // Create a <percentage-token> with the same value as number, and return it.\n            type = TYPE.Percentage;\n            offset++;\n            return;\n        }\n\n        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.\n        type = TYPE.Number;\n    }\n\n    // § 4.3.4. Consume an ident-like token\n    function consumeIdentLikeToken() {\n        const nameStartOffset = offset;\n\n        // Consume a name, and let string be the result.\n        offset = consumeName(source, offset);\n\n        // If string’s value is an ASCII case-insensitive match for \"url\",\n        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n        if (cmpStr(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {\n            // While the next two input code points are whitespace, consume the next input code point.\n            offset = findWhiteSpaceEnd(source, offset + 1);\n\n            // If the next one or two input code points are U+0022 QUOTATION MARK (\"), U+0027 APOSTROPHE ('),\n            // or whitespace followed by U+0022 QUOTATION MARK (\") or U+0027 APOSTROPHE ('),\n            // then create a <function-token> with its value set to string and return it.\n            if (getCharCode(offset) === 0x0022 ||\n                getCharCode(offset) === 0x0027) {\n                type = TYPE.Function;\n                offset = nameStartOffset + 4;\n                return;\n            }\n\n            // Otherwise, consume a url token, and return it.\n            consumeUrlToken();\n            return;\n        }\n\n        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n        // Create a <function-token> with its value set to string and return it.\n        if (getCharCode(offset) === 0x0028) {\n            type = TYPE.Function;\n            offset++;\n            return;\n        }\n\n        // Otherwise, create an <ident-token> with its value set to string and return it.\n        type = TYPE.Ident;\n    }\n\n    // § 4.3.5. Consume a string token\n    function consumeStringToken(endingCodePoint) {\n        // This algorithm may be called with an ending code point, which denotes the code point\n        // that ends the string. If an ending code point is not specified,\n        // the current input code point is used.\n        if (!endingCodePoint) {\n            endingCodePoint = getCharCode(offset++);\n        }\n\n        // Initially create a <string-token> with its value set to the empty string.\n        type = TYPE.String;\n\n        // Repeatedly consume the next input code point from the stream:\n        for (; offset < source.length; offset++) {\n            const code = source.charCodeAt(offset);\n\n            switch (charCodeCategory(code)) {\n                // ending code point\n                case endingCodePoint:\n                    // Return the <string-token>.\n                    offset++;\n                    return;\n\n                    // EOF\n                    // case EofCategory:\n                    // This is a parse error. Return the <string-token>.\n                    // return;\n\n                // newline\n                case WhiteSpaceCategory:\n                    if (isNewline(code)) {\n                        // This is a parse error. Reconsume the current input code point,\n                        // create a <bad-string-token>, and return it.\n                        offset += getNewlineLength(source, offset, code);\n                        type = TYPE.BadString;\n                        return;\n                    }\n                    break;\n\n                // U+005C REVERSE SOLIDUS (\\)\n                case 0x005C:\n                    // If the next input code point is EOF, do nothing.\n                    if (offset === source.length - 1) {\n                        break;\n                    }\n\n                    const nextCode = getCharCode(offset + 1);\n\n                    // Otherwise, if the next input code point is a newline, consume it.\n                    if (isNewline(nextCode)) {\n                        offset += getNewlineLength(source, offset + 1, nextCode);\n                    } else if (isValidEscape(code, nextCode)) {\n                        // Otherwise, (the stream starts with a valid escape) consume\n                        // an escaped code point and append the returned code point to\n                        // the <string-token>’s value.\n                        offset = consumeEscaped(source, offset) - 1;\n                    }\n                    break;\n\n                // anything else\n                // Append the current input code point to the <string-token>’s value.\n            }\n        }\n    }\n\n    // § 4.3.6. Consume a url token\n    // Note: This algorithm assumes that the initial \"url(\" has already been consumed.\n    // This algorithm also assumes that it’s being called to consume an \"unquoted\" value, like url(foo).\n    // A quoted value, like url(\"foo\"), is parsed as a <function-token>. Consume an ident-like token\n    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.\n    function consumeUrlToken() {\n        // Initially create a <url-token> with its value set to the empty string.\n        type = TYPE.Url;\n\n        // Consume as much whitespace as possible.\n        offset = findWhiteSpaceEnd(source, offset);\n\n        // Repeatedly consume the next input code point from the stream:\n        for (; offset < source.length; offset++) {\n            const code = source.charCodeAt(offset);\n\n            switch (charCodeCategory(code)) {\n                // U+0029 RIGHT PARENTHESIS ())\n                case 0x0029:\n                    // Return the <url-token>.\n                    offset++;\n                    return;\n\n                    // EOF\n                    // case EofCategory:\n                    // This is a parse error. Return the <url-token>.\n                    // return;\n\n                // whitespace\n                case WhiteSpaceCategory:\n                    // Consume as much whitespace as possible.\n                    offset = findWhiteSpaceEnd(source, offset);\n\n                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,\n                    // consume it and return the <url-token>\n                    // (if EOF was encountered, this is a parse error);\n                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {\n                        if (offset < source.length) {\n                            offset++;\n                        }\n                        return;\n                    }\n\n                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,\n                    // and return it.\n                    offset = consumeBadUrlRemnants(source, offset);\n                    type = TYPE.BadUrl;\n                    return;\n\n                // U+0022 QUOTATION MARK (\")\n                // U+0027 APOSTROPHE (')\n                // U+0028 LEFT PARENTHESIS (()\n                // non-printable code point\n                case 0x0022:\n                case 0x0027:\n                case 0x0028:\n                case NonPrintableCategory:\n                    // This is a parse error. Consume the remnants of a bad url,\n                    // create a <bad-url-token>, and return it.\n                    offset = consumeBadUrlRemnants(source, offset);\n                    type = TYPE.BadUrl;\n                    return;\n\n                // U+005C REVERSE SOLIDUS (\\)\n                case 0x005C:\n                    // If the stream starts with a valid escape, consume an escaped code point and\n                    // append the returned code point to the <url-token>’s value.\n                    if (isValidEscape(code, getCharCode(offset + 1))) {\n                        offset = consumeEscaped(source, offset) - 1;\n                        break;\n                    }\n\n                    // Otherwise, this is a parse error. Consume the remnants of a bad url,\n                    // create a <bad-url-token>, and return it.\n                    offset = consumeBadUrlRemnants(source, offset);\n                    type = TYPE.BadUrl;\n                    return;\n\n                // anything else\n                // Append the current input code point to the <url-token>’s value.\n            }\n        }\n    }\n\n    // ensure source is a string\n    source = String(source || '');\n\n    const sourceLength = source.length;\n    let start = isBOM(getCharCode(0));\n    let offset = start;\n    let type;\n\n    // https://drafts.csswg.org/css-syntax-3/#consume-token\n    // § 4.3.1. Consume a token\n    while (offset < sourceLength) {\n        const code = source.charCodeAt(offset);\n\n        switch (charCodeCategory(code)) {\n            // whitespace\n            case WhiteSpaceCategory:\n                // Consume as much whitespace as possible. Return a <whitespace-token>.\n                type = TYPE.WhiteSpace;\n                offset = findWhiteSpaceEnd(source, offset + 1);\n                break;\n\n            // U+0022 QUOTATION MARK (\")\n            case 0x0022:\n                // Consume a string token and return it.\n                consumeStringToken();\n                break;\n\n            // U+0023 NUMBER SIGN (#)\n            case 0x0023:\n                // If the next input code point is a name code point or the next two input code points are a valid escape, then:\n                if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // Create a <hash-token>.\n                    type = TYPE.Hash;\n\n                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to \"id\".\n                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {\n                    //     // TODO: set id flag\n                    // }\n\n                    // Consume a name, and set the <hash-token>’s value to the returned string.\n                    offset = consumeName(source, offset + 1);\n\n                    // Return the <hash-token>.\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+0027 APOSTROPHE (')\n            case 0x0027:\n                // Consume a string token and return it.\n                consumeStringToken();\n                break;\n\n            // U+0028 LEFT PARENTHESIS (()\n            case 0x0028:\n                // Return a <(-token>.\n                type = TYPE.LeftParenthesis;\n                offset++;\n                break;\n\n            // U+0029 RIGHT PARENTHESIS ())\n            case 0x0029:\n                // Return a <)-token>.\n                type = TYPE.RightParenthesis;\n                offset++;\n                break;\n\n            // U+002B PLUS SIGN (+)\n            case 0x002B:\n                // If the input stream starts with a number, ...\n                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // ... reconsume the current input code point, consume a numeric token, and return it.\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+002C COMMA (,)\n            case 0x002C:\n                // Return a <comma-token>.\n                type = TYPE.Comma;\n                offset++;\n                break;\n\n            // U+002D HYPHEN-MINUS (-)\n            case 0x002D:\n                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.\n                    if (getCharCode(offset + 1) === 0x002D &&\n                        getCharCode(offset + 2) === 0x003E) {\n                        type = TYPE.CDC;\n                        offset = offset + 3;\n                    } else {\n                        // Otherwise, if the input stream starts with an identifier, ...\n                        if (isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                            // ... reconsume the current input code point, consume an ident-like token, and return it.\n                            consumeIdentLikeToken();\n                        } else {\n                            // Otherwise, return a <delim-token> with its value set to the current input code point.\n                            type = TYPE.Delim;\n                            offset++;\n                        }\n                    }\n                }\n                break;\n\n            // U+002E FULL STOP (.)\n            case 0x002E:\n                // If the input stream starts with a number, ...\n                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // ... reconsume the current input code point, consume a numeric token, and return it.\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+002F SOLIDUS (/)\n            case 0x002F:\n                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),\n                if (getCharCode(offset + 1) === 0x002A) {\n                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)\n                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.\n                    type = TYPE.Comment;\n                    offset = source.indexOf('*/', offset + 2);\n                    offset = offset === -1 ? source.length : offset + 2;\n                } else {\n                    type = TYPE.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+003A COLON (:)\n            case 0x003A:\n                // Return a <colon-token>.\n                type = TYPE.Colon;\n                offset++;\n                break;\n\n            // U+003B SEMICOLON (;)\n            case 0x003B:\n                // Return a <semicolon-token>.\n                type = TYPE.Semicolon;\n                offset++;\n                break;\n\n            // U+003C LESS-THAN SIGN (<)\n            case 0x003C:\n                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...\n                if (getCharCode(offset + 1) === 0x0021 &&\n                    getCharCode(offset + 2) === 0x002D &&\n                    getCharCode(offset + 3) === 0x002D) {\n                    // ... consume them and return a <CDO-token>.\n                    type = TYPE.CDO;\n                    offset = offset + 4;\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+0040 COMMERCIAL AT (@)\n            case 0x0040:\n                // If the next 3 input code points would start an identifier, ...\n                if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {\n                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.\n                    type = TYPE.AtKeyword;\n                    offset = consumeName(source, offset + 1);\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+005B LEFT SQUARE BRACKET ([)\n            case 0x005B:\n                // Return a <[-token>.\n                type = TYPE.LeftSquareBracket;\n                offset++;\n                break;\n\n            // U+005C REVERSE SOLIDUS (\\)\n            case 0x005C:\n                // If the input stream starts with a valid escape, ...\n                if (isValidEscape(code, getCharCode(offset + 1))) {\n                    // ... reconsume the current input code point, consume an ident-like token, and return it.\n                    consumeIdentLikeToken();\n                } else {\n                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+005D RIGHT SQUARE BRACKET (])\n            case 0x005D:\n                // Return a <]-token>.\n                type = TYPE.RightSquareBracket;\n                offset++;\n                break;\n\n            // U+007B LEFT CURLY BRACKET ({)\n            case 0x007B:\n                // Return a <{-token>.\n                type = TYPE.LeftCurlyBracket;\n                offset++;\n                break;\n\n            // U+007D RIGHT CURLY BRACKET (})\n            case 0x007D:\n                // Return a <}-token>.\n                type = TYPE.RightCurlyBracket;\n                offset++;\n                break;\n\n            // digit\n            case DigitCategory:\n                // Reconsume the current input code point, consume a numeric token, and return it.\n                consumeNumericToken();\n                break;\n\n            // name-start code point\n            case NameStartCategory:\n                // Reconsume the current input code point, consume an ident-like token, and return it.\n                consumeIdentLikeToken();\n                break;\n\n                // EOF\n                // case EofCategory:\n                // Return an <EOF-token>.\n                // break;\n\n            // anything else\n            default:\n                // Return a <delim-token> with its value set to the current input code point.\n                type = TYPE.Delim;\n                offset++;\n        }\n\n        // put token to stream\n        onToken(type, start, start = offset);\n    }\n}\n\nexport * from './types.js';\nexport * as tokenTypes from './types.js';\nexport { default as tokenNames } from './names.js';\nexport * from './char-code-definitions.js';\nexport * from './utils.js';\nexport * from './OffsetToLocation.js';\nexport * from './TokenStream.js';\n"],
  "mappings": "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",
  "names": ["String", "EOF", "tokenize", "getCharCode", "offset", "String"]
}
