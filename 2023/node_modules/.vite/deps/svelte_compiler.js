import {
  MagicString
} from "./chunk-N3DBNF6C.js";
import {
  require_lib
} from "./chunk-MNTMWZSK.js";
import {
  fork
} from "./chunk-A4OBTVQ3.js";
import {
  require_lib as require_lib2
} from "./chunk-D7K4FGGS.js";
import "./chunk-O7KSR5KV.js";
import {
  Colon,
  Comment,
  Delim,
  Dimension,
  EOF,
  Function as Function2,
  Ident,
  LeftCurlyBracket,
  LeftParenthesis,
  Number as Number2,
  RightParenthesis,
  WhiteSpace
} from "./chunk-ZH4M6KRP.js";
import {
  boolean_attributes,
  is_html,
  is_svg,
  is_void
} from "./chunk-WYAEJAOY.js";
import {
  VERSION
} from "./chunk-ZUGQ3PSC.js";
import {
  getLocator,
  locate
} from "./chunk-KDOXDICI.js";
import {
  b,
  p,
  parse,
  parseExpressionAt,
  print,
  x
} from "./chunk-VGBWBDAK.js";
import {
  isIdentifierChar,
  isIdentifierStart
} from "./chunk-VC7IVDBA.js";
import {
  analyze,
  extract_identifiers,
  extract_names
} from "./chunk-XVISMPHF.js";
import {
  walk
} from "./chunk-A2ECB5VU.js";
import {
  is_reference
} from "./chunk-GP5QEGAN.js";
import {
  require_remapping_umd
} from "./chunk-VRDOALZY.js";
import {
  require_trace_mapping_umd
} from "./chunk-5FYPV2FC.js";
import {
  require_sourcemap_codec_umd
} from "./chunk-CKUFBTIG.js";
import {
  __export,
  __publicField,
  __toESM
} from "./chunk-ZC22LKFR.js";

// node_modules/svelte/src/compiler/Stats.js
var now = () => performance.now();
function collapse_timings(timings) {
  const result = {};
  timings.forEach((timing) => {
    result[timing.label] = Object.assign(
      {
        total: timing.end - timing.start
      },
      timing.children && collapse_timings(timing.children)
    );
  });
  return result;
}
var Stats = class {
  constructor() {
    /**
     * @typedef {Object} Timing
     * @property {string} label
     * @property {number} start
     * @property {number} end
     * @property {Timing[]} children
     */
    /** @type {number} */
    __publicField(this, "start_time");
    /** @type {Timing} */
    __publicField(this, "current_timing");
    /** @type {Timing[]} */
    __publicField(this, "current_children");
    /** @type {Timing[]} */
    __publicField(this, "timings");
    /** @type {Timing[]} */
    __publicField(this, "stack");
    this.start_time = now();
    this.stack = [];
    this.current_children = this.timings = [];
  }
  /** @param {any} label */
  start(label) {
    const timing = {
      label,
      start: now(),
      end: null,
      children: []
    };
    this.current_children.push(timing);
    this.stack.push(timing);
    this.current_timing = timing;
    this.current_children = timing.children;
  }
  /** @param {any} label */
  stop(label) {
    if (label !== this.current_timing.label) {
      throw new Error(
        `Mismatched timing labels (expected ${this.current_timing.label}, got ${label})`
      );
    }
    this.current_timing.end = now();
    this.stack.pop();
    this.current_timing = this.stack[this.stack.length - 1];
    this.current_children = this.current_timing ? this.current_timing.children : this.timings;
  }
  render() {
    const timings = Object.assign(
      {
        total: now() - this.start_time
      },
      collapse_timings(this.timings)
    );
    return {
      timings
    };
  }
};

// node_modules/svelte/src/compiler/utils/flatten.js
function flatten(nodes, target = []) {
  for (let i = 0; i < nodes.length; i += 1) {
    const node = nodes[i];
    if (Array.isArray(node)) {
      flatten(node, target);
    } else {
      target.push(node);
    }
  }
  return target;
}

// node_modules/svelte/src/compiler/utils/patterns.js
var regex_whitespace = /\s/;
var regex_whitespaces = /\s+/;
var regex_starts_with_whitespace = /^\s/;
var regex_starts_with_whitespaces = /^[ \t\r\n]*/;
var regex_ends_with_whitespace = /\s$/;
var regex_ends_with_whitespaces = /[ \t\r\n]*$/;
var regex_only_whitespaces = /^[ \t\n\r\f]+$/;
var regex_whitespace_characters = /\s/g;
var regex_non_whitespace_character = /\S/;
var regex_starts_with_newline = /^\r?\n/;
var regex_not_newline_characters = /[^\n]/g;
var regex_double_quotes = /"/g;
var regex_backslashes = /\\/g;
var regex_starts_with_underscore = /^_/;
var regex_ends_with_underscore = /_$/;
var regex_dimensions = /^(?:offset|client)(?:Width|Height)$/;
var regex_content_rect = /^(?:contentRect)$/;
var regex_content_box_size = /^(?:contentBoxSize)$/;
var regex_border_box_size = /^(?:borderBoxSize)$/;
var regex_device_pixel_content_box_size = /^(?:devicePixelContentBoxSize)$/;
var regex_box_size = /^(?:contentRect|contentBoxSize|borderBoxSize|devicePixelContentBoxSize)$/;

// node_modules/svelte/src/compiler/utils/extract_svelte_ignore.js
var regex_svelte_ignore = /^\s*svelte-ignore\s+([\s\S]+)\s*$/m;
function extract_svelte_ignore(text2) {
  const match = regex_svelte_ignore.exec(text2);
  return match ? match[1].split(regex_whitespace).map((x2) => x2.trim()).filter(Boolean) : [];
}
function extract_svelte_ignore_from_comments(node) {
  return flatten(
    (node.leadingComments || []).map((comment) => extract_svelte_ignore(comment.value))
  );
}
function extract_ignores_above_position(position, template_nodes) {
  const previous_node_idx = template_nodes.findIndex((child) => child.end === position);
  if (previous_node_idx === -1) {
    return [];
  }
  for (let i = previous_node_idx; i >= 0; i--) {
    const node = template_nodes[i];
    if (node.type !== "Comment" && node.type !== "Text") {
      return [];
    }
    if (node.type === "Comment") {
      if (node.ignores.length) {
        return node.ignores;
      }
    }
  }
  return [];
}
function extract_ignores_above_node(node) {
  let cur_node = node.prev;
  while (cur_node) {
    if (cur_node.type !== "Comment" && cur_node.type !== "Text") {
      return [];
    }
    if (cur_node.type === "Comment" && cur_node.ignores.length) {
      return cur_node.ignores;
    }
    cur_node = cur_node.prev;
  }
  return [];
}

// node_modules/svelte/src/compiler/utils/fuzzymatch.js
function fuzzymatch(name8, names) {
  const set = new FuzzySet(names);
  const matches = set.get(name8);
  return matches && matches[0] && matches[0][0] > 0.7 ? matches[0][1] : null;
}
var GRAM_SIZE_LOWER = 2;
var GRAM_SIZE_UPPER = 3;
function _distance(str1, str2) {
  if (str1 === null && str2 === null) {
    throw "Trying to compare two null values";
  }
  if (str1 === null || str2 === null)
    return 0;
  str1 = String(str1);
  str2 = String(str2);
  const distance = levenshtein(str1, str2);
  return 1 - distance / Math.max(str1.length, str2.length);
}
function levenshtein(str1, str2) {
  const current = [];
  let prev;
  let value;
  for (let i = 0; i <= str2.length; i++) {
    for (let j = 0; j <= str1.length; j++) {
      if (i && j) {
        if (str1.charAt(j - 1) === str2.charAt(i - 1)) {
          value = prev;
        } else {
          value = Math.min(current[j], current[j - 1], prev) + 1;
        }
      } else {
        value = i + j;
      }
      prev = current[j];
      current[j] = value;
    }
  }
  return current.pop();
}
var non_word_regex = /[^\w, ]+/;
function iterate_grams(value, gram_size = 2) {
  const simplified = "-" + value.toLowerCase().replace(non_word_regex, "") + "-";
  const len_diff = gram_size - simplified.length;
  const results = [];
  if (len_diff > 0) {
    for (let i = 0; i < len_diff; ++i) {
      value += "-";
    }
  }
  for (let i = 0; i < simplified.length - gram_size + 1; ++i) {
    results.push(simplified.slice(i, i + gram_size));
  }
  return results;
}
function gram_counter(value, gram_size = 2) {
  const result = {};
  const grams = iterate_grams(value, gram_size);
  let i = 0;
  for (i; i < grams.length; ++i) {
    if (grams[i] in result) {
      result[grams[i]] += 1;
    } else {
      result[grams[i]] = 1;
    }
  }
  return result;
}
function sort_descending(a, b2) {
  return b2[0] - a[0];
}
var FuzzySet = class {
  /**
   * @param {string[]} arr
   */
  constructor(arr) {
    __publicField(this, "exact_set", {});
    __publicField(this, "match_dict", {});
    __publicField(this, "items", {});
    for (let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i) {
      this.items[i] = [];
    }
    for (let i = 0; i < arr.length; ++i) {
      this.add(arr[i]);
    }
  }
  /**
   * @param {string} value
   */
  add(value) {
    const normalized_value = value.toLowerCase();
    if (normalized_value in this.exact_set) {
      return false;
    }
    let i = GRAM_SIZE_LOWER;
    for (i; i < GRAM_SIZE_UPPER + 1; ++i) {
      this._add(value, i);
    }
  }
  /**
   * @param {string} value
   * @param {number} gram_size
   */
  _add(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const items = this.items[gram_size] || [];
    const index = items.length;
    items.push(0);
    const gram_counts = gram_counter(normalized_value, gram_size);
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        this.match_dict[gram].push([index, gram_count]);
      } else {
        this.match_dict[gram] = [[index, gram_count]];
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    items[index] = [vector_normal, normalized_value];
    this.items[gram_size] = items;
    this.exact_set[normalized_value] = value;
  }
  /**
   * @param {string} value
   */
  get(value) {
    const normalized_value = value.toLowerCase();
    const result = this.exact_set[normalized_value];
    if (result) {
      return [[1, result]];
    }
    let results = [];
    for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) {
      results = this.__get(value, gram_size);
      if (results) {
        return results;
      }
    }
    return null;
  }
  /**
   * @param {string} value
   * @param {number} gram_size
   */
  __get(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const matches = {};
    const gram_counts = gram_counter(normalized_value, gram_size);
    const items = this.items[gram_size];
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    let i;
    let index;
    let other_gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        for (i = 0; i < this.match_dict[gram].length; ++i) {
          index = this.match_dict[gram][i][0];
          other_gram_count = this.match_dict[gram][i][1];
          if (index in matches) {
            matches[index] += gram_count * other_gram_count;
          } else {
            matches[index] = gram_count * other_gram_count;
          }
        }
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    let results = [];
    let match_score;
    for (const match_index in matches) {
      match_score = matches[match_index];
      results.push([match_score / (vector_normal * items[match_index][0]), items[match_index][1]]);
    }
    results.sort(sort_descending);
    let new_results = [];
    const end_index = Math.min(50, results.length);
    for (let i2 = 0; i2 < end_index; ++i2) {
      new_results.push([_distance(results[i2][1], normalized_value), results[i2][1]]);
    }
    results = new_results;
    results.sort(sort_descending);
    new_results = [];
    for (let i2 = 0; i2 < results.length; ++i2) {
      if (results[i2][0] == results[0][0]) {
        new_results.push([results[i2][0], this.exact_set[results[i2][1]]]);
      }
    }
    return new_results;
  }
};

// node_modules/svelte/src/compiler/utils/list.js
function list(items, conjunction = "or") {
  if (items.length === 1)
    return items[0];
  return `${items.slice(0, -1).join(", ")} ${conjunction} ${items[items.length - 1]}`;
}

// node_modules/svelte/src/compiler/parse/errors.js
var errors_default = {
  /**
   * @param {string} message
   */
  css_syntax_error: (message) => ({
    code: "css-syntax-error",
    message
  }),
  duplicate_attribute: {
    code: "duplicate-attribute",
    message: "Attributes need to be unique"
  },
  /**
   * @param {string} slug
   * @param {string} name
   */
  duplicate_element: (slug, name8) => ({
    code: `duplicate-${slug}`,
    message: `A component can only have one <${name8}> tag`
  }),
  duplicate_style: {
    code: "duplicate-style",
    message: "You can only have one top-level <style> tag per component"
  },
  empty_attribute_shorthand: {
    code: "empty-attribute-shorthand",
    message: "Attribute shorthand cannot be empty"
  },
  /**
   * @param {string} type
   */
  empty_directive_name: (type) => ({
    code: "empty-directive-name",
    message: `${type} name cannot be empty`
  }),
  empty_global_selector: {
    code: "css-syntax-error",
    message: ":global() must contain a selector"
  },
  expected_block_type: {
    code: "expected-block-type",
    message: "Expected if, each or await"
  },
  expected_name: {
    code: "expected-name",
    message: "Expected name"
  },
  /** @param {string} block */
  invalid_catch_placement_unclosed_block: (block) => ({
    code: "invalid-catch-placement",
    message: `Expected to close ${block} before seeing {:catch} block`
  }),
  invalid_catch_placement_without_await: {
    code: "invalid-catch-placement",
    message: "Cannot have an {:catch} block outside an {#await ...} block"
  },
  invalid_component_definition: {
    code: "invalid-component-definition",
    message: "invalid component definition"
  },
  /**
   * @param {string} name
   */
  invalid_closing_tag_unopened: (name8) => ({
    code: "invalid-closing-tag",
    message: `</${name8}> attempted to close an element that was not open`
  }),
  /**
   * @param {string} name
   * @param {string} reason
   */
  invalid_closing_tag_autoclosed: (name8, reason) => ({
    code: "invalid-closing-tag",
    message: `</${name8}> attempted to close <${name8}> that was already automatically closed by <${reason}>`
  }),
  invalid_debug_args: {
    code: "invalid-debug-args",
    message: "{@debug ...} arguments must be identifiers, not arbitrary expressions"
  },
  invalid_declaration: {
    code: "invalid-declaration",
    message: "Declaration cannot be empty"
  },
  invalid_directive_value: {
    code: "invalid-directive-value",
    message: "Directive value must be a JavaScript expression enclosed in curly braces"
  },
  invalid_elseif: {
    code: "invalid-elseif",
    message: "'elseif' should be 'else if'"
  },
  invalid_elseif_placement_outside_if: {
    code: "invalid-elseif-placement",
    message: "Cannot have an {:else if ...} block outside an {#if ...} block"
  },
  /**
   * @param {string} block
   */
  invalid_elseif_placement_unclosed_block: (block) => ({
    code: "invalid-elseif-placement",
    message: `Expected to close ${block} before seeing {:else if ...} block`
  }),
  invalid_else_placement_outside_if: {
    code: "invalid-else-placement",
    message: "Cannot have an {:else} block outside an {#if ...} or {#each ...} block"
  },
  /**
   * @param {string} block
   */
  invalid_else_placement_unclosed_block: (block) => ({
    code: "invalid-else-placement",
    message: `Expected to close ${block} before seeing {:else} block`
  }),
  /**
   * @param {string} slug
   * @param {string} name
   */
  invalid_element_content: (slug, name8) => ({
    code: `invalid-${slug}-content`,
    message: `<${name8}> cannot have children`
  }),
  invalid_element_definition: {
    code: "invalid-element-definition",
    message: "Invalid element definition"
  },
  /**
   * @param {string} slug
   * @param {string} name
   */
  invalid_element_placement: (slug, name8) => ({
    code: `invalid-${slug}-placement`,
    message: `<${name8}> tags cannot be inside elements or blocks`
  }),
  /**
   * @param {string} location
   * @param {string} name
   */
  invalid_logic_block_placement: (location, name8) => ({
    code: "invalid-logic-block-placement",
    message: `{#${name8}} logic block cannot be ${location}`
  }),
  /**
   * @param {string} location
   * @param {string} name
   */
  invalid_tag_placement: (location, name8) => ({
    code: "invalid-tag-placement",
    message: `{@${name8}} tag cannot be ${location}`
  }),
  /**
   * @param {string} name
   */
  invalid_ref_directive: (name8) => ({
    code: "invalid-ref-directive",
    message: `The ref directive is no longer supported â€” use \`bind:this={${name8}}\` instead`
  }),
  invalid_ref_selector: {
    code: "invalid-ref-selector",
    message: "ref selectors are no longer supported"
  },
  invalid_self_placement: {
    code: "invalid-self-placement",
    message: "<svelte:self> components can only exist inside {#if} blocks, {#each} blocks, or slots passed to components"
  },
  invalid_script_instance: {
    code: "invalid-script",
    message: "A component can only have one instance-level <script> element"
  },
  invalid_script_module: {
    code: "invalid-script",
    message: 'A component can only have one <script context="module"> element'
  },
  invalid_script_context_attribute: {
    code: "invalid-script",
    message: "context attribute must be static"
  },
  invalid_script_context_value: {
    code: "invalid-script",
    message: 'If the context attribute is supplied, its value must be "module"'
  },
  invalid_tag_name: {
    code: "invalid-tag-name",
    message: "Expected valid tag name"
  },
  /**
   * @param {string[]} tags
   * @param {string} match
   */
  invalid_tag_name_svelte_element: (tags, match) => ({
    code: "invalid-tag-name",
    message: `Valid <svelte:...> tag names are ${list(tags)}${match ? " (did you mean " + match + "?)" : ""}`
  }),
  /** @param {string} block */
  invalid_then_placement_unclosed_block: (block) => ({
    code: "invalid-then-placement",
    message: `Expected to close ${block} before seeing {:then} block`
  }),
  invalid_then_placement_without_await: {
    code: "invalid-then-placement",
    message: "Cannot have an {:then} block outside an {#await ...} block"
  },
  /**
   * @param {string} name
   */
  invalid_void_content: (name8) => ({
    code: "invalid-void-content",
    message: `<${name8}> is a void element and cannot have children, or a closing tag`
  }),
  missing_component_definition: {
    code: "missing-component-definition",
    message: "<svelte:component> must have a 'this' attribute"
  },
  missing_attribute_value: {
    code: "missing-attribute-value",
    message: "Expected value for the attribute"
  },
  missing_element_definition: {
    code: "missing-element-definition",
    message: "<svelte:element> must have a 'this' attribute"
  },
  unclosed_script: {
    code: "unclosed-script",
    message: "<script> must have a closing tag"
  },
  unclosed_style: {
    code: "unclosed-style",
    message: "<style> must have a closing tag"
  },
  unclosed_comment: {
    code: "unclosed-comment",
    message: "comment was left open, expected -->"
  },
  /**
   * @param {string} token
   */
  unclosed_attribute_value: (token) => ({
    code: "unclosed-attribute-value",
    message: `Expected to close the attribute value with ${token}`
  }),
  unexpected_block_close: {
    code: "unexpected-block-close",
    message: "Unexpected block closing tag"
  },
  unexpected_eof: {
    code: "unexpected-eof",
    message: "Unexpected end of input"
  },
  /**
   * @param {string} token
   */
  unexpected_eof_token: (token) => ({
    code: "unexpected-eof",
    message: `Unexpected ${token}`
  }),
  /**
   * @param {string} token
   */
  unexpected_token: (token) => ({
    code: "unexpected-token",
    message: `Expected ${token}`
  }),
  unexpected_token_destructure: {
    code: "unexpected-token",
    message: "Expected identifier or destructure pattern"
  }
};

// node_modules/svelte/src/compiler/parse/acorn.js
var parse2 = (source) => parse(source, {
  sourceType: "module",
  ecmaVersion: 13,
  locations: true
});
var parse_expression_at = (source, index) => parseExpressionAt(source, index, {
  sourceType: "module",
  ecmaVersion: 13,
  locations: true
});

// node_modules/svelte/src/compiler/parse/read/expression.js
function read_expression(parser) {
  try {
    const node = parse_expression_at(parser.template, parser.index);
    let num_parens = 0;
    for (let i = parser.index; i < node.start; i += 1) {
      if (parser.template[i] === "(")
        num_parens += 1;
    }
    let index = node.end;
    while (num_parens > 0) {
      const char = parser.template[index];
      if (char === ")") {
        num_parens -= 1;
      } else if (!regex_whitespace.test(char)) {
        parser.error(errors_default.unexpected_token(")"), index);
      }
      index += 1;
    }
    parser.index = index;
    return node;
  } catch (err) {
    parser.acorn_error(err);
  }
}

// node_modules/svelte/src/compiler/parse/read/script.js
var regex_closing_script_tag = /<\/script\s*>/;
var regex_starts_with_closing_script_tag = /^<\/script\s*>/;
function get_context(parser, attributes, start) {
  const context = attributes.find((attribute) => attribute.name === "context");
  if (!context)
    return "default";
  if (context.value.length !== 1 || context.value[0].type !== "Text") {
    parser.error(errors_default.invalid_script_context_attribute, start);
  }
  const value = context.value[0].data;
  if (value !== "module") {
    parser.error(errors_default.invalid_script_context_value, context.start);
  }
  return value;
}
function read_script(parser, start, attributes) {
  const script_start = parser.index;
  const data = parser.read_until(regex_closing_script_tag, errors_default.unclosed_script);
  if (parser.index >= parser.template.length) {
    parser.error(errors_default.unclosed_script);
  }
  const source = parser.template.slice(0, script_start).replace(regex_not_newline_characters, " ") + data;
  parser.read(regex_starts_with_closing_script_tag);
  let ast;
  try {
    ast = parse2(source);
  } catch (err) {
    parser.acorn_error(err);
  }
  ast.start = script_start;
  return {
    type: "Script",
    start,
    end: parser.index,
    context: get_context(parser, attributes, start),
    content: ast
  };
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/index.js
var node_exports = {};
__export(node_exports, {
  Comparison: () => comparison_exports,
  ContainerFeatureStyle: () => container_feature_style_exports,
  ContainerQuery: () => container_query_exports,
  MediaQuery: () => media_query_exports,
  QueryCSSFunction: () => query_css_function_exports,
  QueryFeature: () => query_feature_exports,
  QueryFeatureRange: () => query_feature_range_exports
});

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/comparison.js
var comparison_exports = {};
__export(comparison_exports, {
  generate: () => generate,
  name: () => name,
  parse: () => parse3,
  structure: () => structure
});
var name = "Comparison";
var structure = {
  value: String
};
function parse3() {
  const start = this.tokenStart;
  const char1 = this.consume(Delim);
  if (char1 !== "<" && char1 !== ">" && char1 !== "=") {
    this.error("Malformed comparison operator");
  }
  let char2;
  if (this.tokenType === Delim) {
    char2 = this.consume(Delim);
    if (char2 !== "=") {
      this.error("Malformed comparison operator");
    }
  }
  if (this.tokenType === Delim) {
    this.error("Malformed comparison operator");
  }
  const value = char2 ? `${char1}${char2}` : char1;
  return {
    type: "Comparison",
    loc: this.getLocation(start, this.tokenStart),
    value
  };
}
function generate(node) {
  for (let index = 0; index < node.value.length; index++) {
    this.token(Delim, node.value.charAt(index));
  }
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/container_feature_style.js
var container_feature_style_exports = {};
__export(container_feature_style_exports, {
  generate: () => generate2,
  name: () => name2,
  parse: () => parse4,
  structure: () => structure2
});
var name2 = "ContainerFeatureStyle";
var structure2 = {
  name: String,
  value: ["Function", "Identifier", "Number", "Dimension", "QueryCSSFunction", "Ratio", null]
};
function parse4() {
  const start = this.tokenStart;
  let value = null;
  const function_name = this.consumeFunctionName();
  if (function_name !== "style") {
    this.error('Unknown container style query identifier; "style" is expected');
  }
  this.skipSC();
  const name8 = this.consume(Ident);
  this.skipSC();
  if (this.tokenType !== RightParenthesis) {
    this.eat(Colon);
    this.skipSC();
    switch (this.tokenType) {
      case Number2:
        if (this.lookupNonWSType(1) === Delim) {
          value = this.Ratio();
        } else {
          value = this.Number();
        }
        break;
      case Dimension:
        value = this.Dimension();
        break;
      case Function2:
        value = this.QueryCSSFunction();
        break;
      case Ident:
        value = this.Identifier();
        break;
      default:
        this.error("Number, dimension, ratio, function or identifier is expected");
        break;
    }
    this.skipSC();
  }
  this.eat(RightParenthesis);
  return {
    type: "ContainerFeatureStyle",
    loc: this.getLocation(start, this.tokenStart),
    name: name8,
    value
  };
}
function generate2(node) {
  this.token(Function2, "style(");
  this.token(Ident, node.name);
  if (node.value !== null) {
    this.token(Colon, ":");
    this.node(node.value);
  }
  this.token(RightParenthesis, ")");
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/container_query.js
var container_query_exports = {};
__export(container_query_exports, {
  generate: () => generate3,
  name: () => name3,
  parse: () => parse5,
  structure: () => structure3
});

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/lookahead_is_range.js
function lookahead_is_range() {
  let type;
  let offset = 0;
  let count = 0;
  let delim_found = false;
  let no_colon = true;
  do {
    type = this.lookupNonWSType(offset++);
    if (type !== WhiteSpace) {
      count++;
    }
    if (type === Delim) {
      delim_found = true;
    }
    if (type === Colon) {
      no_colon = false;
    }
    if (type === LeftCurlyBracket || type === RightParenthesis) {
      break;
    }
  } while (type !== EOF && count <= 6);
  return delim_found && no_colon;
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/container_query.js
var CONTAINER_QUERY_KEYWORDS = /* @__PURE__ */ new Set(["none", "and", "not", "or"]);
var name3 = "ContainerQuery";
var structure3 = {
  name: "Identifier",
  children: [
    ["Identifier", "QueryFeature", "QueryFeatureRange", "ContainerFeatureStyle", "WhiteSpace"]
  ]
};
function parse5() {
  const start = this.tokenStart;
  const children = this.createList();
  let child = null;
  let name8 = null;
  if (this.tokenType === Ident) {
    const container_name = this.substring(this.tokenStart, this.tokenEnd);
    if (!CONTAINER_QUERY_KEYWORDS.has(container_name.toLowerCase())) {
      name8 = container_name;
      this.eatIdent(container_name);
    }
  }
  this.skipSC();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment:
        case WhiteSpace:
          this.next();
          continue;
        case Ident:
          child = this.Identifier();
          break;
        case Function2:
          child = this.ContainerFeatureStyle();
          break;
        case LeftParenthesis:
          child = lookahead_is_range.call(this) ? this.QueryFeatureRange() : this.QueryFeature();
          break;
        default:
          break scan;
      }
      children.push(child);
    }
  if (child === null) {
    this.error("Identifier or parenthesis is expected");
  }
  return {
    type: "ContainerQuery",
    loc: this.getLocation(start, this.tokenStart - 1),
    name: name8,
    children
  };
}
function generate3(node) {
  if (typeof node.name === "string") {
    this.token(Ident, node.name);
  }
  this.children(node);
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/media_query.js
var media_query_exports = {};
__export(media_query_exports, {
  generate: () => generate4,
  name: () => name4,
  parse: () => parse6,
  structure: () => structure4
});
var name4 = "MediaQuery";
var structure4 = {
  children: [["Identifier", "QueryFeature", "QueryFeatureRange", "WhiteSpace"]]
};
function parse6() {
  const children = this.createList();
  let child = null;
  this.skipSC();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment:
        case WhiteSpace:
          this.next();
          continue;
        case Ident:
          child = this.Identifier();
          break;
        case LeftParenthesis:
          child = lookahead_is_range.call(this) ? this.QueryFeatureRange() : this.QueryFeature();
          break;
        default:
          break scan;
      }
      children.push(child);
    }
  if (child === null) {
    this.error("Identifier or parenthesis is expected");
  }
  return {
    type: "MediaQuery",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate4(node) {
  this.children(node);
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/query_feature.js
var query_feature_exports = {};
__export(query_feature_exports, {
  generate: () => generate5,
  name: () => name5,
  parse: () => parse7,
  structure: () => structure5
});
var name5 = "QueryFeature";
var structure5 = {
  name: String,
  value: ["Identifier", "Number", "Dimension", "QueryCSSFunction", "Ratio", null]
};
function parse7() {
  const start = this.tokenStart;
  let value = null;
  this.eat(LeftParenthesis);
  this.skipSC();
  const name8 = this.consume(Ident);
  this.skipSC();
  if (this.tokenType !== RightParenthesis) {
    this.eat(Colon);
    this.skipSC();
    switch (this.tokenType) {
      case Number2:
        if (this.lookupNonWSType(1) === Delim) {
          value = this.Ratio();
        } else {
          value = this.Number();
        }
        break;
      case Dimension:
        value = this.Dimension();
        break;
      case Function2:
        value = this.QueryCSSFunction();
        break;
      case Ident:
        value = this.Identifier();
        break;
      default:
        this.error("Number, dimension, ratio, function, or identifier is expected");
        break;
    }
    this.skipSC();
  }
  this.eat(RightParenthesis);
  return {
    type: "QueryFeature",
    loc: this.getLocation(start, this.tokenStart),
    name: name8,
    value
  };
}
function generate5(node) {
  this.token(LeftParenthesis, "(");
  this.token(Ident, node.name);
  if (node.value !== null) {
    this.token(Colon, ":");
    this.node(node.value);
  }
  this.token(RightParenthesis, ")");
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/query_feature_range.js
var query_feature_range_exports = {};
__export(query_feature_range_exports, {
  generate: () => generate6,
  name: () => name6,
  parse: () => parse8,
  structure: () => structure6
});
var name6 = "QueryFeatureRange";
var structure6 = {
  name: String,
  value: ["Identifier", "Number", "Comparison", "Dimension", "QueryCSSFunction", "Ratio", null]
};
function lookup_non_ws_type_and_value(offset, type, reference_str) {
  let current_type;
  do {
    current_type = this.lookupType(offset++);
    if (current_type !== WhiteSpace) {
      break;
    }
  } while (current_type !== 0);
  return current_type === type ? this.lookupValue(offset - 1, reference_str) : false;
}
function parse8() {
  const start = this.tokenStart;
  const children = this.createList();
  let child = null;
  this.eat(LeftParenthesis);
  this.skipSC();
  while (!this.eof && this.tokenType !== RightParenthesis) {
    switch (this.tokenType) {
      case Number2:
        if (lookup_non_ws_type_and_value.call(this, 1, Delim, "/")) {
          child = this.Ratio();
        } else {
          child = this.Number();
        }
        break;
      case Delim:
        child = this.Comparison();
        break;
      case Dimension:
        child = this.Dimension();
        break;
      case Function2:
        child = this.QueryCSSFunction();
        break;
      case Ident:
        child = this.Identifier();
        break;
      default:
        this.error("Number, dimension, comparison, ratio, function, or identifier is expected");
        break;
    }
    children.push(child);
    this.skipSC();
  }
  this.eat(RightParenthesis);
  return {
    type: "QueryFeatureRange",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate6(node) {
  this.children(node);
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/query_css_function.js
var query_css_function_exports = {};
__export(query_css_function_exports, {
  generate: () => generate7,
  name: () => name7,
  parse: () => parse9,
  structure: () => structure7
});
var QUERY_CSS_FUNCTIONS = /* @__PURE__ */ new Set(["calc", "clamp", "min", "max"]);
var name7 = "QueryCSSFunction";
var structure7 = {
  name: String,
  expression: String
};
function parse9() {
  const start = this.tokenStart;
  const name8 = this.consumeFunctionName();
  if (!QUERY_CSS_FUNCTIONS.has(name8)) {
    this.error('Unknown query single value function; expected: "calc", "clamp", "max", min"');
  }
  const body = this.Raw(this.tokenIndex, null, false);
  this.eat(RightParenthesis);
  return {
    type: "QueryCSSFunction",
    loc: this.getLocation(start, this.tokenStart),
    name: name8,
    expression: body.value
  };
}
function generate7(node) {
  this.token(Function, `${node.name}(`);
  this.node(node.expression);
  this.token(RightParenthesis, ")");
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/css_tree_parse.js
var cq_syntax = fork({
  atrule: {
    // extend or override at-rule dictionary
    container: {
      parse: {
        prelude() {
          return this.createSingleNodeList(this.ContainerQuery());
        },
        block(is_style_block = false) {
          return this.Block(is_style_block);
        }
      }
    }
  },
  node: node_exports
});
var parse10 = cq_syntax.parse;

// node_modules/svelte/src/compiler/parse/read/style.js
var regex_closing_style_tag = /<\/style\s*>/;
var regex_starts_with_closing_style_tag = /^<\/style\s*>/;
function read_style(parser, start, attributes) {
  const content_start = parser.index;
  const styles = parser.read_until(regex_closing_style_tag, errors_default.unclosed_style);
  if (parser.index >= parser.template.length) {
    parser.error(errors_default.unclosed_style);
  }
  const content_end = parser.index;
  if (parser.css_mode === "none") {
    parser.read(regex_starts_with_closing_style_tag);
    return null;
  }
  let ast;
  try {
    ast = parse10(styles, {
      positions: true,
      offset: content_start,
      onParseError(error2) {
        throw error2;
      }
    });
  } catch (err) {
    if (err.name === "SyntaxError") {
      parser.error(errors_default.css_syntax_error(err.message), err.offset);
    } else {
      throw err;
    }
  }
  ast = JSON.parse(JSON.stringify(ast));
  walk(ast, {
    /** @param {any} node */
    enter: (node) => {
      if (node.type === "Selector") {
        for (let i = 0; i < node.children.length; i += 1) {
          const a = node.children[i];
          const b2 = node.children[i + 1];
          if (is_ref_selector(a, b2)) {
            parser.error(errors_default.invalid_ref_selector, a.loc.start.offset);
          }
        }
      }
      if (node.type === "Declaration" && node.value.type === "Value" && node.value.children.length === 0) {
        parser.error(errors_default.invalid_declaration, node.start);
      }
      if (node.type === "PseudoClassSelector" && node.name === "global" && node.children === null) {
        parser.error(errors_default.empty_global_selector, node.loc.start.offset);
      }
      if (node.loc) {
        node.start = node.loc.start.offset;
        node.end = node.loc.end.offset;
        delete node.loc;
      }
    }
  });
  parser.read(regex_starts_with_closing_style_tag);
  const end = parser.index;
  return {
    type: "Style",
    start,
    end,
    attributes,
    children: ast.children,
    content: {
      start: content_start,
      end: content_end,
      styles
    }
  };
}
function is_ref_selector(a, b2) {
  if (!b2)
    return false;
  return a.type === "TypeSelector" && a.name === "ref" && b2.type === "PseudoClassSelector";
}

// node_modules/svelte/src/compiler/parse/utils/entities.js
var entities_default = {
  "CounterClockwiseContourIntegral;": 8755,
  "ClockwiseContourIntegral;": 8754,
  "DoubleLongLeftRightArrow;": 10234,
  "NotNestedGreaterGreater;": 10914,
  "DiacriticalDoubleAcute;": 733,
  "NotSquareSupersetEqual;": 8931,
  "CloseCurlyDoubleQuote;": 8221,
  "DoubleContourIntegral;": 8751,
  "FilledVerySmallSquare;": 9642,
  "NegativeVeryThinSpace;": 8203,
  "NotPrecedesSlantEqual;": 8928,
  "NotRightTriangleEqual;": 8941,
  "NotSucceedsSlantEqual;": 8929,
  "CapitalDifferentialD;": 8517,
  "DoubleLeftRightArrow;": 8660,
  "DoubleLongRightArrow;": 10233,
  "EmptyVerySmallSquare;": 9643,
  "NestedGreaterGreater;": 8811,
  "NotDoubleVerticalBar;": 8742,
  "NotGreaterSlantEqual;": 10878,
  "NotLeftTriangleEqual;": 8940,
  "NotSquareSubsetEqual;": 8930,
  "OpenCurlyDoubleQuote;": 8220,
  "ReverseUpEquilibrium;": 10607,
  "DoubleLongLeftArrow;": 10232,
  "DownLeftRightVector;": 10576,
  "LeftArrowRightArrow;": 8646,
  "NegativeMediumSpace;": 8203,
  "NotGreaterFullEqual;": 8807,
  "NotRightTriangleBar;": 10704,
  "RightArrowLeftArrow;": 8644,
  "SquareSupersetEqual;": 8850,
  "leftrightsquigarrow;": 8621,
  "DownRightTeeVector;": 10591,
  "DownRightVectorBar;": 10583,
  "LongLeftRightArrow;": 10231,
  "Longleftrightarrow;": 10234,
  "NegativeThickSpace;": 8203,
  "NotLeftTriangleBar;": 10703,
  "PrecedesSlantEqual;": 8828,
  "ReverseEquilibrium;": 8651,
  "RightDoubleBracket;": 10215,
  "RightDownTeeVector;": 10589,
  "RightDownVectorBar;": 10581,
  "RightTriangleEqual;": 8885,
  "SquareIntersection;": 8851,
  "SucceedsSlantEqual;": 8829,
  "blacktriangleright;": 9656,
  "longleftrightarrow;": 10231,
  "DoubleUpDownArrow;": 8661,
  "DoubleVerticalBar;": 8741,
  "DownLeftTeeVector;": 10590,
  "DownLeftVectorBar;": 10582,
  "FilledSmallSquare;": 9724,
  "GreaterSlantEqual;": 10878,
  "LeftDoubleBracket;": 10214,
  "LeftDownTeeVector;": 10593,
  "LeftDownVectorBar;": 10585,
  "LeftTriangleEqual;": 8884,
  "NegativeThinSpace;": 8203,
  "NotGreaterGreater;": 8811,
  "NotLessSlantEqual;": 10877,
  "NotNestedLessLess;": 10913,
  "NotReverseElement;": 8716,
  "NotSquareSuperset;": 8848,
  "NotTildeFullEqual;": 8775,
  "RightAngleBracket;": 10217,
  "RightUpDownVector;": 10575,
  "SquareSubsetEqual;": 8849,
  "VerticalSeparator;": 10072,
  "blacktriangledown;": 9662,
  "blacktriangleleft;": 9666,
  "leftrightharpoons;": 8651,
  "rightleftharpoons;": 8652,
  "twoheadrightarrow;": 8608,
  "DiacriticalAcute;": 180,
  "DiacriticalGrave;": 96,
  "DiacriticalTilde;": 732,
  "DoubleRightArrow;": 8658,
  "DownArrowUpArrow;": 8693,
  "EmptySmallSquare;": 9723,
  "GreaterEqualLess;": 8923,
  "GreaterFullEqual;": 8807,
  "LeftAngleBracket;": 10216,
  "LeftUpDownVector;": 10577,
  "LessEqualGreater;": 8922,
  "NonBreakingSpace;": 160,
  "NotPrecedesEqual;": 10927,
  "NotRightTriangle;": 8939,
  "NotSucceedsEqual;": 10928,
  "NotSucceedsTilde;": 8831,
  "NotSupersetEqual;": 8841,
  "RightTriangleBar;": 10704,
  "RightUpTeeVector;": 10588,
  "RightUpVectorBar;": 10580,
  "UnderParenthesis;": 9181,
  "UpArrowDownArrow;": 8645,
  "circlearrowright;": 8635,
  "downharpoonright;": 8642,
  "ntrianglerighteq;": 8941,
  "rightharpoondown;": 8641,
  "rightrightarrows;": 8649,
  "twoheadleftarrow;": 8606,
  "vartriangleright;": 8883,
  "CloseCurlyQuote;": 8217,
  "ContourIntegral;": 8750,
  "DoubleDownArrow;": 8659,
  "DoubleLeftArrow;": 8656,
  "DownRightVector;": 8641,
  "LeftRightVector;": 10574,
  "LeftTriangleBar;": 10703,
  "LeftUpTeeVector;": 10592,
  "LeftUpVectorBar;": 10584,
  "LowerRightArrow;": 8600,
  "NotGreaterEqual;": 8817,
  "NotGreaterTilde;": 8821,
  "NotHumpDownHump;": 8782,
  "NotLeftTriangle;": 8938,
  "NotSquareSubset;": 8847,
  "OverParenthesis;": 9180,
  "RightDownVector;": 8642,
  "ShortRightArrow;": 8594,
  "UpperRightArrow;": 8599,
  "bigtriangledown;": 9661,
  "circlearrowleft;": 8634,
  "curvearrowright;": 8631,
  "downharpoonleft;": 8643,
  "leftharpoondown;": 8637,
  "leftrightarrows;": 8646,
  "nLeftrightarrow;": 8654,
  "nleftrightarrow;": 8622,
  "ntrianglelefteq;": 8940,
  "rightleftarrows;": 8644,
  "rightsquigarrow;": 8605,
  "rightthreetimes;": 8908,
  "straightepsilon;": 1013,
  "trianglerighteq;": 8885,
  "vartriangleleft;": 8882,
  "DiacriticalDot;": 729,
  "DoubleRightTee;": 8872,
  "DownLeftVector;": 8637,
  "GreaterGreater;": 10914,
  "HorizontalLine;": 9472,
  "InvisibleComma;": 8291,
  "InvisibleTimes;": 8290,
  "LeftDownVector;": 8643,
  "LeftRightArrow;": 8596,
  "Leftrightarrow;": 8660,
  "LessSlantEqual;": 10877,
  "LongRightArrow;": 10230,
  "Longrightarrow;": 10233,
  "LowerLeftArrow;": 8601,
  "NestedLessLess;": 8810,
  "NotGreaterLess;": 8825,
  "NotLessGreater;": 8824,
  "NotSubsetEqual;": 8840,
  "NotVerticalBar;": 8740,
  "OpenCurlyQuote;": 8216,
  "ReverseElement;": 8715,
  "RightTeeVector;": 10587,
  "RightVectorBar;": 10579,
  "ShortDownArrow;": 8595,
  "ShortLeftArrow;": 8592,
  "SquareSuperset;": 8848,
  "TildeFullEqual;": 8773,
  "UpperLeftArrow;": 8598,
  "ZeroWidthSpace;": 8203,
  "curvearrowleft;": 8630,
  "doublebarwedge;": 8966,
  "downdownarrows;": 8650,
  "hookrightarrow;": 8618,
  "leftleftarrows;": 8647,
  "leftrightarrow;": 8596,
  "leftthreetimes;": 8907,
  "longrightarrow;": 10230,
  "looparrowright;": 8620,
  "nshortparallel;": 8742,
  "ntriangleright;": 8939,
  "rightarrowtail;": 8611,
  "rightharpoonup;": 8640,
  "trianglelefteq;": 8884,
  "upharpoonright;": 8638,
  "ApplyFunction;": 8289,
  "DifferentialD;": 8518,
  "DoubleLeftTee;": 10980,
  "DoubleUpArrow;": 8657,
  "LeftTeeVector;": 10586,
  "LeftVectorBar;": 10578,
  "LessFullEqual;": 8806,
  "LongLeftArrow;": 10229,
  "Longleftarrow;": 10232,
  "NotEqualTilde;": 8770,
  "NotTildeEqual;": 8772,
  "NotTildeTilde;": 8777,
  "Poincareplane;": 8460,
  "PrecedesEqual;": 10927,
  "PrecedesTilde;": 8830,
  "RightArrowBar;": 8677,
  "RightTeeArrow;": 8614,
  "RightTriangle;": 8883,
  "RightUpVector;": 8638,
  "SucceedsEqual;": 10928,
  "SucceedsTilde;": 8831,
  "SupersetEqual;": 8839,
  "UpEquilibrium;": 10606,
  "VerticalTilde;": 8768,
  "VeryThinSpace;": 8202,
  "bigtriangleup;": 9651,
  "blacktriangle;": 9652,
  "divideontimes;": 8903,
  "fallingdotseq;": 8786,
  "hookleftarrow;": 8617,
  "leftarrowtail;": 8610,
  "leftharpoonup;": 8636,
  "longleftarrow;": 10229,
  "looparrowleft;": 8619,
  "measuredangle;": 8737,
  "ntriangleleft;": 8938,
  "shortparallel;": 8741,
  "smallsetminus;": 8726,
  "triangleright;": 9657,
  "upharpoonleft;": 8639,
  "varsubsetneqq;": 10955,
  "varsupsetneqq;": 10956,
  "DownArrowBar;": 10515,
  "DownTeeArrow;": 8615,
  "ExponentialE;": 8519,
  "GreaterEqual;": 8805,
  "GreaterTilde;": 8819,
  "HilbertSpace;": 8459,
  "HumpDownHump;": 8782,
  "Intersection;": 8898,
  "LeftArrowBar;": 8676,
  "LeftTeeArrow;": 8612,
  "LeftTriangle;": 8882,
  "LeftUpVector;": 8639,
  "NotCongruent;": 8802,
  "NotHumpEqual;": 8783,
  "NotLessEqual;": 8816,
  "NotLessTilde;": 8820,
  "Proportional;": 8733,
  "RightCeiling;": 8969,
  "RoundImplies;": 10608,
  "ShortUpArrow;": 8593,
  "SquareSubset;": 8847,
  "UnderBracket;": 9141,
  "VerticalLine;": 124,
  "blacklozenge;": 10731,
  "exponentiale;": 8519,
  "risingdotseq;": 8787,
  "triangledown;": 9663,
  "triangleleft;": 9667,
  "varsubsetneq;": 8842,
  "varsupsetneq;": 8843,
  "CircleMinus;": 8854,
  "CircleTimes;": 8855,
  "Equilibrium;": 8652,
  "GreaterLess;": 8823,
  "LeftCeiling;": 8968,
  "LessGreater;": 8822,
  "MediumSpace;": 8287,
  "NotLessLess;": 8810,
  "NotPrecedes;": 8832,
  "NotSucceeds;": 8833,
  "NotSuperset;": 8835,
  "OverBracket;": 9140,
  "RightVector;": 8640,
  "Rrightarrow;": 8667,
  "RuleDelayed;": 10740,
  "SmallCircle;": 8728,
  "SquareUnion;": 8852,
  "SubsetEqual;": 8838,
  "UpDownArrow;": 8597,
  "Updownarrow;": 8661,
  "VerticalBar;": 8739,
  "backepsilon;": 1014,
  "blacksquare;": 9642,
  "circledcirc;": 8858,
  "circleddash;": 8861,
  "curlyeqprec;": 8926,
  "curlyeqsucc;": 8927,
  "diamondsuit;": 9830,
  "eqslantless;": 10901,
  "expectation;": 8496,
  "nRightarrow;": 8655,
  "nrightarrow;": 8603,
  "preccurlyeq;": 8828,
  "precnapprox;": 10937,
  "quaternions;": 8461,
  "straightphi;": 981,
  "succcurlyeq;": 8829,
  "succnapprox;": 10938,
  "thickapprox;": 8776,
  "updownarrow;": 8597,
  "Bernoullis;": 8492,
  "CirclePlus;": 8853,
  "EqualTilde;": 8770,
  "Fouriertrf;": 8497,
  "ImaginaryI;": 8520,
  "Laplacetrf;": 8466,
  "LeftVector;": 8636,
  "Lleftarrow;": 8666,
  "NotElement;": 8713,
  "NotGreater;": 8815,
  "Proportion;": 8759,
  "RightArrow;": 8594,
  "RightFloor;": 8971,
  "Rightarrow;": 8658,
  "ThickSpace;": 8287,
  "TildeEqual;": 8771,
  "TildeTilde;": 8776,
  "UnderBrace;": 9183,
  "UpArrowBar;": 10514,
  "UpTeeArrow;": 8613,
  "circledast;": 8859,
  "complement;": 8705,
  "curlywedge;": 8911,
  "eqslantgtr;": 10902,
  "gtreqqless;": 10892,
  "lessapprox;": 10885,
  "lesseqqgtr;": 10891,
  "lmoustache;": 9136,
  "longmapsto;": 10236,
  "mapstodown;": 8615,
  "mapstoleft;": 8612,
  "nLeftarrow;": 8653,
  "nleftarrow;": 8602,
  "nsubseteqq;": 10949,
  "nsupseteqq;": 10950,
  "precapprox;": 10935,
  "rightarrow;": 8594,
  "rmoustache;": 9137,
  "sqsubseteq;": 8849,
  "sqsupseteq;": 8850,
  "subsetneqq;": 10955,
  "succapprox;": 10936,
  "supsetneqq;": 10956,
  "upuparrows;": 8648,
  "varepsilon;": 1013,
  "varnothing;": 8709,
  "Backslash;": 8726,
  "CenterDot;": 183,
  "CircleDot;": 8857,
  "Congruent;": 8801,
  "Coproduct;": 8720,
  "DoubleDot;": 168,
  "DownArrow;": 8595,
  "DownBreve;": 785,
  "Downarrow;": 8659,
  "HumpEqual;": 8783,
  "LeftArrow;": 8592,
  "LeftFloor;": 8970,
  "Leftarrow;": 8656,
  "LessTilde;": 8818,
  "Mellintrf;": 8499,
  "MinusPlus;": 8723,
  "NotCupCap;": 8813,
  "NotExists;": 8708,
  "NotSubset;": 8834,
  "OverBrace;": 9182,
  "PlusMinus;": 177,
  "Therefore;": 8756,
  "ThinSpace;": 8201,
  "TripleDot;": 8411,
  "UnionPlus;": 8846,
  "backprime;": 8245,
  "backsimeq;": 8909,
  "bigotimes;": 10754,
  "centerdot;": 183,
  "checkmark;": 10003,
  "complexes;": 8450,
  "dotsquare;": 8865,
  "downarrow;": 8595,
  "gtrapprox;": 10886,
  "gtreqless;": 8923,
  "gvertneqq;": 8809,
  "heartsuit;": 9829,
  "leftarrow;": 8592,
  "lesseqgtr;": 8922,
  "lvertneqq;": 8808,
  "ngeqslant;": 10878,
  "nleqslant;": 10877,
  "nparallel;": 8742,
  "nshortmid;": 8740,
  "nsubseteq;": 8840,
  "nsupseteq;": 8841,
  "pitchfork;": 8916,
  "rationals;": 8474,
  "spadesuit;": 9824,
  "subseteqq;": 10949,
  "subsetneq;": 8842,
  "supseteqq;": 10950,
  "supsetneq;": 8843,
  "therefore;": 8756,
  "triangleq;": 8796,
  "varpropto;": 8733,
  "DDotrahd;": 10513,
  "DotEqual;": 8784,
  "Integral;": 8747,
  "LessLess;": 10913,
  "NotEqual;": 8800,
  "NotTilde;": 8769,
  "PartialD;": 8706,
  "Precedes;": 8826,
  "RightTee;": 8866,
  "Succeeds;": 8827,
  "SuchThat;": 8715,
  "Superset;": 8835,
  "Uarrocir;": 10569,
  "UnderBar;": 95,
  "andslope;": 10840,
  "angmsdaa;": 10664,
  "angmsdab;": 10665,
  "angmsdac;": 10666,
  "angmsdad;": 10667,
  "angmsdae;": 10668,
  "angmsdaf;": 10669,
  "angmsdag;": 10670,
  "angmsdah;": 10671,
  "angrtvbd;": 10653,
  "approxeq;": 8778,
  "awconint;": 8755,
  "backcong;": 8780,
  "barwedge;": 8965,
  "bbrktbrk;": 9142,
  "bigoplus;": 10753,
  "bigsqcup;": 10758,
  "biguplus;": 10756,
  "bigwedge;": 8896,
  "boxminus;": 8863,
  "boxtimes;": 8864,
  "bsolhsub;": 10184,
  "capbrcup;": 10825,
  "circledR;": 174,
  "circledS;": 9416,
  "cirfnint;": 10768,
  "clubsuit;": 9827,
  "cupbrcap;": 10824,
  "curlyvee;": 8910,
  "cwconint;": 8754,
  "doteqdot;": 8785,
  "dotminus;": 8760,
  "drbkarow;": 10512,
  "dzigrarr;": 10239,
  "elinters;": 9191,
  "emptyset;": 8709,
  "eqvparsl;": 10725,
  "fpartint;": 10765,
  "geqslant;": 10878,
  "gesdotol;": 10884,
  "gnapprox;": 10890,
  "hksearow;": 10533,
  "hkswarow;": 10534,
  "imagline;": 8464,
  "imagpart;": 8465,
  "infintie;": 10717,
  "integers;": 8484,
  "intercal;": 8890,
  "intlarhk;": 10775,
  "laemptyv;": 10676,
  "ldrushar;": 10571,
  "leqslant;": 10877,
  "lesdotor;": 10883,
  "llcorner;": 8990,
  "lnapprox;": 10889,
  "lrcorner;": 8991,
  "lurdshar;": 10570,
  "mapstoup;": 8613,
  "multimap;": 8888,
  "naturals;": 8469,
  "ncongdot;": 10861,
  "notindot;": 8949,
  "otimesas;": 10806,
  "parallel;": 8741,
  "plusacir;": 10787,
  "pointint;": 10773,
  "precneqq;": 10933,
  "precnsim;": 8936,
  "profalar;": 9006,
  "profline;": 8978,
  "profsurf;": 8979,
  "raemptyv;": 10675,
  "realpart;": 8476,
  "rppolint;": 10770,
  "rtriltri;": 10702,
  "scpolint;": 10771,
  "setminus;": 8726,
  "shortmid;": 8739,
  "smeparsl;": 10724,
  "sqsubset;": 8847,
  "sqsupset;": 8848,
  "subseteq;": 8838,
  "succneqq;": 10934,
  "succnsim;": 8937,
  "supseteq;": 8839,
  "thetasym;": 977,
  "thicksim;": 8764,
  "timesbar;": 10801,
  "triangle;": 9653,
  "triminus;": 10810,
  "trpezium;": 9186,
  "ulcorner;": 8988,
  "urcorner;": 8989,
  "varkappa;": 1008,
  "varsigma;": 962,
  "vartheta;": 977,
  "Because;": 8757,
  "Cayleys;": 8493,
  "Cconint;": 8752,
  "Cedilla;": 184,
  "Diamond;": 8900,
  "DownTee;": 8868,
  "Element;": 8712,
  "Epsilon;": 917,
  "Implies;": 8658,
  "LeftTee;": 8867,
  "NewLine;": 10,
  "NoBreak;": 8288,
  "NotLess;": 8814,
  "Omicron;": 927,
  "OverBar;": 8254,
  "Product;": 8719,
  "UpArrow;": 8593,
  "Uparrow;": 8657,
  "Upsilon;": 933,
  "alefsym;": 8501,
  "angrtvb;": 8894,
  "angzarr;": 9084,
  "asympeq;": 8781,
  "backsim;": 8765,
  "because;": 8757,
  "bemptyv;": 10672,
  "between;": 8812,
  "bigcirc;": 9711,
  "bigodot;": 10752,
  "bigstar;": 9733,
  "bnequiv;": 8801,
  "boxplus;": 8862,
  "ccupssm;": 10832,
  "cemptyv;": 10674,
  "cirscir;": 10690,
  "coloneq;": 8788,
  "congdot;": 10861,
  "cudarrl;": 10552,
  "cudarrr;": 10549,
  "cularrp;": 10557,
  "curarrm;": 10556,
  "dbkarow;": 10511,
  "ddagger;": 8225,
  "ddotseq;": 10871,
  "demptyv;": 10673,
  "diamond;": 8900,
  "digamma;": 989,
  "dotplus;": 8724,
  "dwangle;": 10662,
  "epsilon;": 949,
  "eqcolon;": 8789,
  "equivDD;": 10872,
  "gesdoto;": 10882,
  "gtquest;": 10876,
  "gtrless;": 8823,
  "harrcir;": 10568,
  "intprod;": 10812,
  "isindot;": 8949,
  "larrbfs;": 10527,
  "larrsim;": 10611,
  "lbrksld;": 10639,
  "lbrkslu;": 10637,
  "ldrdhar;": 10599,
  "lesdoto;": 10881,
  "lessdot;": 8918,
  "lessgtr;": 8822,
  "lesssim;": 8818,
  "lotimes;": 10804,
  "lozenge;": 9674,
  "ltquest;": 10875,
  "luruhar;": 10598,
  "maltese;": 10016,
  "minusdu;": 10794,
  "napprox;": 8777,
  "natural;": 9838,
  "nearrow;": 8599,
  "nexists;": 8708,
  "notinva;": 8713,
  "notinvb;": 8951,
  "notinvc;": 8950,
  "notniva;": 8716,
  "notnivb;": 8958,
  "notnivc;": 8957,
  "npolint;": 10772,
  "npreceq;": 10927,
  "nsqsube;": 8930,
  "nsqsupe;": 8931,
  "nsubset;": 8834,
  "nsucceq;": 10928,
  "nsupset;": 8835,
  "nvinfin;": 10718,
  "nvltrie;": 8884,
  "nvrtrie;": 8885,
  "nwarrow;": 8598,
  "olcross;": 10683,
  "omicron;": 959,
  "orderof;": 8500,
  "orslope;": 10839,
  "pertenk;": 8241,
  "planckh;": 8462,
  "pluscir;": 10786,
  "plussim;": 10790,
  "plustwo;": 10791,
  "precsim;": 8830,
  "quatint;": 10774,
  "questeq;": 8799,
  "rarrbfs;": 10528,
  "rarrsim;": 10612,
  "rbrksld;": 10638,
  "rbrkslu;": 10640,
  "rdldhar;": 10601,
  "realine;": 8475,
  "rotimes;": 10805,
  "ruluhar;": 10600,
  "searrow;": 8600,
  "simplus;": 10788,
  "simrarr;": 10610,
  "subedot;": 10947,
  "submult;": 10945,
  "subplus;": 10943,
  "subrarr;": 10617,
  "succsim;": 8831,
  "supdsub;": 10968,
  "supedot;": 10948,
  "suphsol;": 10185,
  "suphsub;": 10967,
  "suplarr;": 10619,
  "supmult;": 10946,
  "supplus;": 10944,
  "swarrow;": 8601,
  "topfork;": 10970,
  "triplus;": 10809,
  "tritime;": 10811,
  "uparrow;": 8593,
  "upsilon;": 965,
  "uwangle;": 10663,
  "vzigzag;": 10650,
  "zigrarr;": 8669,
  "Aacute;": 193,
  "Abreve;": 258,
  "Agrave;": 192,
  "Assign;": 8788,
  "Atilde;": 195,
  "Barwed;": 8966,
  "Bumpeq;": 8782,
  "Cacute;": 262,
  "Ccaron;": 268,
  "Ccedil;": 199,
  "Colone;": 10868,
  "Conint;": 8751,
  "CupCap;": 8781,
  "Dagger;": 8225,
  "Dcaron;": 270,
  "DotDot;": 8412,
  "Dstrok;": 272,
  "Eacute;": 201,
  "Ecaron;": 282,
  "Egrave;": 200,
  "Exists;": 8707,
  "ForAll;": 8704,
  "Gammad;": 988,
  "Gbreve;": 286,
  "Gcedil;": 290,
  "HARDcy;": 1066,
  "Hstrok;": 294,
  "Iacute;": 205,
  "Igrave;": 204,
  "Itilde;": 296,
  "Jsercy;": 1032,
  "Kcedil;": 310,
  "Lacute;": 313,
  "Lambda;": 923,
  "Lcaron;": 317,
  "Lcedil;": 315,
  "Lmidot;": 319,
  "Lstrok;": 321,
  "Nacute;": 323,
  "Ncaron;": 327,
  "Ncedil;": 325,
  "Ntilde;": 209,
  "Oacute;": 211,
  "Odblac;": 336,
  "Ograve;": 210,
  "Oslash;": 216,
  "Otilde;": 213,
  "Otimes;": 10807,
  "Racute;": 340,
  "Rarrtl;": 10518,
  "Rcaron;": 344,
  "Rcedil;": 342,
  "SHCHcy;": 1065,
  "SOFTcy;": 1068,
  "Sacute;": 346,
  "Scaron;": 352,
  "Scedil;": 350,
  "Square;": 9633,
  "Subset;": 8912,
  "Supset;": 8913,
  "Tcaron;": 356,
  "Tcedil;": 354,
  "Tstrok;": 358,
  "Uacute;": 218,
  "Ubreve;": 364,
  "Udblac;": 368,
  "Ugrave;": 217,
  "Utilde;": 360,
  "Vdashl;": 10982,
  "Verbar;": 8214,
  "Vvdash;": 8874,
  "Yacute;": 221,
  "Zacute;": 377,
  "Zcaron;": 381,
  "aacute;": 225,
  "abreve;": 259,
  "agrave;": 224,
  "andand;": 10837,
  "angmsd;": 8737,
  "angsph;": 8738,
  "apacir;": 10863,
  "approx;": 8776,
  "atilde;": 227,
  "barvee;": 8893,
  "barwed;": 8965,
  "becaus;": 8757,
  "bernou;": 8492,
  "bigcap;": 8898,
  "bigcup;": 8899,
  "bigvee;": 8897,
  "bkarow;": 10509,
  "bottom;": 8869,
  "bowtie;": 8904,
  "boxbox;": 10697,
  "bprime;": 8245,
  "brvbar;": 166,
  "bullet;": 8226,
  "bumpeq;": 8783,
  "cacute;": 263,
  "capand;": 10820,
  "capcap;": 10827,
  "capcup;": 10823,
  "capdot;": 10816,
  "ccaron;": 269,
  "ccedil;": 231,
  "circeq;": 8791,
  "cirmid;": 10991,
  "colone;": 8788,
  "commat;": 64,
  "compfn;": 8728,
  "conint;": 8750,
  "coprod;": 8720,
  "copysr;": 8471,
  "cularr;": 8630,
  "cupcap;": 10822,
  "cupcup;": 10826,
  "cupdot;": 8845,
  "curarr;": 8631,
  "curren;": 164,
  "cylcty;": 9005,
  "dagger;": 8224,
  "daleth;": 8504,
  "dcaron;": 271,
  "dfisht;": 10623,
  "divide;": 247,
  "divonx;": 8903,
  "dlcorn;": 8990,
  "dlcrop;": 8973,
  "dollar;": 36,
  "drcorn;": 8991,
  "drcrop;": 8972,
  "dstrok;": 273,
  "eacute;": 233,
  "easter;": 10862,
  "ecaron;": 283,
  "ecolon;": 8789,
  "egrave;": 232,
  "egsdot;": 10904,
  "elsdot;": 10903,
  "emptyv;": 8709,
  "emsp13;": 8196,
  "emsp14;": 8197,
  "eparsl;": 10723,
  "eqcirc;": 8790,
  "equals;": 61,
  "equest;": 8799,
  "female;": 9792,
  "ffilig;": 64259,
  "ffllig;": 64260,
  "forall;": 8704,
  "frac12;": 189,
  "frac13;": 8531,
  "frac14;": 188,
  "frac15;": 8533,
  "frac16;": 8537,
  "frac18;": 8539,
  "frac23;": 8532,
  "frac25;": 8534,
  "frac34;": 190,
  "frac35;": 8535,
  "frac38;": 8540,
  "frac45;": 8536,
  "frac56;": 8538,
  "frac58;": 8541,
  "frac78;": 8542,
  "gacute;": 501,
  "gammad;": 989,
  "gbreve;": 287,
  "gesdot;": 10880,
  "gesles;": 10900,
  "gtlPar;": 10645,
  "gtrarr;": 10616,
  "gtrdot;": 8919,
  "gtrsim;": 8819,
  "hairsp;": 8202,
  "hamilt;": 8459,
  "hardcy;": 1098,
  "hearts;": 9829,
  "hellip;": 8230,
  "hercon;": 8889,
  "homtht;": 8763,
  "horbar;": 8213,
  "hslash;": 8463,
  "hstrok;": 295,
  "hybull;": 8259,
  "hyphen;": 8208,
  "iacute;": 237,
  "igrave;": 236,
  "iiiint;": 10764,
  "iinfin;": 10716,
  "incare;": 8453,
  "inodot;": 305,
  "intcal;": 8890,
  "iquest;": 191,
  "isinsv;": 8947,
  "itilde;": 297,
  "jsercy;": 1112,
  "kappav;": 1008,
  "kcedil;": 311,
  "kgreen;": 312,
  "lAtail;": 10523,
  "lacute;": 314,
  "lagran;": 8466,
  "lambda;": 955,
  "langle;": 10216,
  "larrfs;": 10525,
  "larrhk;": 8617,
  "larrlp;": 8619,
  "larrpl;": 10553,
  "larrtl;": 8610,
  "latail;": 10521,
  "lbrace;": 123,
  "lbrack;": 91,
  "lcaron;": 318,
  "lcedil;": 316,
  "ldquor;": 8222,
  "lesdot;": 10879,
  "lesges;": 10899,
  "lfisht;": 10620,
  "lfloor;": 8970,
  "lharul;": 10602,
  "llhard;": 10603,
  "lmidot;": 320,
  "lmoust;": 9136,
  "loplus;": 10797,
  "lowast;": 8727,
  "lowbar;": 95,
  "lparlt;": 10643,
  "lrhard;": 10605,
  "lsaquo;": 8249,
  "lsquor;": 8218,
  "lstrok;": 322,
  "lthree;": 8907,
  "ltimes;": 8905,
  "ltlarr;": 10614,
  "ltrPar;": 10646,
  "mapsto;": 8614,
  "marker;": 9646,
  "mcomma;": 10793,
  "midast;": 42,
  "midcir;": 10992,
  "middot;": 183,
  "minusb;": 8863,
  "minusd;": 8760,
  "mnplus;": 8723,
  "models;": 8871,
  "mstpos;": 8766,
  "nVDash;": 8879,
  "nVdash;": 8878,
  "nacute;": 324,
  "nbumpe;": 8783,
  "ncaron;": 328,
  "ncedil;": 326,
  "nearhk;": 10532,
  "nequiv;": 8802,
  "nesear;": 10536,
  "nexist;": 8708,
  "nltrie;": 8940,
  "notinE;": 8953,
  "nparsl;": 11005,
  "nprcue;": 8928,
  "nrarrc;": 10547,
  "nrarrw;": 8605,
  "nrtrie;": 8941,
  "nsccue;": 8929,
  "nsimeq;": 8772,
  "ntilde;": 241,
  "numero;": 8470,
  "nvDash;": 8877,
  "nvHarr;": 10500,
  "nvdash;": 8876,
  "nvlArr;": 10498,
  "nvrArr;": 10499,
  "nwarhk;": 10531,
  "nwnear;": 10535,
  "oacute;": 243,
  "odblac;": 337,
  "odsold;": 10684,
  "ograve;": 242,
  "ominus;": 8854,
  "origof;": 8886,
  "oslash;": 248,
  "otilde;": 245,
  "otimes;": 8855,
  "parsim;": 10995,
  "percnt;": 37,
  "period;": 46,
  "permil;": 8240,
  "phmmat;": 8499,
  "planck;": 8463,
  "plankv;": 8463,
  "plusdo;": 8724,
  "plusdu;": 10789,
  "plusmn;": 177,
  "preceq;": 10927,
  "primes;": 8473,
  "prnsim;": 8936,
  "propto;": 8733,
  "prurel;": 8880,
  "puncsp;": 8200,
  "qprime;": 8279,
  "rAtail;": 10524,
  "racute;": 341,
  "rangle;": 10217,
  "rarrap;": 10613,
  "rarrfs;": 10526,
  "rarrhk;": 8618,
  "rarrlp;": 8620,
  "rarrpl;": 10565,
  "rarrtl;": 8611,
  "ratail;": 10522,
  "rbrace;": 125,
  "rbrack;": 93,
  "rcaron;": 345,
  "rcedil;": 343,
  "rdquor;": 8221,
  "rfisht;": 10621,
  "rfloor;": 8971,
  "rharul;": 10604,
  "rmoust;": 9137,
  "roplus;": 10798,
  "rpargt;": 10644,
  "rsaquo;": 8250,
  "rsquor;": 8217,
  "rthree;": 8908,
  "rtimes;": 8906,
  "sacute;": 347,
  "scaron;": 353,
  "scedil;": 351,
  "scnsim;": 8937,
  "searhk;": 10533,
  "seswar;": 10537,
  "sfrown;": 8994,
  "shchcy;": 1097,
  "sigmaf;": 962,
  "sigmav;": 962,
  "simdot;": 10858,
  "smashp;": 10803,
  "softcy;": 1100,
  "solbar;": 9023,
  "spades;": 9824,
  "sqcaps;": 8851,
  "sqcups;": 8852,
  "sqsube;": 8849,
  "sqsupe;": 8850,
  "square;": 9633,
  "squarf;": 9642,
  "ssetmn;": 8726,
  "ssmile;": 8995,
  "sstarf;": 8902,
  "subdot;": 10941,
  "subset;": 8834,
  "subsim;": 10951,
  "subsub;": 10965,
  "subsup;": 10963,
  "succeq;": 10928,
  "supdot;": 10942,
  "supset;": 8835,
  "supsim;": 10952,
  "supsub;": 10964,
  "supsup;": 10966,
  "swarhk;": 10534,
  "swnwar;": 10538,
  "target;": 8982,
  "tcaron;": 357,
  "tcedil;": 355,
  "telrec;": 8981,
  "there4;": 8756,
  "thetav;": 977,
  "thinsp;": 8201,
  "thksim;": 8764,
  "timesb;": 8864,
  "timesd;": 10800,
  "topbot;": 9014,
  "topcir;": 10993,
  "tprime;": 8244,
  "tridot;": 9708,
  "tstrok;": 359,
  "uacute;": 250,
  "ubreve;": 365,
  "udblac;": 369,
  "ufisht;": 10622,
  "ugrave;": 249,
  "ulcorn;": 8988,
  "ulcrop;": 8975,
  "urcorn;": 8989,
  "urcrop;": 8974,
  "utilde;": 361,
  "vangrt;": 10652,
  "varphi;": 981,
  "varrho;": 1009,
  "veebar;": 8891,
  "vellip;": 8942,
  "verbar;": 124,
  "vsubnE;": 10955,
  "vsubne;": 8842,
  "vsupnE;": 10956,
  "vsupne;": 8843,
  "wedbar;": 10847,
  "wedgeq;": 8793,
  "weierp;": 8472,
  "wreath;": 8768,
  "xoplus;": 10753,
  "xotime;": 10754,
  "xsqcup;": 10758,
  "xuplus;": 10756,
  "xwedge;": 8896,
  "yacute;": 253,
  "zacute;": 378,
  "zcaron;": 382,
  "zeetrf;": 8488,
  "AElig;": 198,
  Aacute: 193,
  "Acirc;": 194,
  Agrave: 192,
  "Alpha;": 913,
  "Amacr;": 256,
  "Aogon;": 260,
  "Aring;": 197,
  Atilde: 195,
  "Breve;": 728,
  Ccedil: 199,
  "Ccirc;": 264,
  "Colon;": 8759,
  "Cross;": 10799,
  "Dashv;": 10980,
  "Delta;": 916,
  Eacute: 201,
  "Ecirc;": 202,
  Egrave: 200,
  "Emacr;": 274,
  "Eogon;": 280,
  "Equal;": 10869,
  "Gamma;": 915,
  "Gcirc;": 284,
  "Hacek;": 711,
  "Hcirc;": 292,
  "IJlig;": 306,
  Iacute: 205,
  "Icirc;": 206,
  Igrave: 204,
  "Imacr;": 298,
  "Iogon;": 302,
  "Iukcy;": 1030,
  "Jcirc;": 308,
  "Jukcy;": 1028,
  "Kappa;": 922,
  Ntilde: 209,
  "OElig;": 338,
  Oacute: 211,
  "Ocirc;": 212,
  Ograve: 210,
  "Omacr;": 332,
  "Omega;": 937,
  Oslash: 216,
  Otilde: 213,
  "Prime;": 8243,
  "RBarr;": 10512,
  "Scirc;": 348,
  "Sigma;": 931,
  "THORN;": 222,
  "TRADE;": 8482,
  "TSHcy;": 1035,
  "Theta;": 920,
  "Tilde;": 8764,
  Uacute: 218,
  "Ubrcy;": 1038,
  "Ucirc;": 219,
  Ugrave: 217,
  "Umacr;": 362,
  "Union;": 8899,
  "Uogon;": 370,
  "UpTee;": 8869,
  "Uring;": 366,
  "VDash;": 8875,
  "Vdash;": 8873,
  "Wcirc;": 372,
  "Wedge;": 8896,
  Yacute: 221,
  "Ycirc;": 374,
  aacute: 225,
  "acirc;": 226,
  "acute;": 180,
  "aelig;": 230,
  agrave: 224,
  "aleph;": 8501,
  "alpha;": 945,
  "amacr;": 257,
  "amalg;": 10815,
  "angle;": 8736,
  "angrt;": 8735,
  "angst;": 197,
  "aogon;": 261,
  "aring;": 229,
  "asymp;": 8776,
  atilde: 227,
  "awint;": 10769,
  "bcong;": 8780,
  "bdquo;": 8222,
  "bepsi;": 1014,
  "blank;": 9251,
  "blk12;": 9618,
  "blk14;": 9617,
  "blk34;": 9619,
  "block;": 9608,
  "boxDL;": 9559,
  "boxDR;": 9556,
  "boxDl;": 9558,
  "boxDr;": 9555,
  "boxHD;": 9574,
  "boxHU;": 9577,
  "boxHd;": 9572,
  "boxHu;": 9575,
  "boxUL;": 9565,
  "boxUR;": 9562,
  "boxUl;": 9564,
  "boxUr;": 9561,
  "boxVH;": 9580,
  "boxVL;": 9571,
  "boxVR;": 9568,
  "boxVh;": 9579,
  "boxVl;": 9570,
  "boxVr;": 9567,
  "boxdL;": 9557,
  "boxdR;": 9554,
  "boxdl;": 9488,
  "boxdr;": 9484,
  "boxhD;": 9573,
  "boxhU;": 9576,
  "boxhd;": 9516,
  "boxhu;": 9524,
  "boxuL;": 9563,
  "boxuR;": 9560,
  "boxul;": 9496,
  "boxur;": 9492,
  "boxvH;": 9578,
  "boxvL;": 9569,
  "boxvR;": 9566,
  "boxvh;": 9532,
  "boxvl;": 9508,
  "boxvr;": 9500,
  "breve;": 728,
  brvbar: 166,
  "bsemi;": 8271,
  "bsime;": 8909,
  "bsolb;": 10693,
  "bumpE;": 10926,
  "bumpe;": 8783,
  "caret;": 8257,
  "caron;": 711,
  "ccaps;": 10829,
  ccedil: 231,
  "ccirc;": 265,
  "ccups;": 10828,
  "cedil;": 184,
  "check;": 10003,
  "clubs;": 9827,
  "colon;": 58,
  "comma;": 44,
  "crarr;": 8629,
  "cross;": 10007,
  "csube;": 10961,
  "csupe;": 10962,
  "ctdot;": 8943,
  "cuepr;": 8926,
  "cuesc;": 8927,
  "cupor;": 10821,
  curren: 164,
  "cuvee;": 8910,
  "cuwed;": 8911,
  "cwint;": 8753,
  "dashv;": 8867,
  "dblac;": 733,
  "ddarr;": 8650,
  "delta;": 948,
  "dharl;": 8643,
  "dharr;": 8642,
  "diams;": 9830,
  "disin;": 8946,
  divide: 247,
  "doteq;": 8784,
  "dtdot;": 8945,
  "dtrif;": 9662,
  "duarr;": 8693,
  "duhar;": 10607,
  "eDDot;": 10871,
  eacute: 233,
  "ecirc;": 234,
  "efDot;": 8786,
  egrave: 232,
  "emacr;": 275,
  "empty;": 8709,
  "eogon;": 281,
  "eplus;": 10865,
  "epsiv;": 1013,
  "eqsim;": 8770,
  "equiv;": 8801,
  "erDot;": 8787,
  "erarr;": 10609,
  "esdot;": 8784,
  "exist;": 8707,
  "fflig;": 64256,
  "filig;": 64257,
  "fjlig;": 102,
  "fllig;": 64258,
  "fltns;": 9649,
  "forkv;": 10969,
  frac12: 189,
  frac14: 188,
  frac34: 190,
  "frasl;": 8260,
  "frown;": 8994,
  "gamma;": 947,
  "gcirc;": 285,
  "gescc;": 10921,
  "gimel;": 8503,
  "gneqq;": 8809,
  "gnsim;": 8935,
  "grave;": 96,
  "gsime;": 10894,
  "gsiml;": 10896,
  "gtcir;": 10874,
  "gtdot;": 8919,
  "harrw;": 8621,
  "hcirc;": 293,
  "hoarr;": 8703,
  iacute: 237,
  "icirc;": 238,
  "iexcl;": 161,
  igrave: 236,
  "iiint;": 8749,
  "iiota;": 8489,
  "ijlig;": 307,
  "imacr;": 299,
  "image;": 8465,
  "imath;": 305,
  "imped;": 437,
  "infin;": 8734,
  "iogon;": 303,
  "iprod;": 10812,
  iquest: 191,
  "isinE;": 8953,
  "isins;": 8948,
  "isinv;": 8712,
  "iukcy;": 1110,
  "jcirc;": 309,
  "jmath;": 567,
  "jukcy;": 1108,
  "kappa;": 954,
  "lAarr;": 8666,
  "lBarr;": 10510,
  "langd;": 10641,
  "laquo;": 171,
  "larrb;": 8676,
  "lates;": 10925,
  "lbarr;": 10508,
  "lbbrk;": 10098,
  "lbrke;": 10635,
  "lceil;": 8968,
  "ldquo;": 8220,
  "lescc;": 10920,
  "lhard;": 8637,
  "lharu;": 8636,
  "lhblk;": 9604,
  "llarr;": 8647,
  "lltri;": 9722,
  "lneqq;": 8808,
  "lnsim;": 8934,
  "loang;": 10220,
  "loarr;": 8701,
  "lobrk;": 10214,
  "lopar;": 10629,
  "lrarr;": 8646,
  "lrhar;": 8651,
  "lrtri;": 8895,
  "lsime;": 10893,
  "lsimg;": 10895,
  "lsquo;": 8216,
  "ltcir;": 10873,
  "ltdot;": 8918,
  "ltrie;": 8884,
  "ltrif;": 9666,
  "mDDot;": 8762,
  "mdash;": 8212,
  "micro;": 181,
  middot: 183,
  "minus;": 8722,
  "mumap;": 8888,
  "nabla;": 8711,
  "napid;": 8779,
  "napos;": 329,
  "natur;": 9838,
  "nbump;": 8782,
  "ncong;": 8775,
  "ndash;": 8211,
  "neArr;": 8663,
  "nearr;": 8599,
  "nedot;": 8784,
  "nesim;": 8770,
  "ngeqq;": 8807,
  "ngsim;": 8821,
  "nhArr;": 8654,
  "nharr;": 8622,
  "nhpar;": 10994,
  "nlArr;": 8653,
  "nlarr;": 8602,
  "nleqq;": 8806,
  "nless;": 8814,
  "nlsim;": 8820,
  "nltri;": 8938,
  "notin;": 8713,
  "notni;": 8716,
  "npart;": 8706,
  "nprec;": 8832,
  "nrArr;": 8655,
  "nrarr;": 8603,
  "nrtri;": 8939,
  "nsime;": 8772,
  "nsmid;": 8740,
  "nspar;": 8742,
  "nsubE;": 10949,
  "nsube;": 8840,
  "nsucc;": 8833,
  "nsupE;": 10950,
  "nsupe;": 8841,
  ntilde: 241,
  "numsp;": 8199,
  "nvsim;": 8764,
  "nwArr;": 8662,
  "nwarr;": 8598,
  oacute: 243,
  "ocirc;": 244,
  "odash;": 8861,
  "oelig;": 339,
  "ofcir;": 10687,
  ograve: 242,
  "ohbar;": 10677,
  "olarr;": 8634,
  "olcir;": 10686,
  "oline;": 8254,
  "omacr;": 333,
  "omega;": 969,
  "operp;": 10681,
  "oplus;": 8853,
  "orarr;": 8635,
  "order;": 8500,
  oslash: 248,
  otilde: 245,
  "ovbar;": 9021,
  "parsl;": 11005,
  "phone;": 9742,
  "plusb;": 8862,
  "pluse;": 10866,
  plusmn: 177,
  "pound;": 163,
  "prcue;": 8828,
  "prime;": 8242,
  "prnap;": 10937,
  "prsim;": 8830,
  "quest;": 63,
  "rAarr;": 8667,
  "rBarr;": 10511,
  "radic;": 8730,
  "rangd;": 10642,
  "range;": 10661,
  "raquo;": 187,
  "rarrb;": 8677,
  "rarrc;": 10547,
  "rarrw;": 8605,
  "ratio;": 8758,
  "rbarr;": 10509,
  "rbbrk;": 10099,
  "rbrke;": 10636,
  "rceil;": 8969,
  "rdquo;": 8221,
  "reals;": 8477,
  "rhard;": 8641,
  "rharu;": 8640,
  "rlarr;": 8644,
  "rlhar;": 8652,
  "rnmid;": 10990,
  "roang;": 10221,
  "roarr;": 8702,
  "robrk;": 10215,
  "ropar;": 10630,
  "rrarr;": 8649,
  "rsquo;": 8217,
  "rtrie;": 8885,
  "rtrif;": 9656,
  "sbquo;": 8218,
  "sccue;": 8829,
  "scirc;": 349,
  "scnap;": 10938,
  "scsim;": 8831,
  "sdotb;": 8865,
  "sdote;": 10854,
  "seArr;": 8664,
  "searr;": 8600,
  "setmn;": 8726,
  "sharp;": 9839,
  "sigma;": 963,
  "simeq;": 8771,
  "simgE;": 10912,
  "simlE;": 10911,
  "simne;": 8774,
  "slarr;": 8592,
  "smile;": 8995,
  "smtes;": 10924,
  "sqcap;": 8851,
  "sqcup;": 8852,
  "sqsub;": 8847,
  "sqsup;": 8848,
  "srarr;": 8594,
  "starf;": 9733,
  "strns;": 175,
  "subnE;": 10955,
  "subne;": 8842,
  "supnE;": 10956,
  "supne;": 8843,
  "swArr;": 8665,
  "swarr;": 8601,
  "szlig;": 223,
  "theta;": 952,
  "thkap;": 8776,
  "thorn;": 254,
  "tilde;": 732,
  "times;": 215,
  "trade;": 8482,
  "trisb;": 10701,
  "tshcy;": 1115,
  "twixt;": 8812,
  uacute: 250,
  "ubrcy;": 1118,
  "ucirc;": 251,
  "udarr;": 8645,
  "udhar;": 10606,
  ugrave: 249,
  "uharl;": 8639,
  "uharr;": 8638,
  "uhblk;": 9600,
  "ultri;": 9720,
  "umacr;": 363,
  "uogon;": 371,
  "uplus;": 8846,
  "upsih;": 978,
  "uring;": 367,
  "urtri;": 9721,
  "utdot;": 8944,
  "utrif;": 9652,
  "uuarr;": 8648,
  "vBarv;": 10985,
  "vDash;": 8872,
  "varpi;": 982,
  "vdash;": 8866,
  "veeeq;": 8794,
  "vltri;": 8882,
  "vnsub;": 8834,
  "vnsup;": 8835,
  "vprop;": 8733,
  "vrtri;": 8883,
  "wcirc;": 373,
  "wedge;": 8743,
  "xcirc;": 9711,
  "xdtri;": 9661,
  "xhArr;": 10234,
  "xharr;": 10231,
  "xlArr;": 10232,
  "xlarr;": 10229,
  "xodot;": 10752,
  "xrArr;": 10233,
  "xrarr;": 10230,
  "xutri;": 9651,
  yacute: 253,
  "ycirc;": 375,
  AElig: 198,
  Acirc: 194,
  "Aopf;": 120120,
  Aring: 197,
  "Ascr;": 119964,
  "Auml;": 196,
  "Barv;": 10983,
  "Beta;": 914,
  "Bopf;": 120121,
  "Bscr;": 8492,
  "CHcy;": 1063,
  "COPY;": 169,
  "Cdot;": 266,
  "Copf;": 8450,
  "Cscr;": 119966,
  "DJcy;": 1026,
  "DScy;": 1029,
  "DZcy;": 1039,
  "Darr;": 8609,
  "Dopf;": 120123,
  "Dscr;": 119967,
  Ecirc: 202,
  "Edot;": 278,
  "Eopf;": 120124,
  "Escr;": 8496,
  "Esim;": 10867,
  "Euml;": 203,
  "Fopf;": 120125,
  "Fscr;": 8497,
  "GJcy;": 1027,
  "Gdot;": 288,
  "Gopf;": 120126,
  "Gscr;": 119970,
  "Hopf;": 8461,
  "Hscr;": 8459,
  "IEcy;": 1045,
  "IOcy;": 1025,
  Icirc: 206,
  "Idot;": 304,
  "Iopf;": 120128,
  "Iota;": 921,
  "Iscr;": 8464,
  "Iuml;": 207,
  "Jopf;": 120129,
  "Jscr;": 119973,
  "KHcy;": 1061,
  "KJcy;": 1036,
  "Kopf;": 120130,
  "Kscr;": 119974,
  "LJcy;": 1033,
  "Lang;": 10218,
  "Larr;": 8606,
  "Lopf;": 120131,
  "Lscr;": 8466,
  "Mopf;": 120132,
  "Mscr;": 8499,
  "NJcy;": 1034,
  "Nopf;": 8469,
  "Nscr;": 119977,
  Ocirc: 212,
  "Oopf;": 120134,
  "Oscr;": 119978,
  "Ouml;": 214,
  "Popf;": 8473,
  "Pscr;": 119979,
  "QUOT;": 34,
  "Qopf;": 8474,
  "Qscr;": 119980,
  "Rang;": 10219,
  "Rarr;": 8608,
  "Ropf;": 8477,
  "Rscr;": 8475,
  "SHcy;": 1064,
  "Sopf;": 120138,
  "Sqrt;": 8730,
  "Sscr;": 119982,
  "Star;": 8902,
  THORN: 222,
  "TScy;": 1062,
  "Topf;": 120139,
  "Tscr;": 119983,
  "Uarr;": 8607,
  Ucirc: 219,
  "Uopf;": 120140,
  "Upsi;": 978,
  "Uscr;": 119984,
  "Uuml;": 220,
  "Vbar;": 10987,
  "Vert;": 8214,
  "Vopf;": 120141,
  "Vscr;": 119985,
  "Wopf;": 120142,
  "Wscr;": 119986,
  "Xopf;": 120143,
  "Xscr;": 119987,
  "YAcy;": 1071,
  "YIcy;": 1031,
  "YUcy;": 1070,
  "Yopf;": 120144,
  "Yscr;": 119988,
  "Yuml;": 376,
  "ZHcy;": 1046,
  "Zdot;": 379,
  "Zeta;": 918,
  "Zopf;": 8484,
  "Zscr;": 119989,
  acirc: 226,
  acute: 180,
  aelig: 230,
  "andd;": 10844,
  "andv;": 10842,
  "ange;": 10660,
  "aopf;": 120146,
  "apid;": 8779,
  "apos;": 39,
  aring: 229,
  "ascr;": 119990,
  "auml;": 228,
  "bNot;": 10989,
  "bbrk;": 9141,
  "beta;": 946,
  "beth;": 8502,
  "bnot;": 8976,
  "bopf;": 120147,
  "boxH;": 9552,
  "boxV;": 9553,
  "boxh;": 9472,
  "boxv;": 9474,
  "bscr;": 119991,
  "bsim;": 8765,
  "bsol;": 92,
  "bull;": 8226,
  "bump;": 8782,
  "caps;": 8745,
  "cdot;": 267,
  cedil: 184,
  "cent;": 162,
  "chcy;": 1095,
  "cirE;": 10691,
  "circ;": 710,
  "cire;": 8791,
  "comp;": 8705,
  "cong;": 8773,
  "copf;": 120148,
  "copy;": 169,
  "cscr;": 119992,
  "csub;": 10959,
  "csup;": 10960,
  "cups;": 8746,
  "dArr;": 8659,
  "dHar;": 10597,
  "darr;": 8595,
  "dash;": 8208,
  "diam;": 8900,
  "djcy;": 1106,
  "dopf;": 120149,
  "dscr;": 119993,
  "dscy;": 1109,
  "dsol;": 10742,
  "dtri;": 9663,
  "dzcy;": 1119,
  "eDot;": 8785,
  "ecir;": 8790,
  ecirc: 234,
  "edot;": 279,
  "emsp;": 8195,
  "ensp;": 8194,
  "eopf;": 120150,
  "epar;": 8917,
  "epsi;": 949,
  "escr;": 8495,
  "esim;": 8770,
  "euml;": 235,
  "euro;": 8364,
  "excl;": 33,
  "flat;": 9837,
  "fnof;": 402,
  "fopf;": 120151,
  "fork;": 8916,
  "fscr;": 119995,
  "gdot;": 289,
  "geqq;": 8807,
  "gesl;": 8923,
  "gjcy;": 1107,
  "gnap;": 10890,
  "gneq;": 10888,
  "gopf;": 120152,
  "gscr;": 8458,
  "gsim;": 8819,
  "gtcc;": 10919,
  "gvnE;": 8809,
  "hArr;": 8660,
  "half;": 189,
  "harr;": 8596,
  "hbar;": 8463,
  "hopf;": 120153,
  "hscr;": 119997,
  icirc: 238,
  "iecy;": 1077,
  iexcl: 161,
  "imof;": 8887,
  "iocy;": 1105,
  "iopf;": 120154,
  "iota;": 953,
  "iscr;": 119998,
  "isin;": 8712,
  "iuml;": 239,
  "jopf;": 120155,
  "jscr;": 119999,
  "khcy;": 1093,
  "kjcy;": 1116,
  "kopf;": 120156,
  "kscr;": 12e4,
  "lArr;": 8656,
  "lHar;": 10594,
  "lang;": 10216,
  laquo: 171,
  "larr;": 8592,
  "late;": 10925,
  "lcub;": 123,
  "ldca;": 10550,
  "ldsh;": 8626,
  "leqq;": 8806,
  "lesg;": 8922,
  "ljcy;": 1113,
  "lnap;": 10889,
  "lneq;": 10887,
  "lopf;": 120157,
  "lozf;": 10731,
  "lpar;": 40,
  "lscr;": 120001,
  "lsim;": 8818,
  "lsqb;": 91,
  "ltcc;": 10918,
  "ltri;": 9667,
  "lvnE;": 8808,
  "macr;": 175,
  "male;": 9794,
  "malt;": 10016,
  micro: 181,
  "mlcp;": 10971,
  "mldr;": 8230,
  "mopf;": 120158,
  "mscr;": 120002,
  "nGtv;": 8811,
  "nLtv;": 8810,
  "nang;": 8736,
  "napE;": 10864,
  "nbsp;": 160,
  "ncap;": 10819,
  "ncup;": 10818,
  "ngeq;": 8817,
  "nges;": 10878,
  "ngtr;": 8815,
  "nisd;": 8954,
  "njcy;": 1114,
  "nldr;": 8229,
  "nleq;": 8816,
  "nles;": 10877,
  "nmid;": 8740,
  "nopf;": 120159,
  "npar;": 8742,
  "npre;": 10927,
  "nsce;": 10928,
  "nscr;": 120003,
  "nsim;": 8769,
  "nsub;": 8836,
  "nsup;": 8837,
  "ntgl;": 8825,
  "ntlg;": 8824,
  "nvap;": 8781,
  "nvge;": 8805,
  "nvgt;": 62,
  "nvle;": 8804,
  "nvlt;": 60,
  "oast;": 8859,
  "ocir;": 8858,
  ocirc: 244,
  "odiv;": 10808,
  "odot;": 8857,
  "ogon;": 731,
  "oint;": 8750,
  "omid;": 10678,
  "oopf;": 120160,
  "opar;": 10679,
  "ordf;": 170,
  "ordm;": 186,
  "oror;": 10838,
  "oscr;": 8500,
  "osol;": 8856,
  "ouml;": 246,
  "para;": 182,
  "part;": 8706,
  "perp;": 8869,
  "phiv;": 981,
  "plus;": 43,
  "popf;": 120161,
  pound: 163,
  "prap;": 10935,
  "prec;": 8826,
  "prnE;": 10933,
  "prod;": 8719,
  "prop;": 8733,
  "pscr;": 120005,
  "qint;": 10764,
  "qopf;": 120162,
  "qscr;": 120006,
  "quot;": 34,
  "rArr;": 8658,
  "rHar;": 10596,
  "race;": 8765,
  "rang;": 10217,
  raquo: 187,
  "rarr;": 8594,
  "rcub;": 125,
  "rdca;": 10551,
  "rdsh;": 8627,
  "real;": 8476,
  "rect;": 9645,
  "rhov;": 1009,
  "ring;": 730,
  "ropf;": 120163,
  "rpar;": 41,
  "rscr;": 120007,
  "rsqb;": 93,
  "rtri;": 9657,
  "scap;": 10936,
  "scnE;": 10934,
  "sdot;": 8901,
  "sect;": 167,
  "semi;": 59,
  "sext;": 10038,
  "shcy;": 1096,
  "sime;": 8771,
  "simg;": 10910,
  "siml;": 10909,
  "smid;": 8739,
  "smte;": 10924,
  "solb;": 10692,
  "sopf;": 120164,
  "spar;": 8741,
  "squf;": 9642,
  "sscr;": 120008,
  "star;": 9734,
  "subE;": 10949,
  "sube;": 8838,
  "succ;": 8827,
  "sung;": 9834,
  "sup1;": 185,
  "sup2;": 178,
  "sup3;": 179,
  "supE;": 10950,
  "supe;": 8839,
  szlig: 223,
  "tbrk;": 9140,
  "tdot;": 8411,
  thorn: 254,
  times: 215,
  "tint;": 8749,
  "toea;": 10536,
  "topf;": 120165,
  "tosa;": 10537,
  "trie;": 8796,
  "tscr;": 120009,
  "tscy;": 1094,
  "uArr;": 8657,
  "uHar;": 10595,
  "uarr;": 8593,
  ucirc: 251,
  "uopf;": 120166,
  "upsi;": 965,
  "uscr;": 120010,
  "utri;": 9653,
  "uuml;": 252,
  "vArr;": 8661,
  "vBar;": 10984,
  "varr;": 8597,
  "vert;": 124,
  "vopf;": 120167,
  "vscr;": 120011,
  "wopf;": 120168,
  "wscr;": 120012,
  "xcap;": 8898,
  "xcup;": 8899,
  "xmap;": 10236,
  "xnis;": 8955,
  "xopf;": 120169,
  "xscr;": 120013,
  "xvee;": 8897,
  "yacy;": 1103,
  "yicy;": 1111,
  "yopf;": 120170,
  "yscr;": 120014,
  "yucy;": 1102,
  "yuml;": 255,
  "zdot;": 380,
  "zeta;": 950,
  "zhcy;": 1078,
  "zopf;": 120171,
  "zscr;": 120015,
  "zwnj;": 8204,
  "AMP;": 38,
  "Acy;": 1040,
  "Afr;": 120068,
  "And;": 10835,
  Auml: 196,
  "Bcy;": 1041,
  "Bfr;": 120069,
  COPY: 169,
  "Cap;": 8914,
  "Cfr;": 8493,
  "Chi;": 935,
  "Cup;": 8915,
  "Dcy;": 1044,
  "Del;": 8711,
  "Dfr;": 120071,
  "Dot;": 168,
  "ENG;": 330,
  "ETH;": 208,
  "Ecy;": 1069,
  "Efr;": 120072,
  "Eta;": 919,
  Euml: 203,
  "Fcy;": 1060,
  "Ffr;": 120073,
  "Gcy;": 1043,
  "Gfr;": 120074,
  "Hat;": 94,
  "Hfr;": 8460,
  "Icy;": 1048,
  "Ifr;": 8465,
  "Int;": 8748,
  Iuml: 207,
  "Jcy;": 1049,
  "Jfr;": 120077,
  "Kcy;": 1050,
  "Kfr;": 120078,
  "Lcy;": 1051,
  "Lfr;": 120079,
  "Lsh;": 8624,
  "Map;": 10501,
  "Mcy;": 1052,
  "Mfr;": 120080,
  "Ncy;": 1053,
  "Nfr;": 120081,
  "Not;": 10988,
  "Ocy;": 1054,
  "Ofr;": 120082,
  Ouml: 214,
  "Pcy;": 1055,
  "Pfr;": 120083,
  "Phi;": 934,
  "Psi;": 936,
  QUOT: 34,
  "Qfr;": 120084,
  "REG;": 174,
  "Rcy;": 1056,
  "Rfr;": 8476,
  "Rho;": 929,
  "Rsh;": 8625,
  "Scy;": 1057,
  "Sfr;": 120086,
  "Sub;": 8912,
  "Sum;": 8721,
  "Sup;": 8913,
  "Tab;": 9,
  "Tau;": 932,
  "Tcy;": 1058,
  "Tfr;": 120087,
  "Ucy;": 1059,
  "Ufr;": 120088,
  Uuml: 220,
  "Vcy;": 1042,
  "Vee;": 8897,
  "Vfr;": 120089,
  "Wfr;": 120090,
  "Xfr;": 120091,
  "Ycy;": 1067,
  "Yfr;": 120092,
  "Zcy;": 1047,
  "Zfr;": 8488,
  "acE;": 8766,
  "acd;": 8767,
  "acy;": 1072,
  "afr;": 120094,
  "amp;": 38,
  "and;": 8743,
  "ang;": 8736,
  "apE;": 10864,
  "ape;": 8778,
  "ast;": 42,
  auml: 228,
  "bcy;": 1073,
  "bfr;": 120095,
  "bne;": 61,
  "bot;": 8869,
  "cap;": 8745,
  cent: 162,
  "cfr;": 120096,
  "chi;": 967,
  "cir;": 9675,
  copy: 169,
  "cup;": 8746,
  "dcy;": 1076,
  "deg;": 176,
  "dfr;": 120097,
  "die;": 168,
  "div;": 247,
  "dot;": 729,
  "ecy;": 1101,
  "efr;": 120098,
  "egs;": 10902,
  "ell;": 8467,
  "els;": 10901,
  "eng;": 331,
  "eta;": 951,
  "eth;": 240,
  euml: 235,
  "fcy;": 1092,
  "ffr;": 120099,
  "gEl;": 10892,
  "gap;": 10886,
  "gcy;": 1075,
  "gel;": 8923,
  "geq;": 8805,
  "ges;": 10878,
  "gfr;": 120100,
  "ggg;": 8921,
  "glE;": 10898,
  "gla;": 10917,
  "glj;": 10916,
  "gnE;": 8809,
  "gne;": 10888,
  "hfr;": 120101,
  "icy;": 1080,
  "iff;": 8660,
  "ifr;": 120102,
  "int;": 8747,
  iuml: 239,
  "jcy;": 1081,
  "jfr;": 120103,
  "kcy;": 1082,
  "kfr;": 120104,
  "lEg;": 10891,
  "lap;": 10885,
  "lat;": 10923,
  "lcy;": 1083,
  "leg;": 8922,
  "leq;": 8804,
  "les;": 10877,
  "lfr;": 120105,
  "lgE;": 10897,
  "lnE;": 8808,
  "lne;": 10887,
  "loz;": 9674,
  "lrm;": 8206,
  "lsh;": 8624,
  macr: 175,
  "map;": 8614,
  "mcy;": 1084,
  "mfr;": 120106,
  "mho;": 8487,
  "mid;": 8739,
  "nGg;": 8921,
  "nGt;": 8811,
  "nLl;": 8920,
  "nLt;": 8810,
  "nap;": 8777,
  nbsp: 160,
  "ncy;": 1085,
  "nfr;": 120107,
  "ngE;": 8807,
  "nge;": 8817,
  "ngt;": 8815,
  "nis;": 8956,
  "niv;": 8715,
  "nlE;": 8806,
  "nle;": 8816,
  "nlt;": 8814,
  "not;": 172,
  "npr;": 8832,
  "nsc;": 8833,
  "num;": 35,
  "ocy;": 1086,
  "ofr;": 120108,
  "ogt;": 10689,
  "ohm;": 937,
  "olt;": 10688,
  "ord;": 10845,
  ordf: 170,
  ordm: 186,
  "orv;": 10843,
  ouml: 246,
  "par;": 8741,
  para: 182,
  "pcy;": 1087,
  "pfr;": 120109,
  "phi;": 966,
  "piv;": 982,
  "prE;": 10931,
  "pre;": 10927,
  "psi;": 968,
  "qfr;": 120110,
  quot: 34,
  "rcy;": 1088,
  "reg;": 174,
  "rfr;": 120111,
  "rho;": 961,
  "rlm;": 8207,
  "rsh;": 8625,
  "scE;": 10932,
  "sce;": 10928,
  "scy;": 1089,
  sect: 167,
  "sfr;": 120112,
  "shy;": 173,
  "sim;": 8764,
  "smt;": 10922,
  "sol;": 47,
  "squ;": 9633,
  "sub;": 8834,
  "sum;": 8721,
  sup1: 185,
  sup2: 178,
  sup3: 179,
  "sup;": 8835,
  "tau;": 964,
  "tcy;": 1090,
  "tfr;": 120113,
  "top;": 8868,
  "ucy;": 1091,
  "ufr;": 120114,
  "uml;": 168,
  uuml: 252,
  "vcy;": 1074,
  "vee;": 8744,
  "vfr;": 120115,
  "wfr;": 120116,
  "xfr;": 120117,
  "ycy;": 1099,
  "yen;": 165,
  "yfr;": 120118,
  yuml: 255,
  "zcy;": 1079,
  "zfr;": 120119,
  "zwj;": 8205,
  AMP: 38,
  "DD;": 8517,
  ETH: 208,
  "GT;": 62,
  "Gg;": 8921,
  "Gt;": 8811,
  "Im;": 8465,
  "LT;": 60,
  "Ll;": 8920,
  "Lt;": 8810,
  "Mu;": 924,
  "Nu;": 925,
  "Or;": 10836,
  "Pi;": 928,
  "Pr;": 10939,
  REG: 174,
  "Re;": 8476,
  "Sc;": 10940,
  "Xi;": 926,
  "ac;": 8766,
  "af;": 8289,
  amp: 38,
  "ap;": 8776,
  "dd;": 8518,
  deg: 176,
  "ee;": 8519,
  "eg;": 10906,
  "el;": 10905,
  eth: 240,
  "gE;": 8807,
  "ge;": 8805,
  "gg;": 8811,
  "gl;": 8823,
  "gt;": 62,
  "ic;": 8291,
  "ii;": 8520,
  "in;": 8712,
  "it;": 8290,
  "lE;": 8806,
  "le;": 8804,
  "lg;": 8822,
  "ll;": 8810,
  "lt;": 60,
  "mp;": 8723,
  "mu;": 956,
  "ne;": 8800,
  "ni;": 8715,
  not: 172,
  "nu;": 957,
  "oS;": 9416,
  "or;": 8744,
  "pi;": 960,
  "pm;": 177,
  "pr;": 8826,
  reg: 174,
  "rx;": 8478,
  "sc;": 8827,
  shy: 173,
  uml: 168,
  "wp;": 8472,
  "wr;": 8768,
  "xi;": 958,
  yen: 165,
  GT: 62,
  LT: 60,
  gt: 62,
  lt: 60
};

// node_modules/svelte/src/compiler/parse/utils/html.js
var windows_1252 = [
  8364,
  129,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  710,
  8240,
  352,
  8249,
  338,
  141,
  381,
  143,
  144,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  732,
  8482,
  353,
  8250,
  339,
  157,
  382,
  376
];
function reg_exp_entity(entity_name, is_attribute_value) {
  if (is_attribute_value && !entity_name.endsWith(";")) {
    return `${entity_name}\\b(?!=)`;
  }
  return entity_name;
}
function get_entity_pattern(is_attribute_value) {
  const reg_exp_num = "#(?:x[a-fA-F\\d]+|\\d+)(?:;)?";
  const reg_exp_entities = Object.keys(entities_default).map(
    (entity_name) => reg_exp_entity(entity_name, is_attribute_value)
  );
  const entity_pattern = new RegExp(`&(${reg_exp_num}|${reg_exp_entities.join("|")})`, "g");
  return entity_pattern;
}
var entity_pattern_content = get_entity_pattern(false);
var entity_pattern_attr_value = get_entity_pattern(true);
function decode_character_references(html2, is_attribute_value) {
  const entity_pattern = is_attribute_value ? entity_pattern_attr_value : entity_pattern_content;
  return html2.replace(entity_pattern, (match, entity) => {
    let code;
    if (entity[0] !== "#") {
      code = entities_default[entity];
    } else if (entity[1] === "x") {
      code = parseInt(entity.substring(2), 16);
    } else {
      code = parseInt(entity.substring(1), 10);
    }
    if (!code) {
      return match;
    }
    return String.fromCodePoint(validate_code(code));
  });
}
var NUL = 0;
function validate_code(code) {
  if (code === 10) {
    return 32;
  }
  if (code < 128) {
    return code;
  }
  if (code <= 159) {
    return windows_1252[code - 128];
  }
  if (code < 55296) {
    return code;
  }
  if (code <= 57343) {
    return NUL;
  }
  if (code <= 65535) {
    return code;
  }
  if (code >= 65536 && code <= 131071) {
    return code;
  }
  if (code >= 131072 && code <= 196607) {
    return code;
  }
  return NUL;
}
var disallowed_contents = /* @__PURE__ */ new Map([
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["dt", /* @__PURE__ */ new Set(["dt", "dd"])],
  ["dd", /* @__PURE__ */ new Set(["dt", "dd"])],
  [
    "p",
    new Set(
      "address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(
        " "
      )
    )
  ],
  ["rt", /* @__PURE__ */ new Set(["rt", "rp"])],
  ["rp", /* @__PURE__ */ new Set(["rt", "rp"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup"])],
  ["option", /* @__PURE__ */ new Set(["option", "optgroup"])],
  ["thead", /* @__PURE__ */ new Set(["tbody", "tfoot"])],
  ["tbody", /* @__PURE__ */ new Set(["tbody", "tfoot"])],
  ["tfoot", /* @__PURE__ */ new Set(["tbody"])],
  ["tr", /* @__PURE__ */ new Set(["tr", "tbody"])],
  ["td", /* @__PURE__ */ new Set(["td", "th", "tr"])],
  ["th", /* @__PURE__ */ new Set(["td", "th", "tr"])]
]);
function closing_tag_omitted(current, next) {
  if (disallowed_contents.has(current)) {
    if (!next || disallowed_contents.get(current).has(next)) {
      return true;
    }
  }
  return false;
}

// node_modules/svelte/src/compiler/parse/state/tag.js
var valid_tag_name = /^\!?[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
var regex_starts_with_invalid_attr_value = /^(\/>|[\s"'=<>`])/;
var meta_tags = /* @__PURE__ */ new Map([
  ["svelte:head", "Head"],
  ["svelte:options", "Options"],
  ["svelte:window", "Window"],
  ["svelte:document", "Document"],
  ["svelte:body", "Body"]
]);
var valid_meta_tags = Array.from(meta_tags.keys()).concat(
  "svelte:self",
  "svelte:component",
  "svelte:fragment",
  "svelte:element"
);
var specials = /* @__PURE__ */ new Map([
  [
    "script",
    {
      read: read_script,
      property: "js"
    }
  ],
  [
    "style",
    {
      read: read_style,
      property: "css"
    }
  ]
]);
var SELF = /^svelte:self(?=[\s/>])/;
var COMPONENT = /^svelte:component(?=[\s/>])/;
var SLOT = /^svelte:fragment(?=[\s/>])/;
var ELEMENT = /^svelte:element(?=[\s/>])/;
function parent_is_head(stack) {
  let i = stack.length;
  while (i--) {
    const { type } = stack[i];
    if (type === "Head")
      return true;
    if (type === "Element" || type === "InlineComponent")
      return false;
  }
  return false;
}
var regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i;
var regex_closing_comment = /-->/;
var regex_capital_letter = /[A-Z]/;
function tag(parser) {
  const start = parser.index++;
  let parent = parser.current();
  if (parser.eat("!--")) {
    const data = parser.read_until(regex_closing_comment);
    parser.eat("-->", true, errors_default.unclosed_comment);
    parser.current().children.push({
      start,
      end: parser.index,
      type: "Comment",
      data,
      ignores: extract_svelte_ignore(data)
    });
    return;
  }
  const is_closing_tag = parser.eat("/");
  const name8 = read_tag_name(parser);
  if (meta_tags.has(name8)) {
    const slug = meta_tags.get(name8).toLowerCase();
    if (is_closing_tag) {
      if ((name8 === "svelte:window" || name8 === "svelte:body") && parser.current().children.length) {
        parser.error(
          errors_default.invalid_element_content(slug, name8),
          parser.current().children[0].start
        );
      }
    } else {
      if (name8 in parser.meta_tags) {
        parser.error(errors_default.duplicate_element(slug, name8), start);
      }
      if (parser.stack.length > 1) {
        parser.error(errors_default.invalid_element_placement(slug, name8), start);
      }
      parser.meta_tags[name8] = true;
    }
  }
  const type = meta_tags.has(name8) ? meta_tags.get(name8) : regex_capital_letter.test(name8[0]) || name8 === "svelte:self" || name8 === "svelte:component" ? "InlineComponent" : name8 === "svelte:fragment" ? "SlotTemplate" : name8 === "title" && parent_is_head(parser.stack) ? "Title" : name8 === "slot" ? "Slot" : "Element";
  const element = {
    start,
    end: null,
    type,
    name: name8,
    attributes: [],
    children: []
  };
  parser.allow_whitespace();
  if (is_closing_tag) {
    if (is_void(name8)) {
      parser.error(errors_default.invalid_void_content(name8), start);
    }
    parser.eat(">", true);
    while (parent.name !== name8) {
      if (parent.type !== "Element") {
        const error2 = parser.last_auto_closed_tag && parser.last_auto_closed_tag.tag === name8 ? errors_default.invalid_closing_tag_autoclosed(name8, parser.last_auto_closed_tag.reason) : errors_default.invalid_closing_tag_unopened(name8);
        parser.error(error2, start);
      }
      parent.end = start;
      parser.stack.pop();
      parent = parser.current();
    }
    parent.end = parser.index;
    parser.stack.pop();
    if (parser.last_auto_closed_tag && parser.stack.length < parser.last_auto_closed_tag.depth) {
      parser.last_auto_closed_tag = null;
    }
    return;
  } else if (closing_tag_omitted(parent.name, name8)) {
    parent.end = start;
    parser.stack.pop();
    parser.last_auto_closed_tag = {
      tag: parent.name,
      reason: name8,
      depth: parser.stack.length
    };
  }
  const unique_names = /* @__PURE__ */ new Set();
  const is_top_level_script_or_style = specials.has(name8) && parser.stack.length === 1;
  let attribute;
  while (attribute = read_attribute(parser, unique_names, is_top_level_script_or_style)) {
    element.attributes.push(attribute);
    parser.allow_whitespace();
  }
  if (name8 === "svelte:component") {
    const index = element.attributes.findIndex(
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index === -1) {
      parser.error(errors_default.missing_component_definition, start);
    }
    const definition = element.attributes.splice(index, 1)[0];
    if (definition.value === true || definition.value.length !== 1 || definition.value[0].type === "Text") {
      parser.error(errors_default.invalid_component_definition, definition.start);
    }
    element.expression = definition.value[0].expression;
  }
  if (name8 === "svelte:element") {
    const index = element.attributes.findIndex(
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index === -1) {
      parser.error(errors_default.missing_element_definition, start);
    }
    const definition = element.attributes.splice(index, 1)[0];
    if (definition.value === true) {
      parser.error(errors_default.invalid_element_definition, definition.start);
    }
    element.tag = definition.value[0].data || definition.value[0].expression;
  }
  if (is_top_level_script_or_style) {
    const special = specials.get(name8);
    parser.eat(">", true);
    const content = special.read(parser, start, element.attributes);
    if (content)
      parser[special.property].push(content);
    return;
  }
  parser.current().children.push(element);
  const self_closing = parser.eat("/") || is_void(name8);
  parser.eat(">", true);
  if (self_closing) {
    element.end = parser.index;
  } else if (name8 === "textarea") {
    element.children = read_sequence(
      parser,
      () => regex_closing_textarea_tag.test(parser.template.slice(parser.index)),
      "inside <textarea>"
    );
    parser.read(regex_closing_textarea_tag);
    element.end = parser.index;
  } else if (name8 === "script" || name8 === "style") {
    const start2 = parser.index;
    const data = parser.read_until(new RegExp(`</${name8}>`));
    const end = parser.index;
    element.children.push({ start: start2, end, type: "Text", data });
    parser.eat(`</${name8}>`, true);
    element.end = parser.index;
  } else {
    parser.stack.push(element);
  }
}
var regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/;
function read_tag_name(parser) {
  const start = parser.index;
  if (parser.read(SELF)) {
    let i = parser.stack.length;
    let legal = false;
    while (i--) {
      const fragment2 = parser.stack[i];
      if (fragment2.type === "IfBlock" || fragment2.type === "EachBlock" || fragment2.type === "InlineComponent") {
        legal = true;
        break;
      }
    }
    if (!legal) {
      parser.error(errors_default.invalid_self_placement, start);
    }
    return "svelte:self";
  }
  if (parser.read(COMPONENT))
    return "svelte:component";
  if (parser.read(ELEMENT))
    return "svelte:element";
  if (parser.read(SLOT))
    return "svelte:fragment";
  const name8 = parser.read_until(regex_whitespace_or_slash_or_closing_tag);
  if (meta_tags.has(name8))
    return name8;
  if (name8.startsWith("svelte:")) {
    const match = fuzzymatch(name8.slice(7), valid_meta_tags);
    parser.error(errors_default.invalid_tag_name_svelte_element(valid_meta_tags, match), start);
  }
  if (!valid_tag_name.test(name8)) {
    parser.error(errors_default.invalid_tag_name, start);
  }
  return name8;
}
var regex_token_ending_character = /[\s=\/>"']/;
var regex_starts_with_quote_characters = /^["']/;
function read_attribute(parser, unique_names, is_static) {
  const start = parser.index;
  function check_unique(name9) {
    if (unique_names.has(name9)) {
      parser.error(errors_default.duplicate_attribute, start);
    }
    unique_names.add(name9);
  }
  if (!is_static && parser.eat("{")) {
    parser.allow_whitespace();
    if (parser.eat("...")) {
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      return {
        start,
        end: parser.index,
        type: "Spread",
        expression
      };
    } else {
      const value_start = parser.index;
      const name9 = parser.read_identifier();
      parser.allow_whitespace();
      parser.eat("}", true);
      if (name9 === null) {
        parser.error(errors_default.empty_attribute_shorthand, start);
      }
      check_unique(name9);
      return {
        start,
        end: parser.index,
        type: "Attribute",
        name: name9,
        value: [
          {
            start: value_start,
            end: value_start + name9.length,
            type: "AttributeShorthand",
            expression: {
              start: value_start,
              end: value_start + name9.length,
              type: "Identifier",
              name: name9
            }
          }
        ]
      };
    }
  }
  const name8 = parser.read_until(regex_token_ending_character);
  if (!name8)
    return null;
  let end = parser.index;
  parser.allow_whitespace();
  const colon_index = name8.indexOf(":");
  const type = colon_index !== -1 && get_directive_type(name8.slice(0, colon_index));
  let value = true;
  if (parser.eat("=")) {
    parser.allow_whitespace();
    value = read_attribute_value(parser, is_static);
    end = parser.index;
  } else if (parser.match_regex(regex_starts_with_quote_characters)) {
    parser.error(errors_default.unexpected_token("="), parser.index);
  }
  if (!is_static && type) {
    const [directive_name, ...modifiers] = name8.slice(colon_index + 1).split("|");
    if (directive_name === "") {
      parser.error(errors_default.empty_directive_name(type), start + colon_index + 1);
    }
    if (type === "Binding" && directive_name !== "this") {
      check_unique(directive_name);
    } else if (type !== "EventHandler" && type !== "Action") {
      check_unique(name8);
    }
    if (type === "Ref") {
      parser.error(errors_default.invalid_ref_directive(directive_name), start);
    }
    if (type === "StyleDirective") {
      return {
        start,
        end,
        type,
        name: directive_name,
        modifiers,
        value
      };
    }
    const first_value = value[0];
    let expression = null;
    if (first_value) {
      const attribute_contains_text = (
        /** @type {any[]} */
        value.length > 1 || first_value.type === "Text"
      );
      if (attribute_contains_text) {
        parser.error(errors_default.invalid_directive_value, first_value.start);
      } else {
        expression = first_value.expression;
      }
    }
    const directive = {
      start,
      end,
      type,
      name: directive_name,
      modifiers,
      expression
    };
    if (type === "Transition") {
      const direction = name8.slice(0, colon_index);
      directive.intro = direction === "in" || direction === "transition";
      directive.outro = direction === "out" || direction === "transition";
    }
    if (!directive.expression && (type === "Binding" || type === "Class")) {
      directive.expression = {
        start: directive.start + colon_index + 1,
        end: directive.end,
        type: "Identifier",
        name: directive.name
      };
    }
    return directive;
  }
  check_unique(name8);
  return {
    start,
    end,
    type: "Attribute",
    name: name8,
    value
  };
}
function get_directive_type(name8) {
  if (name8 === "use")
    return "Action";
  if (name8 === "animate")
    return "Animation";
  if (name8 === "bind")
    return "Binding";
  if (name8 === "class")
    return "Class";
  if (name8 === "style")
    return "StyleDirective";
  if (name8 === "on")
    return "EventHandler";
  if (name8 === "let")
    return "Let";
  if (name8 === "in" || name8 === "out" || name8 === "transition")
    return "Transition";
}
var regex_attribute_value = /^(?:"([^"]*)"|'([^'])*'|([^>\s]+))/;
function read_attribute_value(parser, is_static) {
  if (is_static) {
    let value2 = parser.match_regex(regex_attribute_value);
    if (!value2) {
      parser.error(errors_default.missing_attribute_value);
    }
    parser.index += value2.length;
    const quoted = value2[0] === '"' || value2[0] === "'";
    if (quoted) {
      value2 = value2.slice(1, -1);
    }
    return [
      {
        start: parser.index - value2.length - (quoted ? 1 : 0),
        end: quoted ? parser.index - 1 : parser.index,
        type: "Text",
        raw: value2,
        data: decode_character_references(value2, true)
      }
    ];
  }
  const quote_mark = parser.eat("'") ? "'" : parser.eat('"') ? '"' : null;
  if (quote_mark && parser.eat(quote_mark)) {
    return [
      {
        start: parser.index - 1,
        end: parser.index - 1,
        type: "Text",
        raw: "",
        data: ""
      }
    ];
  }
  let value;
  try {
    value = read_sequence(
      parser,
      () => {
        if (quote_mark)
          return parser.match(quote_mark);
        return !!parser.match_regex(regex_starts_with_invalid_attr_value);
      },
      "in attribute value"
    );
  } catch (error2) {
    if (error2.code === "parse-error") {
      if (parser.template.slice(error2.pos - 1, error2.pos + 1) === "/>") {
        parser.index = error2.pos;
        parser.error(errors_default.unclosed_attribute_value(quote_mark || "}"));
      }
    }
    throw error2;
  }
  if (value.length === 0 && !quote_mark) {
    parser.error(errors_default.missing_attribute_value);
  }
  if (quote_mark)
    parser.index += 1;
  return value;
}
function read_sequence(parser, done, location) {
  let current_chunk = {
    start: parser.index,
    end: null,
    type: "Text",
    raw: "",
    data: null
  };
  const chunks = [];
  function flush(end) {
    if (current_chunk.raw) {
      current_chunk.data = decode_character_references(current_chunk.raw, true);
      current_chunk.end = end;
      chunks.push(current_chunk);
    }
  }
  while (parser.index < parser.template.length) {
    const index = parser.index;
    if (done()) {
      flush(parser.index);
      return chunks;
    } else if (parser.eat("{")) {
      if (parser.match("#")) {
        const index2 = parser.index - 1;
        parser.eat("#");
        const name8 = parser.read_until(/[^a-z]/);
        parser.error(errors_default.invalid_logic_block_placement(location, name8), index2);
      } else if (parser.match("@")) {
        const index2 = parser.index - 1;
        parser.eat("@");
        const name8 = parser.read_until(/[^a-z]/);
        parser.error(errors_default.invalid_tag_placement(location, name8), index2);
      }
      flush(parser.index - 1);
      parser.allow_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      chunks.push({
        start: index,
        end: parser.index,
        type: "MustacheTag",
        expression
      });
      current_chunk = {
        start: parser.index,
        end: null,
        type: "Text",
        raw: "",
        data: null
      };
    } else {
      current_chunk.raw += parser.template[parser.index++];
    }
  }
  parser.error(errors_default.unexpected_eof);
}

// node_modules/svelte/src/compiler/utils/full_char_code_at.js
function full_char_code_at(str, i) {
  const code = str.charCodeAt(i);
  if (code <= 55295 || code >= 57344)
    return code;
  const next = str.charCodeAt(i + 1);
  return (code << 10) + next - 56613888;
}

// node_modules/svelte/src/compiler/parse/utils/bracket.js
var SQUARE_BRACKET_OPEN = "[".charCodeAt(0);
var SQUARE_BRACKET_CLOSE = "]".charCodeAt(0);
var CURLY_BRACKET_OPEN = "{".charCodeAt(0);
var CURLY_BRACKET_CLOSE = "}".charCodeAt(0);
function is_bracket_open(code) {
  return code === SQUARE_BRACKET_OPEN || code === CURLY_BRACKET_OPEN;
}
function is_bracket_close(code) {
  return code === SQUARE_BRACKET_CLOSE || code === CURLY_BRACKET_CLOSE;
}
function is_bracket_pair(open, close) {
  return open === SQUARE_BRACKET_OPEN && close === SQUARE_BRACKET_CLOSE || open === CURLY_BRACKET_OPEN && close === CURLY_BRACKET_CLOSE;
}
function get_bracket_close(open) {
  if (open === SQUARE_BRACKET_OPEN) {
    return SQUARE_BRACKET_CLOSE;
  }
  if (open === CURLY_BRACKET_OPEN) {
    return CURLY_BRACKET_CLOSE;
  }
}

// node_modules/svelte/src/compiler/parse/read/context.js
function read_context(parser) {
  const start = parser.index;
  let i = parser.index;
  const code = full_char_code_at(parser.template, i);
  if (isIdentifierStart(code, true)) {
    return {
      type: "Identifier",
      name: parser.read_identifier(),
      start,
      end: parser.index
    };
  }
  if (!is_bracket_open(code)) {
    parser.error(errors_default.unexpected_token_destructure);
  }
  const bracket_stack = [code];
  i += code <= 65535 ? 1 : 2;
  while (i < parser.template.length) {
    const code2 = full_char_code_at(parser.template, i);
    if (is_bracket_open(code2)) {
      bracket_stack.push(code2);
    } else if (is_bracket_close(code2)) {
      if (!is_bracket_pair(bracket_stack[bracket_stack.length - 1], code2)) {
        parser.error(
          errors_default.unexpected_token(
            String.fromCharCode(get_bracket_close(bracket_stack[bracket_stack.length - 1]))
          )
        );
      }
      bracket_stack.pop();
      if (bracket_stack.length === 0) {
        i += code2 <= 65535 ? 1 : 2;
        break;
      }
    }
    i += code2 <= 65535 ? 1 : 2;
  }
  parser.index = i;
  const pattern_string = parser.template.slice(start, i);
  try {
    let space_with_newline = parser.template.slice(0, start).replace(regex_not_newline_characters, " ");
    const first_space = space_with_newline.indexOf(" ");
    space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);
    return parse_expression_at(`${space_with_newline}(${pattern_string} = 1)`, start - 1).left;
  } catch (error2) {
    parser.acorn_error(error2);
  }
}

// node_modules/svelte/src/compiler/utils/trim.js
function trim_start(str) {
  return str.replace(regex_starts_with_whitespaces, "");
}
function trim_end(str) {
  return str.replace(regex_ends_with_whitespaces, "");
}

// node_modules/svelte/src/compiler/parse/utils/node.js
function to_string(node) {
  switch (node.type) {
    case "IfBlock":
      return "{#if} block";
    case "ThenBlock":
      return "{:then} block";
    case "ElseBlock":
      return "{:else} block";
    case "PendingBlock":
    case "AwaitBlock":
      return "{#await} block";
    case "CatchBlock":
      return "{:catch} block";
    case "EachBlock":
      return "{#each} block";
    case "RawMustacheTag":
      return "{@html} block";
    case "DebugTag":
      return "{@debug} block";
    case "ConstTag":
      return "{@const} tag";
    case "Element":
    case "InlineComponent":
    case "Slot":
    case "Title":
      return `<${node.name}> tag`;
    default:
      return node.type;
  }
}

// node_modules/svelte/src/compiler/parse/state/mustache.js
function trim_whitespace(block, trim_before, trim_after) {
  if (!block.children || block.children.length === 0)
    return;
  const first_child = block.children[0];
  const last_child = block.children[block.children.length - 1];
  if (first_child.type === "Text" && trim_before) {
    first_child.data = trim_start(first_child.data);
    if (!first_child.data)
      block.children.shift();
  }
  if (last_child.type === "Text" && trim_after) {
    last_child.data = trim_end(last_child.data);
    if (!last_child.data)
      block.children.pop();
  }
  if (block.else) {
    trim_whitespace(block.else, trim_before, trim_after);
  }
  if (first_child.elseif) {
    trim_whitespace(first_child, trim_before, trim_after);
  }
}
var regex_whitespace_with_closing_curly_brace = /^\s*}/;
function mustache(parser) {
  const start = parser.index;
  parser.index += 1;
  parser.allow_whitespace();
  if (parser.eat("/")) {
    let block = parser.current();
    let expected;
    if (closing_tag_omitted(block.name)) {
      block.end = start;
      parser.stack.pop();
      block = parser.current();
    }
    if (block.type === "ElseBlock" || block.type === "PendingBlock" || block.type === "ThenBlock" || block.type === "CatchBlock") {
      block.end = start;
      parser.stack.pop();
      block = parser.current();
      expected = "await";
    }
    if (block.type === "IfBlock") {
      expected = "if";
    } else if (block.type === "EachBlock") {
      expected = "each";
    } else if (block.type === "AwaitBlock") {
      expected = "await";
    } else if (block.type === "KeyBlock") {
      expected = "key";
    } else {
      parser.error(errors_default.unexpected_block_close);
    }
    parser.eat(expected, true);
    parser.allow_whitespace();
    parser.eat("}", true);
    while (block.elseif) {
      block.end = parser.index;
      parser.stack.pop();
      block = parser.current();
      if (block.else) {
        block.else.end = start;
      }
    }
    const char_before = parser.template[block.start - 1];
    const char_after = parser.template[parser.index];
    const trim_before = !char_before || regex_whitespace.test(char_before);
    const trim_after = !char_after || regex_whitespace.test(char_after);
    trim_whitespace(block, trim_before, trim_after);
    block.end = parser.index;
    parser.stack.pop();
  } else if (parser.eat(":else")) {
    if (parser.eat("if")) {
      parser.error(errors_default.invalid_elseif);
    }
    parser.allow_whitespace();
    if (parser.eat("if")) {
      const block = parser.current();
      if (block.type !== "IfBlock") {
        parser.error(
          parser.stack.some((block2) => block2.type === "IfBlock") ? errors_default.invalid_elseif_placement_unclosed_block(to_string(block)) : errors_default.invalid_elseif_placement_outside_if
        );
      }
      parser.require_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      block.else = {
        start: parser.index,
        end: null,
        type: "ElseBlock",
        children: [
          {
            start: parser.index,
            end: null,
            type: "IfBlock",
            elseif: true,
            expression,
            children: []
          }
        ]
      };
      parser.stack.push(block.else.children[0]);
    } else {
      const block = parser.current();
      if (block.type !== "IfBlock" && block.type !== "EachBlock") {
        parser.error(
          parser.stack.some((block2) => block2.type === "IfBlock" || block2.type === "EachBlock") ? errors_default.invalid_else_placement_unclosed_block(to_string(block)) : errors_default.invalid_else_placement_outside_if
        );
      }
      parser.allow_whitespace();
      parser.eat("}", true);
      block.else = {
        start: parser.index,
        end: null,
        type: "ElseBlock",
        children: []
      };
      parser.stack.push(block.else);
    }
  } else if (parser.match(":then") || parser.match(":catch")) {
    const block = parser.current();
    const is_then = parser.eat(":then") || !parser.eat(":catch");
    if (is_then) {
      if (block.type !== "PendingBlock") {
        parser.error(
          parser.stack.some((block2) => block2.type === "PendingBlock") ? errors_default.invalid_then_placement_unclosed_block(to_string(block)) : errors_default.invalid_then_placement_without_await
        );
      }
    } else {
      if (block.type !== "ThenBlock" && block.type !== "PendingBlock") {
        parser.error(
          parser.stack.some((block2) => block2.type === "ThenBlock" || block2.type === "PendingBlock") ? errors_default.invalid_catch_placement_unclosed_block(to_string(block)) : errors_default.invalid_catch_placement_without_await
        );
      }
    }
    block.end = start;
    parser.stack.pop();
    const await_block = parser.current();
    if (!parser.eat("}")) {
      parser.require_whitespace();
      await_block[is_then ? "value" : "error"] = read_context(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    const new_block = {
      start,
      end: null,
      type: is_then ? "ThenBlock" : "CatchBlock",
      children: [],
      skip: false
    };
    await_block[is_then ? "then" : "catch"] = new_block;
    parser.stack.push(new_block);
  } else if (parser.eat("#")) {
    let type;
    if (parser.eat("if")) {
      type = "IfBlock";
    } else if (parser.eat("each")) {
      type = "EachBlock";
    } else if (parser.eat("await")) {
      type = "AwaitBlock";
    } else if (parser.eat("key")) {
      type = "KeyBlock";
    } else {
      parser.error(errors_default.expected_block_type);
    }
    parser.require_whitespace();
    const expression = read_expression(parser);
    const block = type === "AwaitBlock" ? {
      start,
      end: null,
      type,
      expression,
      value: null,
      error: null,
      pending: {
        start: null,
        end: null,
        type: "PendingBlock",
        children: [],
        skip: true
      },
      then: {
        start: null,
        end: null,
        type: "ThenBlock",
        children: [],
        skip: true
      },
      catch: {
        start: null,
        end: null,
        type: "CatchBlock",
        children: [],
        skip: true
      }
    } : {
      start,
      end: null,
      type,
      expression,
      children: []
    };
    parser.allow_whitespace();
    if (type === "EachBlock") {
      parser.eat("as", true);
      parser.require_whitespace();
      block.context = read_context(parser);
      parser.allow_whitespace();
      if (parser.eat(",")) {
        parser.allow_whitespace();
        block.index = parser.read_identifier();
        if (!block.index)
          parser.error(errors_default.expected_name);
        parser.allow_whitespace();
      }
      if (parser.eat("(")) {
        parser.allow_whitespace();
        block.key = read_expression(parser);
        parser.allow_whitespace();
        parser.eat(")", true);
        parser.allow_whitespace();
      }
    }
    const await_block_shorthand = type === "AwaitBlock" && parser.eat("then");
    if (await_block_shorthand) {
      if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser.allow_whitespace();
      } else {
        parser.require_whitespace();
        block.value = read_context(parser);
        parser.allow_whitespace();
      }
    }
    const await_block_catch_shorthand = !await_block_shorthand && type === "AwaitBlock" && parser.eat("catch");
    if (await_block_catch_shorthand) {
      if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser.allow_whitespace();
      } else {
        parser.require_whitespace();
        block.error = read_context(parser);
        parser.allow_whitespace();
      }
    }
    parser.eat("}", true);
    parser.current().children.push(block);
    parser.stack.push(block);
    if (type === "AwaitBlock") {
      let child_block;
      if (await_block_shorthand) {
        block.then.skip = false;
        child_block = block.then;
      } else if (await_block_catch_shorthand) {
        block.catch.skip = false;
        child_block = block.catch;
      } else {
        block.pending.skip = false;
        child_block = block.pending;
      }
      child_block.start = parser.index;
      parser.stack.push(child_block);
    }
  } else if (parser.eat("@html")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.current().children.push({
      start,
      end: parser.index,
      type: "RawMustacheTag",
      expression
    });
  } else if (parser.eat("@debug")) {
    let identifiers;
    if (parser.read(regex_whitespace_with_closing_curly_brace)) {
      identifiers = [];
    } else {
      const expression = read_expression(parser);
      identifiers = expression.type === "SequenceExpression" ? expression.expressions : [expression];
      identifiers.forEach((node) => {
        if (node.type !== "Identifier") {
          parser.error(errors_default.invalid_debug_args, node.start);
        }
      });
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    parser.current().children.push({
      start,
      end: parser.index,
      type: "DebugTag",
      identifiers
    });
  } else if (parser.eat("@const")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    if (!(expression.type === "AssignmentExpression" && expression.operator === "=")) {
      parser.error(
        {
          code: "invalid-const-args",
          message: "{@const ...} must be an assignment."
        },
        start
      );
    }
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.current().children.push({
      start,
      end: parser.index,
      type: "ConstTag",
      expression
    });
  } else {
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.current().children.push({
      start,
      end: parser.index,
      type: "MustacheTag",
      expression
    });
  }
}

// node_modules/svelte/src/compiler/parse/state/text.js
function text(parser) {
  const start = parser.index;
  let data = "";
  while (parser.index < parser.template.length && !parser.match("<") && !parser.match("{")) {
    data += parser.template[parser.index++];
  }
  const node = {
    start,
    end: parser.index,
    type: "Text",
    raw: data,
    data: decode_character_references(data, false)
  };
  parser.current().children.push(node);
}

// node_modules/svelte/src/compiler/parse/state/fragment.js
function fragment(parser) {
  if (parser.match("<")) {
    return tag;
  }
  if (parser.match("{")) {
    return mustache;
  }
  return text;
}

// node_modules/svelte/src/compiler/utils/names.js
var reserved = /* @__PURE__ */ new Set([
  "arguments",
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "eval",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "implements",
  "import",
  "in",
  "instanceof",
  "interface",
  "let",
  "new",
  "null",
  "package",
  "private",
  "protected",
  "public",
  "return",
  "static",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield"
]);
function is_valid(str) {
  let i = 0;
  while (i < str.length) {
    const code = full_char_code_at(str, i);
    if (!(i === 0 ? isIdentifierStart : isIdentifierChar)(code, true))
      return false;
    i += code <= 65535 ? 1 : 2;
  }
  return true;
}
var regex_non_standard_characters = /[^a-zA-Z0-9_]+/g;
var regex_starts_with_number = /^[0-9]/;
function sanitize(name8) {
  return name8.replace(regex_non_standard_characters, "_").replace(regex_starts_with_underscore, "").replace(regex_ends_with_underscore, "").replace(regex_starts_with_number, "_$&");
}

// node_modules/svelte/src/compiler/utils/get_code_frame.js
var regex_tabs = /^\t+/;
function tabs_to_spaces(str) {
  return str.replace(regex_tabs, (match) => match.split("	").join("  "));
}
function get_code_frame(source, line, column) {
  const lines = source.split("\n");
  const frame_start = Math.max(0, line - 2);
  const frame_end = Math.min(line + 3, lines.length);
  const digits = String(frame_end + 1).length;
  return lines.slice(frame_start, frame_end).map((str, i) => {
    const is_error_line = frame_start + i === line;
    const line_num = String(i + frame_start + 1).padStart(digits, " ");
    if (is_error_line) {
      const indicator = " ".repeat(digits + 2 + tabs_to_spaces(str.slice(0, column)).length) + "^";
      return `${line_num}: ${tabs_to_spaces(str)}
${indicator}`;
    }
    return `${line_num}: ${tabs_to_spaces(str)}`;
  }).join("\n");
}

// node_modules/svelte/src/compiler/utils/error.js
var CompileError = class extends Error {
  constructor() {
    super(...arguments);
    /**
     * @type {string}
     */
    __publicField(this, "code");
    /**
     * @type {{ line: number; column: number }}
     */
    __publicField(this, "start");
    /**
     * @type {{ line: number; column: number }}
     */
    __publicField(this, "end");
    /**
     * @type {number}
     */
    __publicField(this, "pos");
    /**
     * @type {string}
     */
    __publicField(this, "filename");
    /**
     * @type {string}
     */
    __publicField(this, "frame");
  }
  toString() {
    return `${this.message} (${this.start.line}:${this.start.column})
${this.frame}`;
  }
};
function error(message, props) {
  const error2 = new CompileError(message);
  error2.name = props.name;
  const start = locate(props.source, props.start, { offsetLine: 1 });
  const end = locate(props.source, props.end || props.start, { offsetLine: 1 });
  error2.code = props.code;
  error2.start = start;
  error2.end = end;
  error2.pos = props.start;
  error2.filename = props.filename;
  error2.frame = get_code_frame(props.source, start.line - 1, start.column);
  throw error2;
}

// node_modules/svelte/src/compiler/parse/index.js
var regex_position_indicator = / \(\d+:\d+\)$/;
var Parser = class {
  /**
   * @param {string} template
   * @param {import('../interfaces.js').ParserOptions} options
   */
  constructor(template, options) {
    /**
     * @readonly
     * @type {string}
     */
    __publicField(this, "template");
    /**
     * @readonly
     * @type {string}
     */
    __publicField(this, "filename");
    /**
     * @readonly
     * @type {boolean}
     */
    __publicField(this, "customElement");
    /**
     * @readonly
     * @type {'injected' | 'external' | 'none' | boolean}
     */
    __publicField(this, "css_mode");
    __publicField(this, "index", 0);
    /**
     * @type {import('../interfaces.js').TemplateNode[]}
     */
    __publicField(this, "stack", []);
    /**
     * @type {import('../interfaces.js').Fragment}
     */
    __publicField(this, "html");
    /**
     * @type {import('../interfaces.js').Style[]}
     */
    __publicField(this, "css", []);
    /**
     * @type {import('../interfaces.js').Script[]}
     */
    __publicField(this, "js", []);
    __publicField(this, "meta_tags", {});
    /**
     * @type {{tag: string; reason: string; depth: number;}}
     */
    __publicField(this, "last_auto_closed_tag");
    if (typeof template !== "string") {
      throw new TypeError("Template must be a string");
    }
    this.template = template.trimRight();
    this.filename = options.filename;
    this.customElement = options.customElement;
    this.css_mode = options.css;
    this.html = {
      start: null,
      end: null,
      type: "Fragment",
      children: []
    };
    this.stack.push(this.html);
    let state = fragment;
    while (this.index < this.template.length) {
      state = state(this) || fragment;
    }
    if (this.stack.length > 1) {
      const current = this.current();
      const type = current.type === "Element" ? `<${current.name}>` : "Block";
      const slug = current.type === "Element" ? "element" : "block";
      this.error(
        {
          code: `unclosed-${slug}`,
          message: `${type} was left open`
        },
        current.start
      );
    }
    if (state !== fragment) {
      this.error({
        code: "unexpected-eof",
        message: "Unexpected end of input"
      });
    }
    if (this.html.children.length) {
      let start = this.html.children[0].start;
      while (regex_whitespace.test(template[start]))
        start += 1;
      let end = this.html.children[this.html.children.length - 1].end;
      while (regex_whitespace.test(template[end - 1]))
        end -= 1;
      this.html.start = start;
      this.html.end = end;
    } else {
      this.html.start = this.html.end = null;
    }
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  /**
   * @param {any} err
   */
  acorn_error(err) {
    this.error(
      {
        code: "parse-error",
        message: err.message.replace(regex_position_indicator, "")
      },
      err.pos
    );
  }
  /**
   * @param {{ code: string; message: string }} err
   */
  error({ code, message }, index = this.index) {
    error(message, {
      name: "ParseError",
      code,
      source: this.template,
      start: index,
      filename: this.filename
    });
  }
  /**
   * @param {string} str
   * @param {boolean} [required]
   * @param {{ code: string; message: string }} [error]
   */
  eat(str, required, error2) {
    if (this.match(str)) {
      this.index += str.length;
      return true;
    }
    if (required) {
      this.error(
        error2 || (this.index === this.template.length ? errors_default.unexpected_eof_token(str) : errors_default.unexpected_token(str))
      );
    }
    return false;
  }
  /**
   * @param {string} str
   */
  match(str) {
    return this.template.slice(this.index, this.index + str.length) === str;
  }
  /**
   * Match a regex at the current index
   * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  match_regex(pattern) {
    const match = pattern.exec(this.template.slice(this.index));
    if (!match || match.index !== 0)
      return null;
    return match[0];
  }
  allow_whitespace() {
    while (this.index < this.template.length && regex_whitespace.test(this.template[this.index])) {
      this.index++;
    }
  }
  /**
   * Search for a regex starting at the current index and return the result if it matches
   * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  read(pattern) {
    const result = this.match_regex(pattern);
    if (result)
      this.index += result.length;
    return result;
  }
  read_identifier(allow_reserved = false) {
    const start = this.index;
    let i = this.index;
    const code = full_char_code_at(this.template, i);
    if (!isIdentifierStart(code, true))
      return null;
    i += code <= 65535 ? 1 : 2;
    while (i < this.template.length) {
      const code2 = full_char_code_at(this.template, i);
      if (!isIdentifierChar(code2, true))
        break;
      i += code2 <= 65535 ? 1 : 2;
    }
    const identifier = this.template.slice(this.index, this.index = i);
    if (!allow_reserved && reserved.has(identifier)) {
      this.error(
        {
          code: "unexpected-reserved-word",
          message: `'${identifier}' is a reserved word in JavaScript and cannot be used here`
        },
        start
      );
    }
    return identifier;
  }
  /**
   * @param {RegExp} pattern
   * @param {Parameters<Parser['error']>[0]} [error_message]
   */
  read_until(pattern, error_message) {
    if (this.index >= this.template.length) {
      this.error(
        error_message || {
          code: "unexpected-eof",
          message: "Unexpected end of input"
        }
      );
    }
    const start = this.index;
    const match = pattern.exec(this.template.slice(start));
    if (match) {
      this.index = start + match.index;
      return this.template.slice(start, this.index);
    }
    this.index = this.template.length;
    return this.template.slice(start);
  }
  require_whitespace() {
    if (!regex_whitespace.test(this.template[this.index])) {
      this.error({
        code: "missing-whitespace",
        message: "Expected whitespace"
      });
    }
    this.allow_whitespace();
  }
};
function parse11(template, options = {}) {
  const parser = new Parser(template, options);
  if (parser.css.length > 1) {
    parser.error(errors_default.duplicate_style, parser.css[1].start);
  }
  const instance_scripts = parser.js.filter((script) => script.context === "default");
  const module_scripts = parser.js.filter((script) => script.context === "module");
  if (instance_scripts.length > 1) {
    parser.error(errors_default.invalid_script_instance, instance_scripts[1].start);
  }
  if (module_scripts.length > 1) {
    parser.error(errors_default.invalid_script_module, module_scripts[1].start);
  }
  return {
    html: parser.html,
    css: parser.css[0],
    instance: instance_scripts[0],
    module: module_scripts[0]
  };
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/is_head.js
function is_head(node) {
  return node && node.type === "MemberExpression" && node.object["name"] === "@_document" && node.property["name"] === "head";
}

// node_modules/svelte/src/compiler/compile/render_dom/Block.js
var Block = class _Block {
  /** @param {BlockOptions} options */
  constructor(options) {
    /**
     * @typedef {Object} Bindings
     * @property {import('estree').Identifier} object
     * @property {import('estree').Identifier} property
     * @property {import('estree').Node} snippet
     * @property {string} store
     * @property {(node:import('estree').Node) => import('estree').Node} modifier
     */
    /**
     * @typedef {Object} BlockOptions
     * @property {Block} [parent]
     * @property {import('estree').Identifier} name
     * @property {string} type
     * @property {import('./Renderer.js').default} [renderer]
     * @property {string} [comment]
     * @property {import('estree').Identifier} [key]
     * @property {Map<string,Bindings>} [bindings]
     * @property {Set<string>} [dependencies]
     */
    /** @type {Block} */
    __publicField(this, "parent");
    /** @type {import('./Renderer.js').default} */
    __publicField(this, "renderer");
    /** @type {import('estree').Identifier} */
    __publicField(this, "name");
    /** @type {string} */
    __publicField(this, "type");
    /** @type {string} */
    __publicField(this, "comment");
    /** @type {import('./wrappers/shared/Wrapper.js').default[]} */
    __publicField(this, "wrappers");
    /** @type {import('estree').Identifier} */
    __publicField(this, "key");
    /** @type {import('estree').Identifier} */
    __publicField(this, "first");
    /** @type {Set<string>} */
    __publicField(this, "dependencies", /* @__PURE__ */ new Set());
    /** @type {Map<string, Bindings>} */
    __publicField(this, "bindings");
    /** @type {Set<string>} */
    __publicField(this, "binding_group_initialised", /* @__PURE__ */ new Set());
    /** @type {Set<import('./Renderer.js').BindingGroup>} */
    __publicField(this, "binding_groups", /* @__PURE__ */ new Set());
    /**
     * @type {{
     * 		declarations: Array<import('estree').Node | import('estree').Node[]>;
     * 		init: Array<import('estree').Node | import('estree').Node[]>;
     * 		create: Array<import('estree').Node | import('estree').Node[]>;
     * 		claim: Array<import('estree').Node | import('estree').Node[]>;
     * 		hydrate: Array<import('estree').Node | import('estree').Node[]>;
     * 		mount: Array<import('estree').Node | import('estree').Node[]>;
     * 		measure: Array<import('estree').Node | import('estree').Node[]>;
     * 		restore_measurements: Array<import('estree').Node | import('estree').Node[]>;
     * 		fix: Array<import('estree').Node | import('estree').Node[]>;
     * 		animate: Array<import('estree').Node | import('estree').Node[]>;
     * 		intro: Array<import('estree').Node | import('estree').Node[]>;
     * 		update: Array<import('estree').Node | import('estree').Node[]>;
     * 		outro: Array<import('estree').Node | import('estree').Node[]>;
     * 		destroy: Array<import('estree').Node | import('estree').Node[]>;
     * 	}}
     */
    __publicField(this, "chunks");
    /** @type {import('estree').Node[]} */
    __publicField(this, "event_listeners", []);
    /** @type {boolean} */
    __publicField(this, "maintain_context");
    /** @type {boolean} */
    __publicField(this, "has_animation");
    /** @type {boolean} */
    __publicField(this, "has_intros");
    /** @type {boolean} */
    __publicField(this, "has_outros");
    /** @type {boolean} */
    __publicField(this, "has_intro_method");
    // could have the method without the transition, due to siblings
    /** @type {boolean} */
    __publicField(this, "has_outro_method");
    /** @type {number} */
    __publicField(this, "outros");
    /** @type {Map<string, import('estree').Identifier>} */
    __publicField(this, "aliases");
    /** @type {Map<string, { id: import('estree').Identifier; init?: import('estree').Node }>} */
    __publicField(this, "variables", /* @__PURE__ */ new Map());
    /** @type {(name: string) => import('estree').Identifier} */
    __publicField(this, "get_unique_name");
    /** */
    __publicField(this, "has_update_method", false);
    /** @type {{ element_var: string; condition_expression?: any }} */
    __publicField(this, "autofocus");
    this.parent = options.parent;
    this.renderer = options.renderer;
    this.name = options.name;
    this.type = options.type;
    this.comment = options.comment;
    this.wrappers = [];
    this.key = options.key;
    this.first = null;
    this.bindings = options.bindings;
    this.chunks = {
      declarations: [],
      init: [],
      create: [],
      claim: [],
      hydrate: [],
      mount: [],
      measure: [],
      restore_measurements: [],
      fix: [],
      animate: [],
      intro: [],
      update: [],
      outro: [],
      destroy: []
    };
    this.has_animation = false;
    this.has_intro_method = false;
    this.has_outro_method = false;
    this.outros = 0;
    this.get_unique_name = this.renderer.component.get_unique_name_maker();
    this.aliases = /* @__PURE__ */ new Map();
    if (this.key)
      this.aliases.set("key", this.get_unique_name("key"));
  }
  assign_variable_names() {
    const seen = /* @__PURE__ */ new Set();
    const dupes = /* @__PURE__ */ new Set();
    let i = this.wrappers.length;
    while (i--) {
      const wrapper = this.wrappers[i];
      if (!wrapper.var)
        continue;
      if (seen.has(wrapper.var.name)) {
        dupes.add(wrapper.var.name);
      }
      seen.add(wrapper.var.name);
    }
    const counts = /* @__PURE__ */ new Map();
    i = this.wrappers.length;
    while (i--) {
      const wrapper = this.wrappers[i];
      if (!wrapper.var)
        continue;
      let suffix = "";
      if (dupes.has(wrapper.var.name)) {
        const i2 = counts.get(wrapper.var.name) || 0;
        counts.set(wrapper.var.name, i2 + 1);
        suffix = i2;
      }
      wrapper.var.name = this.get_unique_name(wrapper.var.name + suffix).name;
    }
  }
  /** @param {Set<string>} dependencies */
  add_dependencies(dependencies) {
    dependencies.forEach((dependency) => {
      this.dependencies.add(dependency);
    });
    this.has_update_method = true;
    if (this.parent) {
      this.parent.add_dependencies(dependencies);
    }
  }
  /**
   * @param {import('estree').Identifier} id
   * @param {import('estree').Node} render_statement
   * @param {import('estree').Node} claim_statement
   * @param {import('estree').Node} parent_node
   * @param {boolean} [no_detach]
   */
  add_element(id, render_statement, claim_statement, parent_node, no_detach) {
    this.add_variable(id);
    this.chunks.create.push(b`${id} = ${render_statement};`);
    if (this.renderer.options.hydratable) {
      this.chunks.claim.push(b`${id} = ${claim_statement || render_statement};`);
    }
    if (parent_node) {
      this.chunks.mount.push(b`@append(${parent_node}, ${id});`);
      if (is_head(parent_node) && !no_detach)
        this.chunks.destroy.push(b`@detach(${id});`);
    } else {
      this.chunks.mount.push(b`@insert(#target, ${id}, #anchor);`);
      if (!no_detach)
        this.chunks.destroy.push(b`if (detaching) @detach(${id});`);
    }
  }
  /** @param {boolean} [local] */
  add_intro(local) {
    this.has_intros = this.has_intro_method = true;
    if (!local && this.parent)
      this.parent.add_intro();
  }
  /** @param {boolean} [local] */
  add_outro(local) {
    this.has_outros = this.has_outro_method = true;
    this.outros += 1;
    if (!local && this.parent)
      this.parent.add_outro();
  }
  add_animation() {
    this.has_animation = true;
  }
  /**
   * @param {import('estree').Identifier} id
   * @param {import('estree').Node} [init]
   */
  add_variable(id, init) {
    if (this.variables.has(id.name)) {
      throw new Error(`Variable '${id.name}' already initialised with a different value`);
    }
    this.variables.set(id.name, { id, init });
  }
  /** @param {string} name */
  alias(name8) {
    if (!this.aliases.has(name8)) {
      this.aliases.set(name8, this.get_unique_name(name8));
    }
    return this.aliases.get(name8);
  }
  /** @param {BlockOptions} options */
  child(options) {
    return new _Block(Object.assign({}, this, { key: null }, options, { parent: this }));
  }
  /** @param {any} [key] */
  get_contents(key) {
    const { dev } = this.renderer.options;
    if (this.has_outros) {
      this.add_variable({ type: "Identifier", name: "#current" });
      if (this.chunks.intro.length > 0) {
        this.chunks.intro.push(b`#current = true;`);
        this.chunks.mount.push(b`#current = true;`);
      }
      if (this.chunks.outro.length > 0) {
        this.chunks.outro.push(b`#current = false;`);
      }
    }
    if (this.autofocus) {
      if (this.autofocus.condition_expression) {
        this.chunks.mount.push(
          b`if (${this.autofocus.condition_expression}) ${this.autofocus.element_var}.focus();`
        );
      } else {
        this.chunks.mount.push(b`${this.autofocus.element_var}.focus();`);
      }
    }
    this.render_binding_groups();
    this.render_listeners();
    const properties2 = {};
    const noop2 = x`@noop`;
    properties2.key = key;
    if (this.first) {
      properties2.first = x`null`;
      this.chunks.hydrate.push(b`this.first = ${this.first};`);
    }
    if (this.chunks.create.length === 0 && this.chunks.hydrate.length === 0) {
      properties2.create = noop2;
    } else {
      const hydrate = this.chunks.hydrate.length > 0 && (this.renderer.options.hydratable ? b`this.h();` : this.chunks.hydrate);
      properties2.create = x`function #create() {
				${this.chunks.create}
				${hydrate}
			}`;
    }
    if (this.renderer.options.hydratable || this.chunks.claim.length > 0) {
      if (this.chunks.claim.length === 0 && this.chunks.hydrate.length === 0) {
        properties2.claim = noop2;
      } else {
        properties2.claim = x`function #claim(#nodes) {
					${this.chunks.claim}
					${this.renderer.options.hydratable && this.chunks.hydrate.length > 0 && b`this.h();`}
				}`;
      }
    }
    if (this.renderer.options.hydratable && this.chunks.hydrate.length > 0) {
      properties2.hydrate = x`function #hydrate() {
				${this.chunks.hydrate}
			}`;
    }
    if (this.chunks.mount.length === 0) {
      properties2.mount = noop2;
    } else if (this.event_listeners.length === 0) {
      properties2.mount = x`function #mount(#target, #anchor) {
				${this.chunks.mount}
			}`;
    } else {
      properties2.mount = x`function #mount(#target, #anchor) {
				${this.chunks.mount}
			}`;
    }
    if (this.has_update_method || this.maintain_context) {
      if (this.chunks.update.length === 0 && !this.maintain_context) {
        properties2.update = noop2;
      } else {
        const ctx = this.maintain_context ? x`#new_ctx` : x`#ctx`;
        let dirty = { type: "Identifier", name: "#dirty" };
        if (!this.renderer.context_overflow && !this.parent) {
          dirty = { type: "ArrayPattern", elements: [dirty] };
        }
        properties2.update = x`function #update(${ctx}, ${dirty}) {
					${this.maintain_context && b`#ctx = ${ctx};`}
					${this.chunks.update}
				}`;
      }
    }
    if (this.has_animation) {
      properties2.measure = x`function #measure() {
				${this.chunks.measure}
			}`;
      if (this.chunks.restore_measurements.length) {
        properties2.restore_measurements = x`function #restore_measurements(#measurement) {
					${this.chunks.restore_measurements}
				}`;
      }
      properties2.fix = x`function #fix() {
				${this.chunks.fix}
			}`;
      properties2.animate = x`function #animate() {
				${this.chunks.animate}
			}`;
    }
    if (this.has_intro_method || this.has_outro_method) {
      if (this.chunks.intro.length === 0) {
        properties2.intro = noop2;
      } else {
        properties2.intro = x`function #intro(#local) {
					${this.has_outros && b`if (#current) return;`}
					${this.chunks.intro}
				}`;
      }
      if (this.chunks.outro.length === 0) {
        properties2.outro = noop2;
      } else {
        properties2.outro = x`function #outro(#local) {
					${this.chunks.outro}
				}`;
      }
    }
    if (this.chunks.destroy.length === 0) {
      properties2.destroy = noop2;
    } else {
      const dispose_elements = [];
      const others = flatten(this.chunks.destroy).filter(
        /** @param {import('estree').Node} node */
        (node) => {
          if (node.type === "IfStatement" && node.test.type === "Identifier" && node.test.name === "detaching") {
            dispose_elements.push(node.consequent);
            return false;
          } else {
            return true;
          }
        }
      );
      properties2.destroy = x`function #destroy(detaching) {
				${dispose_elements.length ? b`if (detaching) { ${dispose_elements} }` : null}
				${others}
			}`;
    }
    if (!this.renderer.component.compile_options.dev) {
      for (const name8 in properties2) {
        const property = properties2[name8];
        if (property)
          property.id = null;
      }
    }
    const return_value = x`{
			key: ${properties2.key},
			first: ${properties2.first},
			c: ${properties2.create},
			l: ${properties2.claim},
			h: ${properties2.hydrate},
			m: ${properties2.mount},
			p: ${properties2.update},
			r: ${properties2.measure},
			s: ${properties2.restore_measurements},
			f: ${properties2.fix},
			a: ${properties2.animate},
			i: ${properties2.intro},
			o: ${properties2.outro},
			d: ${properties2.destroy}
		}`;
    const block = dev && this.get_unique_name("block");
    const body = b`
			${this.chunks.declarations}

			${Array.from(this.variables.values()).map(({ id, init }) => {
      return init ? b`let ${id} = ${init}` : b`let ${id}`;
    })}

			${this.chunks.init}

			${dev ? b`
					const ${block} = ${return_value};
					@dispatch_dev("SvelteRegisterBlock", {
						block: ${block},
						id: ${this.name || "create_fragment"}.name,
						type: "${this.type}",
						source: "${this.comment ? this.comment.replace(regex_double_quotes, '\\"') : ""}",
						ctx: #ctx
					});
					return ${block};` : b`
					return ${return_value};`}
		`;
    return body;
  }
  /** @returns {boolean} */
  has_content() {
    return !!this.first || this.event_listeners.length > 0 || this.chunks.intro.length > 0 || this.chunks.outro.length > 0 || this.chunks.create.length > 0 || this.chunks.hydrate.length > 0 || this.chunks.claim.length > 0 || this.chunks.mount.length > 0 || this.chunks.update.length > 0 || this.chunks.destroy.length > 0 || this.has_animation;
  }
  render() {
    const key = this.key && this.get_unique_name("key");
    const args = [x`#ctx`];
    if (key)
      args.unshift(key);
    const fn = b`function ${this.name}(${args}) {
			${this.get_contents(key)}
		}`;
    return this.comment ? b`
				// ${this.comment}
				${fn}` : fn;
  }
  /** @param {string} chunk */
  render_listeners(chunk = "") {
    if (this.event_listeners.length > 0) {
      this.add_variable({ type: "Identifier", name: "#mounted" });
      this.chunks.destroy.push(b`#mounted = false`);
      const dispose = {
        type: "Identifier",
        name: `#dispose${chunk}`
      };
      this.add_variable(dispose);
      if (this.event_listeners.length === 1) {
        this.chunks.mount.push(b`
						if (!#mounted) {
							${dispose} = ${this.event_listeners[0]};
							#mounted = true;
						}
					`);
        this.chunks.destroy.push(b`${dispose}();`);
      } else {
        this.chunks.mount.push(b`
					if (!#mounted) {
						${dispose} = [
							${this.event_listeners}
						];
						#mounted = true;
					}
				`);
        this.chunks.destroy.push(b`@run_all(${dispose});`);
      }
    }
  }
  render_binding_groups() {
    for (const binding_group of this.binding_groups) {
      binding_group.render(this);
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/Wrapper.js
var Wrapper = class {
  /**
   * @param {import('../../Renderer.js').default} renderer
   * @param {import('../../Block.js').default} block
   * @param {Wrapper} parent
   * @param {NodeType} node
   */
  constructor(renderer, block, parent, node) {
    /** @type {import('../../Renderer.js').default} */
    __publicField(this, "renderer");
    /** @type {Wrapper} */
    __publicField(this, "parent");
    /** @type {NodeType} */
    __publicField(this, "node");
    /** @type {Wrapper | null} */
    __publicField(this, "prev");
    /** @type {Wrapper | null} */
    __publicField(this, "next");
    /** @type {import('estree').Identifier} */
    __publicField(this, "var");
    this.node = node;
    Object.defineProperties(this, {
      renderer: {
        value: renderer
      },
      parent: {
        value: parent
      }
    });
    block.wrappers.push(this);
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  get_or_create_anchor(block, parent_node, parent_nodes) {
    const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
    const anchor = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || { type: "Identifier", name: "null" };
    if (needs_anchor) {
      block.add_element(
        anchor,
        x`@empty()`,
        parent_nodes && x`@empty()`,
        /** @type {import('estree').Identifier} */
        parent_node
      );
    }
    return anchor;
  }
  /**
   * @param {import('estree').Identifier} anchor
   * @returns {import('estree').Identifier}
   */
  get_update_mount_node(anchor) {
    return (
      /** @type {import('estree').Identifier} */
      this.parent && this.parent.is_dom_node() ? this.parent.var : x`${anchor}.parentNode`
    );
  }
  is_dom_node() {
    return this.node.type === "Element" || this.node.type === "Text" || this.node.type === "MustacheTag";
  }
  /**
   * @param {import('../../Block.js').default} _block
   * @param {import('estree').Identifier} _parent_node
   * @param {import('estree').Identifier} _parent_nodes
   * @param {Record<string, any>} _data
   */
  render(_block, _parent_node, _parent_nodes, _data = void 0) {
    throw Error("Wrapper class is not renderable");
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/create_debugging_comment.js
function create_debugging_comment(node, component) {
  const { locate: locate2, source } = component;
  let c = node.start;
  if (node.type === "ElseBlock") {
    while (source[c - 1] !== "{")
      c -= 1;
    while (source[c - 1] === "{")
      c -= 1;
  }
  let d;
  if (node.type === "InlineComponent" || node.type === "Element" || node.type === "SlotTemplate") {
    if (node.children.length) {
      d = node.children[0].start;
      while (source[d - 1] !== ">")
        d -= 1;
    } else {
      d = node.start;
      while (source[d] !== ">")
        d += 1;
      d += 1;
    }
  } else if (node.type === "Text" || node.type === "Comment") {
    d = node.end;
  } else {
    d = node.expression ? node.expression.node.end : c;
    while (source[d] !== "}" && d <= source.length)
      d += 1;
    while (source[d] === "}")
      d += 1;
  }
  const start = locate2(c);
  const loc = `(${start.line}:${start.column})`;
  return `${loc} ${source.slice(c, d)}`.replace(regex_whitespace_characters, " ");
}

// node_modules/svelte/src/compiler/compile/nodes/shared/Node.js
var Node = class {
  /**
   * @param {import('../../Component.js').default} component
   * @param {Node} parent
   * @param {any} _scope
   * @param {import('../../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, _scope, info) {
    /**
     * @readonly
     * @type {number}
     */
    __publicField(this, "start");
    /**
     * @readonly
     * @type {number}
     */
    __publicField(this, "end");
    /**
     * @readonly
     * @type {import('../../Component.js').default}
     */
    __publicField(this, "component");
    /**
     * @readonly
     * @type {Parent}
     */
    __publicField(this, "parent");
    /**
     * @readonly
     * @type {Type}
     */
    __publicField(this, "type");
    /** @type {import('../interfaces.js').INode} */
    __publicField(this, "prev");
    /** @type {import('../interfaces.js').INode} */
    __publicField(this, "next");
    /** @type {boolean} */
    __publicField(this, "can_use_innerhtml");
    /** @type {boolean} */
    __publicField(this, "is_static_content");
    /** @type {string} */
    __publicField(this, "var");
    /** @type {import('../Attribute.js').default[]} */
    __publicField(this, "attributes", []);
    this.start = info.start;
    this.end = info.end;
    this.type = /** @type {Type} */
    info.type;
    Object.defineProperties(this, {
      component: {
        value: component
      },
      parent: {
        value: parent
      }
    });
    this.can_use_innerhtml = true;
    this.is_static_content = true;
  }
  cannot_use_innerhtml() {
    if (this.can_use_innerhtml !== false) {
      this.can_use_innerhtml = false;
      if (this.parent)
        this.parent.cannot_use_innerhtml();
    }
  }
  not_static_content() {
    this.is_static_content = false;
    if (this.parent)
      this.parent.not_static_content();
  }
  /** @param {RegExp} selector */
  find_nearest(selector) {
    if (selector.test(this.type))
      return this;
    if (this.parent)
      return this.parent.find_nearest(selector);
  }
  /** @param {string} name */
  get_static_attribute_value(name8) {
    const attribute = this.attributes.find(
      /** @param {import('../Attribute.js').default} attr */
      (attr) => attr.type === "Attribute" && attr.name.toLowerCase() === name8
    );
    if (!attribute)
      return null;
    if (attribute.is_true)
      return true;
    if (attribute.chunks.length === 0)
      return "";
    if (attribute.chunks.length === 1 && attribute.chunks[0].type === "Text") {
      return (
        /** @type {import('../Text.js').default} */
        attribute.chunks[0].data
      );
    }
    return null;
  }
  /** @param {string} type */
  has_ancestor(type) {
    return this.parent ? this.parent.type === type || this.parent.has_ancestor(type) : false;
  }
};

// node_modules/svelte/src/compiler/compile/compiler_warnings.js
var compiler_warnings_default = {
  tag_option_deprecated: {
    code: "tag-option-deprecated",
    message: "'tag' option is deprecated â€” use 'customElement' instead"
  },
  unused_export_let: (
    /**
    * @param {string} component
    * @param {string} property
    */
    (component, property) => ({
      code: "unused-export-let",
      message: `${component} has unused export property '${property}'. If it is for external reference only, please consider using \`export const ${property}\``
    })
  ),
  module_script_reactive_declaration: {
    code: "module-script-reactive-declaration",
    message: "$: has no effect in a module script"
  },
  non_top_level_reactive_declaration: {
    code: "non-top-level-reactive-declaration",
    message: "$: has no effect outside of the top-level"
  },
  module_script_variable_reactive_declaration: (
    /** @param {string[]} names */
    (names) => ({
      code: "module-script-reactive-declaration",
      message: `${names.map((name8) => `"${name8}"`).join(", ")} ${names.length > 1 ? "are" : "is"} declared in a module script and will not be reactive`
    })
  ),
  missing_declaration: (
    /**
    * @param {string} name
    * @param {boolean} has_script
    */
    (name8, has_script) => ({
      code: "missing-declaration",
      message: `'${name8}' is not defined` + (has_script ? "" : `. Consider adding a <script> block with 'export let ${name8}' to declare a prop`)
    })
  ),
  missing_custom_element_compile_options: {
    code: "missing-custom-element-compile-options",
    message: "The 'customElement' option is used when generating a custom element. Did you forget the 'customElement: true' compile option?"
  },
  css_unused_selector: (
    /** @param {string} selector */
    (selector) => ({
      code: "css-unused-selector",
      message: `Unused CSS selector "${selector}"`
    })
  ),
  empty_block: {
    code: "empty-block",
    message: "Empty block"
  },
  reactive_component: (
    /** @param {string} name */
    (name8) => ({
      code: "reactive-component",
      message: `<${name8}/> will not be reactive if ${name8} changes. Use <svelte:component this={${name8}}/> if you want this reactivity.`
    })
  ),
  component_name_lowercase: (
    /** @param {string} name */
    (name8) => ({
      code: "component-name-lowercase",
      message: `<${name8}> will be treated as an HTML element unless it begins with a capital letter`
    })
  ),
  avoid_is: {
    code: "avoid-is",
    message: "The 'is' attribute is not supported cross-browser and should be avoided"
  },
  invalid_html_attribute: (
    /**
    * @param {string} name
    * @param {string} suggestion
    */
    (name8, suggestion) => ({
      code: "invalid-html-attribute",
      message: `'${name8}' is not a valid HTML attribute. Did you mean '${suggestion}'?`
    })
  ),
  a11y_aria_attributes: (
    /** @param {string} name */
    (name8) => ({
      code: "a11y-aria-attributes",
      message: `A11y: <${name8}> should not have aria-* attributes`
    })
  ),
  a11y_incorrect_attribute_type: (
    /**
    * @param {import('aria-query').ARIAPropertyDefinition} schema
    * @param {string} attribute
    */
    (schema, attribute) => {
      let message;
      switch (schema.type) {
        case "boolean":
          message = `The value of '${attribute}' must be exactly one of true or false`;
          break;
        case "id":
          message = `The value of '${attribute}' must be a string that represents a DOM element ID`;
          break;
        case "idlist":
          message = `The value of '${attribute}' must be a space-separated list of strings that represent DOM element IDs`;
          break;
        case "tristate":
          message = `The value of '${attribute}' must be exactly one of true, false, or mixed`;
          break;
        case "token":
          message = `The value of '${attribute}' must be exactly one of ${(schema.values || []).join(
            ", "
          )}`;
          break;
        case "tokenlist":
          message = `The value of '${attribute}' must be a space-separated list of one or more of ${(schema.values || []).join(", ")}`;
          break;
        default:
          message = `The value of '${attribute}' must be of type ${schema.type}`;
      }
      return {
        code: "a11y-incorrect-aria-attribute-type",
        message: `A11y: ${message}`
      };
    }
  ),
  a11y_unknown_aria_attribute: (
    /**
    * @param {string} attribute
    * @param {string} [suggestion]
    */
    (attribute, suggestion) => ({
      code: "a11y-unknown-aria-attribute",
      message: `A11y: Unknown aria attribute 'aria-${attribute}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
    })
  ),
  a11y_hidden: (
    /** @param {string} name */
    (name8) => ({
      code: "a11y-hidden",
      message: `A11y: <${name8}> element should not be hidden`
    })
  ),
  a11y_misplaced_role: (
    /** @param {string} name */
    (name8) => ({
      code: "a11y-misplaced-role",
      message: `A11y: <${name8}> should not have role attribute`
    })
  ),
  a11y_unknown_role: (
    /**
    * @param {string | boolean} role
    * @param {string} [suggestion]
    */
    (role, suggestion) => ({
      code: "a11y-unknown-role",
      message: `A11y: Unknown role '${role}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
    })
  ),
  a11y_no_abstract_role: (
    /** @param {string | boolean} role */
    (role) => ({
      code: "a11y-no-abstract-role",
      message: `A11y: Abstract role '${role}' is forbidden`
    })
  ),
  a11y_no_redundant_roles: (
    /** @param {string | boolean} role */
    (role) => ({
      code: "a11y-no-redundant-roles",
      message: `A11y: Redundant role '${role}'`
    })
  ),
  a11y_no_static_element_interactions: (
    /**
    * @param {string} element
    * @param {string[]} handlers
    */
    (element, handlers2) => ({
      code: "a11y-no-static-element-interactions",
      message: `A11y: <${element}> with ${handlers2.join(", ")} ${handlers2.length === 1 ? "handler" : "handlers"} must have an ARIA role`
    })
  ),
  a11y_no_interactive_element_to_noninteractive_role: (
    /**
    * @param {string | boolean} role
    * @param {string} element
    */
    (role, element) => ({
      code: "a11y-no-interactive-element-to-noninteractive-role",
      message: `A11y: <${element}> cannot have role '${role}'`
    })
  ),
  a11y_no_noninteractive_element_interactions: (
    /** @param {string} element */
    (element) => ({
      code: "a11y-no-noninteractive-element-interactions",
      message: `A11y: Non-interactive element <${element}> should not be assigned mouse or keyboard event listeners.`
    })
  ),
  a11y_no_noninteractive_element_to_interactive_role: (
    /**
    * @param {string | boolean} role
    * @param {string} element
    */
    (role, element) => ({
      code: "a11y-no-noninteractive-element-to-interactive-role",
      message: `A11y: Non-interactive element <${element}> cannot have interactive role '${role}'`
    })
  ),
  a11y_role_has_required_aria_props: (
    /**
    * @param {string} role
    * @param {string[]} props
    */
    (role, props) => ({
      code: "a11y-role-has-required-aria-props",
      message: `A11y: Elements with the ARIA role "${role}" must have the following attributes defined: ${props.map((name8) => `"${name8}"`).join(", ")}`
    })
  ),
  a11y_role_supports_aria_props: (
    /**
    * @param {string} attribute
    * @param {string} role
    * @param {boolean} is_implicit
    * @param {string} name
    */
    (attribute, role, is_implicit, name8) => {
      let message = `The attribute '${attribute}' is not supported by the role '${role}'.`;
      if (is_implicit) {
        message += ` This role is implicit on the element <${name8}>.`;
      }
      return {
        code: "a11y-role-supports-aria-props",
        message: `A11y: ${message}`
      };
    }
  ),
  a11y_accesskey: {
    code: "a11y-accesskey",
    message: "A11y: Avoid using accesskey"
  },
  a11y_autofocus: {
    code: "a11y-autofocus",
    message: "A11y: Avoid using autofocus"
  },
  a11y_misplaced_scope: {
    code: "a11y-misplaced-scope",
    message: "A11y: The scope attribute should only be used with <th> elements"
  },
  a11y_positive_tabindex: {
    code: "a11y-positive-tabindex",
    message: "A11y: avoid tabindex values above zero"
  },
  a11y_invalid_attribute: (
    /**
    * @param {string} href_attribute
    * @param {string} href_value
    */
    (href_attribute, href_value) => ({
      code: "a11y-invalid-attribute",
      message: `A11y: '${href_value}' is not a valid ${href_attribute} attribute`
    })
  ),
  a11y_missing_attribute: (
    /**
    * @param {string} name
    * @param {string} article
    * @param {string} sequence
    */
    (name8, article, sequence) => ({
      code: "a11y-missing-attribute",
      message: `A11y: <${name8}> element should have ${article} ${sequence} attribute`
    })
  ),
  a11y_autocomplete_valid: (
    /**
    * @param {null | true | string} type
    * @param {null | true | string} value
    */
    (type, value) => ({
      code: "a11y-autocomplete-valid",
      message: `A11y: The value '${value}' is not supported by the attribute 'autocomplete' on element <input type="${type || "..."}">`
    })
  ),
  a11y_img_redundant_alt: {
    code: "a11y-img-redundant-alt",
    message: "A11y: Screenreaders already announce <img> elements as an image."
  },
  a11y_interactive_supports_focus: (
    /** @param {string} role */
    (role) => ({
      code: "a11y-interactive-supports-focus",
      message: `A11y: Elements with the '${role}' interactive role must have a tabindex value.`
    })
  ),
  a11y_label_has_associated_control: {
    code: "a11y-label-has-associated-control",
    message: "A11y: A form label must be associated with a control."
  },
  a11y_media_has_caption: {
    code: "a11y-media-has-caption",
    message: 'A11y: <video> elements must have a <track kind="captions">'
  },
  a11y_distracting_elements: (
    /** @param {string} name */
    (name8) => ({
      code: "a11y-distracting-elements",
      message: `A11y: Avoid <${name8}> elements`
    })
  ),
  a11y_structure_immediate: {
    code: "a11y-structure",
    message: "A11y: <figcaption> must be an immediate child of <figure>"
  },
  a11y_structure_first_or_last: {
    code: "a11y-structure",
    message: "A11y: <figcaption> must be first or last child of <figure>"
  },
  a11y_mouse_events_have_key_events: (
    /**
    * @param {string} event
    * @param {string} accompanied_by
    */
    (event, accompanied_by) => ({
      code: "a11y-mouse-events-have-key-events",
      message: `A11y: on:${event} must be accompanied by on:${accompanied_by}`
    })
  ),
  a11y_click_events_have_key_events: {
    code: "a11y-click-events-have-key-events",
    message: 'A11y: visible, non-interactive elements with an on:click event must be accompanied by a keyboard event handler. Consider whether an interactive element such as <button type="button"> or <a> might be more appropriate. See https://svelte.dev/docs/accessibility-warnings#a11y-click-events-have-key-events for more details.'
  },
  a11y_missing_content: (
    /** @param {string} name */
    (name8) => ({
      code: "a11y-missing-content",
      message: `A11y: <${name8}> element should have child content`
    })
  ),
  a11y_no_noninteractive_tabindex: {
    code: "a11y-no-noninteractive-tabindex",
    message: "A11y: noninteractive element cannot have nonnegative tabIndex value"
  },
  a11y_aria_activedescendant_has_tabindex: {
    code: "a11y-aria-activedescendant-has-tabindex",
    message: "A11y: Elements with attribute aria-activedescendant should have tabindex value"
  },
  redundant_event_modifier_for_touch: {
    code: "redundant-event-modifier",
    message: "Touch event handlers that don't use the 'event' object are passive by default"
  },
  redundant_event_modifier_passive: {
    code: "redundant-event-modifier",
    message: "The passive modifier only works with wheel and touch events"
  },
  invalid_rest_eachblock_binding: (
    /** @param {string} rest_element_name */
    (rest_element_name) => ({
      code: "invalid-rest-eachblock-binding",
      message: `The rest operator (...) will create a new object and binding '${rest_element_name}' with the original object will not work`
    })
  ),
  avoid_mouse_events_on_document: {
    code: "avoid-mouse-events-on-document",
    message: "Mouse enter/leave events on the document are not supported in all browsers and should be avoided"
  },
  illegal_attribute_character: {
    code: "illegal-attribute-character",
    message: "Attributes should not contain ':' characters to prevent ambiguity with Svelte directives"
  }
};

// node_modules/svelte/src/compiler/compile/nodes/shared/AbstractBlock.js
var regex_non_whitespace_characters = /[^ \r\n\f\v\t]/;
var AbstractBlock = class extends Node {
  /**
   * @param {import('../../Component.js').default} component
   * @param {any} parent
   * @param {any} scope
   * @param {any} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('../../render_dom/Block.js').default} */
    __publicField(this, "block");
    /** @type {import('../interfaces.js').INode[]} */
    __publicField(this, "children");
  }
  warn_if_empty_block() {
    if (!this.children || this.children.length > 1)
      return;
    const child = this.children[0];
    if (!child || child.type === "Text" && !regex_non_whitespace_characters.test(child.data)) {
      this.component.warn(this, compiler_warnings_default.empty_block);
    }
  }
};

// node_modules/svelte/src/compiler/compile/utils/flatten_reference.js
function flatten_reference(node) {
  const nodes = [];
  const parts = [];
  while (node.type === "MemberExpression") {
    nodes.unshift(node.property);
    if (!node.computed) {
      parts.unshift(
        /** @type {import('estree').Identifier} */
        node.property.name
      );
    } else {
      const computed_property = to_string2(node.property);
      if (computed_property) {
        parts.unshift(`[${computed_property}]`);
      }
    }
    node = node.object;
  }
  const name8 = node.type === "Identifier" ? node.name : node.type === "ThisExpression" ? "this" : null;
  nodes.unshift(node);
  parts.unshift(name8);
  return { name: name8, nodes, parts };
}
function to_string2(node) {
  switch (node.type) {
    case "Literal":
      return String(node.value);
    case "Identifier":
      return node.name;
  }
}

// node_modules/svelte/src/compiler/compile/utils/scope.js
function create_scopes(expression) {
  return analyze(expression);
}

// node_modules/svelte/src/compiler/compile/utils/get_object.js
function get_object(node) {
  while (node.type === "MemberExpression")
    node = node.object;
  return (
    /** @type {import('estree').Identifier} */
    node
  );
}

// node_modules/svelte/src/compiler/compile/utils/reserved_keywords.js
var reserved_keywords = /* @__PURE__ */ new Set(["$$props", "$$restProps", "$$slots"]);
function is_reserved_keyword(name8) {
  return reserved_keywords.has(name8);
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/is_dynamic.js
function is_dynamic(variable) {
  if (variable) {
    const is_declared_in_reactive_context = !variable.module && !variable.global;
    if (is_declared_in_reactive_context && (variable.mutated || variable.reassigned))
      return true;
    if (is_declared_in_reactive_context && variable.writable && variable.export_name)
      return true;
    if (is_reserved_keyword(variable.name))
      return true;
  }
  return false;
}

// node_modules/svelte/src/compiler/utils/nodes_match.js
function nodes_match(a, b2, ignoreKeys = []) {
  if (!!a !== !!b2)
    return false;
  if (Array.isArray(a) !== Array.isArray(b2))
    return false;
  if (a && typeof a === "object") {
    if (Array.isArray(a)) {
      if (a.length !== b2.length)
        return false;
      return a.every((child, i2) => nodes_match(child, b2[i2]));
    }
    const a_keys = Object.keys(a).sort().filter((key) => !ignoreKeys.includes(key));
    const b_keys = Object.keys(b2).sort().filter((key) => !ignoreKeys.includes(key));
    if (a_keys.length !== b_keys.length)
      return false;
    let i = a_keys.length;
    while (i--) {
      const key = a_keys[i];
      if (b_keys[i] !== key)
        return false;
      if (key === "start" || key === "end")
        continue;
      if (!nodes_match(a[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a === b2;
}

// node_modules/svelte/src/compiler/compile/render_dom/invalidate.js
function invalidate(renderer, scope, node, names, main_execution_context = false) {
  const { component } = renderer;
  const [head, ...tail] = (
    /** @type {import('../../interfaces.js').Var[]} */
    Array.from(names).filter((name8) => {
      const owner = scope.find_owner(name8);
      return !owner || owner === component.instance_scope;
    }).map((name8) => component.var_lookup.get(name8)).filter((variable) => {
      return variable && !variable.hoistable && !variable.global && !variable.module && (variable.referenced || variable.subscribable || variable.is_reactive_dependency || variable.export_name || variable.name[0] === "$");
    })
  );
  function get_invalidated(variable, node2) {
    if (main_execution_context && !variable.subscribable && variable.name[0] !== "$") {
      return node2;
    }
    return renderer_invalidate(renderer, variable.name, void 0, main_execution_context);
  }
  if (!head) {
    return node;
  }
  component.has_reactive_assignments = true;
  if (node.type === "AssignmentExpression" && node.operator === "=" && nodes_match(node.left, node.right, ["trailingComments", "leadingComments"]) && tail.length === 0) {
    return get_invalidated(head, node);
  }
  const is_store_value = head.name[0] === "$" && head.name[1] !== "$";
  const extra_args = tail.map((variable) => get_invalidated(variable)).filter(Boolean);
  if (is_store_value) {
    return x`@set_store_value(${head.name.slice(1)}, ${node}, ${head.name}, ${extra_args})`;
  }
  let invalidate2;
  if (!main_execution_context) {
    const pass_value = extra_args.length > 0 || node.type === "AssignmentExpression" && node.left.type !== "Identifier" || node.type === "UpdateExpression" && (!node.prefix || node.argument.type !== "Identifier");
    if (pass_value) {
      extra_args.unshift({
        type: "Identifier",
        name: head.name
      });
    }
    invalidate2 = x`$$invalidate(${renderer.context_lookup.get(head.name).index}, ${node}, ${extra_args})`;
  } else {
    invalidate2 = extra_args.length ? [node, ...extra_args] : node;
  }
  if (head.subscribable && head.reassigned) {
    const subscribe = `$$subscribe_${head.name}`;
    invalidate2 = x`${subscribe}(${invalidate2})`;
  }
  return invalidate2;
}
function renderer_invalidate(renderer, name8, value, main_execution_context = false) {
  const variable = renderer.component.var_lookup.get(name8);
  if (variable && variable.subscribable && (variable.reassigned || variable.export_name)) {
    if (main_execution_context) {
      return x`${`$$subscribe_${name8}`}(${value || name8})`;
    } else {
      const member = renderer.context_lookup.get(name8);
      return x`${`$$subscribe_${name8}`}($$invalidate(${member.index}, ${value || name8}))`;
    }
  }
  if (name8[0] === "$" && name8[1] !== "$") {
    return x`${name8.slice(1)}.set(${value || name8})`;
  }
  if (variable && (variable.module || !variable.referenced && !variable.is_reactive_dependency && !variable.export_name && !name8.startsWith("$$"))) {
    return value || name8;
  }
  if (value) {
    if (main_execution_context) {
      return x`${value}`;
    } else {
      const member = renderer.context_lookup.get(name8);
      return x`$$invalidate(${member.index}, ${value})`;
    }
  }
  if (main_execution_context)
    return;
  const deps = /* @__PURE__ */ new Set([name8]);
  deps.forEach((name9) => {
    const reactive_declarations = renderer.component.reactive_declarations.filter(
      (x2) => x2.assignees.has(name9)
    );
    reactive_declarations.forEach((declaration) => {
      declaration.dependencies.forEach((name10) => {
        deps.add(name10);
      });
    });
  });
  const filtered = Array.from(deps).filter((n) => renderer.context_lookup.has(n));
  if (!filtered.length)
    return null;
  return filtered.map((n) => x`$$invalidate(${renderer.context_lookup.get(n).index}, ${n})`).reduce((lhs, rhs) => x`${lhs}, ${rhs}`);
}

// node_modules/svelte/src/compiler/compile/utils/replace_object.js
function replace_object(node, replacement) {
  if (node.type === "Identifier")
    return replacement;
  const ancestor = node;
  let parent;
  while (node.type === "MemberExpression") {
    parent = node;
    node = node.object;
  }
  parent.object = /** @type {any} */
  replacement;
  return ancestor;
}

// node_modules/svelte/src/compiler/compile/nodes/shared/is_contextual.js
function is_contextual(component, scope, name8) {
  if (is_reserved_keyword(name8))
    return true;
  if (!scope.is_top_level(name8))
    return true;
  const variable = component.var_lookup.get(name8);
  if (!variable || variable.hoistable)
    return false;
  return true;
}

// node_modules/svelte/src/compiler/utils/clone.js
function clone(val) {
  let k, out, tmp;
  if (Array.isArray(val)) {
    out = Array(k = val.length);
    while (k--)
      out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone(tmp) : tmp;
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = {};
    for (k in val) {
      if (k === "__proto__") {
        Object.defineProperty(out, k, {
          value: clone(val[k]),
          configurable: true,
          enumerable: true,
          writable: true
        });
      } else if (typeof val[k] !== "function") {
        out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone(tmp) : tmp;
      }
    }
    return out;
  }
  return val;
}

// node_modules/svelte/src/compiler/compile/compiler_errors.js
var compiler_errors_default = {
  invalid_binding_elements: (
    /**
    * @param {string} element
    * @param {string} binding
    */
    (element, binding) => ({
      code: "invalid-binding",
      message: `'${binding}' is not a valid binding on <${element}> elements`
    })
  ),
  invalid_binding_element_with: (
    /**
    * @param {string} elements
    * @param {string} binding
    */
    (elements, binding) => ({
      code: "invalid-binding",
      message: `'${binding}' binding can only be used with ${elements}`
    })
  ),
  invalid_binding_on: (
    /**
    * @param {string} binding
    * @param {string} element
    * @param {string} [post]
    */
    (binding, element, post) => ({
      code: "invalid-binding",
      message: `'${binding}' is not a valid binding on ${element}` + (post || "")
    })
  ),
  invalid_binding_foreign: (
    /** @param {string} binding */
    (binding) => ({
      code: "invalid-binding",
      message: `'${binding}' is not a valid binding. Foreign elements only support bind:this`
    })
  ),
  invalid_binding_no_checkbox: (
    /**
    * @param {string} binding
    * @param {boolean} is_radio
    */
    (binding, is_radio) => ({
      code: "invalid-binding",
      message: `'${binding}' binding can only be used with <input type="checkbox">` + (is_radio ? ` â€” for <input type="radio">, use 'group' binding` : "")
    })
  ),
  invalid_binding: (
    /** @param {string} binding */
    (binding) => ({
      code: "invalid-binding",
      message: `'${binding}' is not a valid binding`
    })
  ),
  invalid_binding_window: (
    /** @param {string[]} parts */
    (parts) => ({
      code: "invalid-binding",
      message: `Bindings on <svelte:window> must be to top-level properties, e.g. '${parts[parts.length - 1]}' rather than '${parts.join(".")}'`
    })
  ),
  invalid_binding_let: {
    code: "invalid-binding",
    message: "Cannot bind to a variable declared with the let: directive"
  },
  invalid_binding_await: {
    code: "invalid-binding",
    message: "Cannot bind to a variable declared with {#await ... then} or {:catch} blocks"
  },
  invalid_binding_const: {
    code: "invalid-binding",
    message: "Cannot bind to a variable declared with {@const ...}"
  },
  invalid_binding_writable: {
    code: "invalid-binding",
    message: "Cannot bind to a variable which is not writable"
  },
  binding_undeclared: (
    /** @param {string} name */
    (name8) => ({
      code: "binding-undeclared",
      message: `${name8} is not declared`
    })
  ),
  invalid_type: {
    code: "invalid-type",
    message: "'type' attribute cannot be dynamic if input uses two-way binding"
  },
  missing_type: {
    code: "missing-type",
    message: "'type' attribute must be specified"
  },
  dynamic_multiple_attribute: {
    code: "dynamic-multiple-attribute",
    message: "'multiple' attribute cannot be dynamic if select uses two-way binding"
  },
  missing_contenteditable_attribute: {
    code: "missing-contenteditable-attribute",
    message: "'contenteditable' attribute is required for textContent, innerHTML and innerText two-way bindings"
  },
  dynamic_contenteditable_attribute: {
    code: "dynamic-contenteditable-attribute",
    message: "'contenteditable' attribute cannot be dynamic if element uses two-way binding"
  },
  invalid_event_modifier_combination: (
    /**
    * @param {string} modifier1
    * @param {string} modifier2
    */
    (modifier1, modifier2) => ({
      code: "invalid-event-modifier",
      message: `The '${modifier1}' and '${modifier2}' modifiers cannot be used together`
    })
  ),
  invalid_event_modifier_legacy: (
    /** @param {string} modifier */
    (modifier) => ({
      code: "invalid-event-modifier",
      message: `The '${modifier}' modifier cannot be used in legacy mode`
    })
  ),
  invalid_event_modifier: (
    /** @param {string} valid */
    (valid) => ({
      code: "invalid-event-modifier",
      message: `Valid event modifiers are ${valid}`
    })
  ),
  invalid_event_modifier_component: {
    code: "invalid-event-modifier",
    message: "Event modifiers other than 'once' can only be used on DOM elements"
  },
  textarea_duplicate_value: {
    code: "textarea-duplicate-value",
    message: "A <textarea> can have either a value attribute or (equivalently) child content, but not both"
  },
  illegal_attribute: (
    /** @param {string} name */
    (name8) => ({
      code: "illegal-attribute",
      message: `'${name8}' is not a valid attribute name`
    })
  ),
  invalid_slot_attribute: {
    code: "invalid-slot-attribute",
    message: "slot attribute cannot have a dynamic value"
  },
  duplicate_slot_attribute: (
    /** @param {string} name */
    (name8) => ({
      code: "duplicate-slot-attribute",
      message: `Duplicate '${name8}' slot`
    })
  ),
  invalid_slotted_content: {
    code: "invalid-slotted-content",
    message: "Element with a slot='...' attribute must be a child of a component or a descendant of a custom element"
  },
  invalid_attribute_head: {
    code: "invalid-attribute",
    message: "<svelte:head> should not have any attributes or directives"
  },
  invalid_action: {
    code: "invalid-action",
    message: "Actions can only be applied to DOM elements, not components"
  },
  invalid_animation: {
    code: "invalid-animation",
    message: "Animations can only be applied to DOM elements, not components"
  },
  invalid_class: {
    code: "invalid-class",
    message: "Classes can only be applied to DOM elements, not components"
  },
  invalid_transition: {
    code: "invalid-transition",
    message: "Transitions can only be applied to DOM elements, not components"
  },
  invalid_let: {
    code: "invalid-let",
    message: "let directive value must be an identifier or an object/array pattern"
  },
  invalid_slot_directive: {
    code: "invalid-slot-directive",
    message: "<slot> cannot have directives"
  },
  dynamic_slot_name: {
    code: "dynamic-slot-name",
    message: "<slot> name cannot be dynamic"
  },
  invalid_slot_name: {
    code: "invalid-slot-name",
    message: "default is a reserved word â€” it cannot be used as a slot name"
  },
  invalid_slot_attribute_value_missing: {
    code: "invalid-slot-attribute",
    message: "slot attribute value is missing"
  },
  invalid_slotted_content_fragment: {
    code: "invalid-slotted-content",
    message: "<svelte:fragment> must be a child of a component"
  },
  illegal_attribute_title: {
    code: "illegal-attribute",
    message: "<title> cannot have attributes"
  },
  illegal_structure_title: {
    code: "illegal-structure",
    message: "<title> can only contain text and {tags}"
  },
  duplicate_transition: (
    /**
    * @param {string} directive
    * @param {string} parent_directive
    */
    (directive, parent_directive) => {
      function describe(_directive) {
        return _directive === "transition" ? "a 'transition'" : `an '${_directive}'`;
      }
      const message = directive === parent_directive ? `An element can only have one '${directive}' directive` : `An element cannot have both ${describe(parent_directive)} directive and ${describe(
        directive
      )} directive`;
      return {
        code: "duplicate-transition",
        message
      };
    }
  ),
  contextual_store: {
    code: "contextual-store",
    message: "Stores must be declared at the top level of the component (this may change in a future version of Svelte)"
  },
  default_export: {
    code: "default-export",
    message: "A component cannot have a default export"
  },
  illegal_declaration: {
    code: "illegal-declaration",
    message: "The $ prefix is reserved, and cannot be used for variable and import names"
  },
  illegal_subscription: {
    code: "illegal-subscription",
    message: 'Cannot reference store value inside <script context="module">'
  },
  illegal_global: (
    /** @param {string} name */
    (name8) => ({
      code: "illegal-global",
      message: `${name8} is an illegal variable name`
    })
  ),
  illegal_variable_declaration: {
    code: "illegal-variable-declaration",
    message: 'Cannot declare same variable name which is imported inside <script context="module">'
  },
  cyclical_reactive_declaration: (
    /** @param {string[]} cycle */
    (cycle) => ({
      code: "cyclical-reactive-declaration",
      message: `Cyclical dependency detected: ${cycle.join(" â†’ ")}`
    })
  ),
  invalid_tag_property: {
    code: "invalid-tag-property",
    message: "tag name must be two or more words joined by the '-' character"
  },
  invalid_customElement_attribute: {
    code: "invalid-customElement-attribute",
    message: "'customElement' must be a string literal defining a valid custom element name or an object of the form { tag: string; shadow?: 'open' | 'none'; props?: { [key: string]: { attribute?: string; reflect?: boolean; type: .. } } }"
  },
  invalid_tag_attribute: {
    code: "invalid-tag-attribute",
    message: "'tag' must be a string literal"
  },
  invalid_shadow_attribute: {
    code: "invalid-shadow-attribute",
    message: "'shadow' must be either 'open' or 'none'"
  },
  invalid_props_attribute: {
    code: "invalid-props-attribute",
    message: "'props' must be a statically analyzable object literal of the form '{ [key: string]: { attribute?: string; reflect?: boolean; type?: 'String' | 'Boolean' | 'Number' | 'Array' | 'Object' }'"
  },
  invalid_namespace_property: (
    /**
    * @param {string} namespace
    * @param {string} [suggestion]
    */
    (namespace, suggestion) => ({
      code: "invalid-namespace-property",
      message: `Invalid namespace '${namespace}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
    })
  ),
  invalid_namespace_attribute: {
    code: "invalid-namespace-attribute",
    message: "The 'namespace' attribute must be a string literal representing a valid namespace"
  },
  invalid_attribute_value: (
    /** @param {string} name */
    (name8) => ({
      code: `invalid-${name8}-value`,
      message: `${name8} attribute must be true or false`
    })
  ),
  invalid_options_attribute_unknown: (
    /** @param {string} name */
    (name8) => ({
      code: "invalid-options-attribute",
      message: `<svelte:options> unknown attribute '${name8}'`
    })
  ),
  invalid_options_attribute: {
    code: "invalid-options-attribute",
    message: "<svelte:options> can only have static 'tag', 'namespace', 'accessors', 'immutable' and 'preserveWhitespace' attributes"
  },
  css_invalid_global: {
    code: "css-invalid-global",
    message: ":global(...) can be at the start or end of a selector sequence, but not in the middle"
  },
  css_invalid_global_selector: {
    code: "css-invalid-global-selector",
    message: ":global(...) must contain a single selector"
  },
  css_invalid_global_selector_position: {
    code: "css-invalid-global-selector-position",
    message: ":global(...) not at the start of a selector sequence should not contain type or universal selectors"
  },
  css_invalid_selector: (
    /** @param {string} selector */
    (selector) => ({
      code: "css-invalid-selector",
      message: `Invalid selector "${selector}"`
    })
  ),
  duplicate_animation: {
    code: "duplicate-animation",
    message: "An element can only have one 'animate' directive"
  },
  invalid_animation_immediate: {
    code: "invalid-animation",
    message: "An element that uses the animate directive must be the immediate child of a keyed each block"
  },
  invalid_animation_key: {
    code: "invalid-animation",
    message: "An element that uses the animate directive must be used inside a keyed each block. Did you forget to add a key to your each block?"
  },
  invalid_animation_sole: {
    code: "invalid-animation",
    message: "An element that uses the animate directive must be the sole child of a keyed each block"
  },
  invalid_animation_dynamic_element: {
    code: "invalid-animation",
    message: "<svelte:element> cannot have a animate directive"
  },
  invalid_directive_value: {
    code: "invalid-directive-value",
    message: "Can only bind to an identifier (e.g. `foo`) or a member expression (e.g. `foo.bar` or `foo[baz]`)"
  },
  invalid_const_placement: {
    code: "invalid-const-placement",
    message: "{@const} must be the immediate child of {#if}, {:else if}, {:else}, {#each}, {:then}, {:catch}, <svelte:fragment> or <Component>"
  },
  invalid_const_declaration: (
    /** @param {string} name */
    (name8) => ({
      code: "invalid-const-declaration",
      message: `'${name8}' has already been declared`
    })
  ),
  invalid_const_update: (
    /** @param {string} name */
    (name8) => ({
      code: "invalid-const-update",
      message: `'${name8}' is declared using {@const ...} and is read-only`
    })
  ),
  cyclical_const_tags: (
    /** @param {string[]} cycle */
    (cycle) => ({
      code: "cyclical-const-tags",
      message: `Cyclical dependency detected: ${cycle.join(" â†’ ")}`
    })
  ),
  invalid_component_style_directive: {
    code: "invalid-component-style-directive",
    message: "Style directives cannot be used on components"
  },
  invalid_var_declaration: {
    code: "invalid_var_declaration",
    message: '"var" scope should not extend outside the reactive block'
  },
  invalid_style_directive_modifier: (
    /** @param {string} valid */
    (valid) => ({
      code: "invalid-style-directive-modifier",
      message: `Valid modifiers for style directives are: ${valid}`
    })
  )
};

// node_modules/svelte/src/compiler/compile/nodes/shared/Expression.js
var regex_contains_term_function_expression = /FunctionExpression/;
var Expression = class {
  /**
   * @param {import('../../Component.js').default} component  *
   * @param {import('../interfaces.js').INode} owner  *
   * @param {import('./TemplateScope.js').default} template_scope  *
   * @param {import('estree').Node} info  *
   * @param {boolean} [lazy]  undefined
   */
  constructor(component, owner, template_scope, info, lazy) {
    /** @type {'Expression'} */
    __publicField(this, "type", "Expression");
    /** @type {import('../../Component.js').default} */
    __publicField(this, "component");
    /** @type {import('../interfaces.js').INode} */
    __publicField(this, "owner");
    /** @type {import('estree').Node} */
    __publicField(this, "node");
    /** @type {Set<string>} */
    __publicField(this, "references", /* @__PURE__ */ new Set());
    /**
     * Dependencies declared in the script block
     * @type {Set<string>}
     */
    __publicField(this, "dependencies", /* @__PURE__ */ new Set());
    /**
     * Dependencies declared in the HTML-like template section
     * @type {Set<string>}
     */
    __publicField(this, "contextual_dependencies", /* @__PURE__ */ new Set());
    /** @type {import('./TemplateScope.js').default} */
    __publicField(this, "template_scope");
    /** @type {import('../../utils/scope.js').Scope} */
    __publicField(this, "scope");
    /** @type {WeakMap<import('estree').Node, import('../../utils/scope.js').Scope>} */
    __publicField(this, "scope_map");
    /** @type {Array<import('estree').Node | import('estree').Node[]>} */
    __publicField(this, "declarations", []);
    /** @type {boolean} */
    __publicField(this, "uses_context", false);
    /** @type {import('estree').Node} */
    __publicField(this, "manipulated");
    Object.defineProperties(this, {
      component: {
        value: component
      }
    });
    this.node = info;
    this.template_scope = template_scope;
    this.owner = owner;
    const { dependencies, contextual_dependencies, references } = this;
    let { map, scope } = create_scopes(info);
    this.scope = scope;
    this.scope_map = map;
    const expression = this;
    let function_expression;
    walk(info, {
      /**
       * @param {any} node
       * @param {import('estree').Node} parent
       * @param {string} key
       */
      enter(node, parent, key) {
        if (key === "key" && /** @type {import('estree').Property} */
        parent.shorthand)
          return;
        if (node.type === "MetaProperty")
          return this.skip();
        if (map.has(node)) {
          scope = map.get(node);
        }
        if (!function_expression && regex_contains_term_function_expression.test(node.type)) {
          function_expression = node;
        }
        if (is_reference(node, parent)) {
          const { name: name8, nodes } = flatten_reference(node);
          references.add(name8);
          if (scope.has(name8))
            return;
          if (name8[0] === "$") {
            const store_name = name8.slice(1);
            if (template_scope.names.has(store_name) || scope.has(store_name)) {
              return component.error(node, compiler_errors_default.contextual_store);
            }
          }
          if (template_scope.is_let(name8)) {
            if (!lazy) {
              contextual_dependencies.add(name8);
              dependencies.add(name8);
            }
          } else if (template_scope.names.has(name8)) {
            expression.uses_context = true;
            contextual_dependencies.add(name8);
            const owner2 = template_scope.get_owner(name8);
            const is_index = owner2.type === "EachBlock" && owner2.key && name8 === owner2.index;
            if (!lazy || is_index) {
              template_scope.dependencies_for_name.get(name8).forEach((name9) => dependencies.add(name9));
            }
          } else {
            if (!lazy) {
              const variable = component.var_lookup.get(name8);
              if (!variable || !variable.imported || variable.mutated || variable.reassigned) {
                dependencies.add(name8);
              }
            }
            component.add_reference(node, name8);
            component.warn_if_undefined(name8, nodes[0], template_scope, owner);
          }
          this.skip();
        }
        let names;
        let deep = false;
        if (function_expression) {
          if (node.type === "AssignmentExpression") {
            deep = node.left.type === "MemberExpression";
            names = extract_names(deep ? get_object(node.left) : node.left);
          } else if (node.type === "UpdateExpression") {
            deep = node.argument.type === "MemberExpression";
            names = extract_names(get_object(node.argument));
          }
        }
        if (names) {
          names.forEach((name8) => {
            var _a;
            if (template_scope.names.has(name8)) {
              if (template_scope.is_const(name8)) {
                component.error(node, compiler_errors_default.invalid_const_update(name8));
              }
              template_scope.dependencies_for_name.get(name8).forEach((name9) => {
                const variable = component.var_lookup.get(name9);
                if (variable)
                  variable[deep ? "mutated" : "reassigned"] = true;
              });
              const each_block = template_scope.get_owner(name8);
              each_block.has_binding = true;
            } else {
              component.add_reference(node, name8);
              const variable = component.var_lookup.get(name8);
              if (variable) {
                variable[deep ? "mutated" : "reassigned"] = true;
              }
              const declaration = (_a = scope.find_owner(name8)) == null ? void 0 : _a.declarations.get(name8);
              if (declaration) {
                if (
                  /** @type {import('estree').VariableDeclaration} */
                  declaration.kind === "const" && !deep
                ) {
                  component.error(node, {
                    code: "assignment-to-const",
                    message: "You are assigning to a const"
                  });
                }
              } else if (variable && variable.writable === false && !deep) {
                component.error(node, {
                  code: "assignment-to-const",
                  message: "You are assigning to a const"
                });
              }
            }
          });
        }
      },
      /** @type {import('estree-walker').SyncHandler} */
      leave(node) {
        if (map.has(node)) {
          scope = scope.parent;
        }
        if (node === function_expression) {
          function_expression = null;
        }
      }
    });
  }
  dynamic_dependencies() {
    return Array.from(this.dependencies).filter((name8) => {
      if (this.template_scope.is_let(name8))
        return true;
      if (is_reserved_keyword(name8))
        return true;
      const variable = this.component.var_lookup.get(name8);
      return is_dynamic(variable);
    });
  }
  dynamic_contextual_dependencies() {
    return Array.from(this.contextual_dependencies).filter((name8) => {
      return Array.from(this.template_scope.dependencies_for_name.get(name8)).some(
        (variable_name) => {
          const variable = this.component.var_lookup.get(variable_name);
          return is_dynamic(variable);
        }
      );
    });
  }
  // TODO move this into a render-dom wrapper?
  /**
   * @param {import('../../render_dom/Block.js').default} [block]
   * @param {string | void} [ctx]
   */
  manipulate(block, ctx) {
    if (this.manipulated)
      return this.manipulated;
    const { component, declarations, scope_map: map, template_scope, owner } = this;
    let scope = this.scope;
    let function_expression;
    let dependencies;
    let contextual_dependencies;
    const node = walk(this.node, {
      /** @type {import('estree-walker').SyncHandler} */
      enter(node2, parent) {
        if (node2.type === "Property" && node2.shorthand) {
          node2.value = clone(node2.value);
          node2.shorthand = false;
        }
        if (map.has(node2)) {
          scope = map.get(node2);
        }
        if (node2.type === "Identifier" && is_reference(node2, parent)) {
          const { name: name8 } = flatten_reference(node2);
          if (scope.has(name8))
            return;
          if (function_expression) {
            if (template_scope.names.has(name8)) {
              contextual_dependencies.add(name8);
              template_scope.dependencies_for_name.get(name8).forEach((dependency) => {
                dependencies.add(dependency);
              });
            } else {
              dependencies.add(name8);
              component.add_reference(node2, name8);
            }
          } else if (is_contextual(component, template_scope, name8)) {
            const reference = block.renderer.reference(node2, ctx);
            this.replace(reference);
          }
          this.skip();
        }
        if (!function_expression) {
          if (node2.type === "AssignmentExpression") {
          }
          if (node2.type === "FunctionExpression" || node2.type === "ArrowFunctionExpression") {
            function_expression = node2;
            dependencies = /* @__PURE__ */ new Set();
            contextual_dependencies = /* @__PURE__ */ new Set();
          }
        }
      },
      /** @type {import('estree-walker').SyncHandler} */
      leave(node2, parent) {
        if (map.has(node2))
          scope = scope.parent;
        if (node2 === function_expression) {
          const id = component.get_unique_name(sanitize(get_function_name(node2, owner)));
          const declaration = b`const ${id} = ${node2}`;
          const extract_functions = () => {
            const deps = Array.from(contextual_dependencies);
            const function_expression2 = (
              /** @type {import('estree').FunctionExpression} */
              node2
            );
            const has_args = function_expression2.params.length > 0;
            function_expression2.params = [
              ...deps.map(
                (name8) => (
                  /** @type {import('estree').Identifier} */
                  { type: "Identifier", name: name8 }
                )
              ),
              ...function_expression2.params
            ];
            const context_args = deps.map((name8) => block.renderer.reference(name8, ctx));
            component.partly_hoisted.push(declaration);
            block.renderer.add_to_context(id.name);
            const callee = block.renderer.reference(id);
            this.replace(id);
            const func_declaration = has_args ? b`function ${id}(...args) {
								return ${callee}(${context_args}, ...args);
							}` : b`function ${id}() {
								return ${callee}(${context_args});
							}`;
            return { deps, func_declaration };
          };
          if (owner.type === "ConstTag") {
            if (contextual_dependencies.size === 0) {
              let child_scope = scope;
              walk(node2, {
                /** @type {import('estree-walker').SyncHandler} */
                enter(node3, parent2) {
                  if (map.has(node3))
                    child_scope = map.get(node3);
                  if (node3.type === "Identifier" && is_reference(node3, parent2)) {
                    if (child_scope.has(node3.name))
                      return;
                    this.replace(block.renderer.reference(node3, ctx));
                  }
                },
                /** @param {import('estree').Node} node */
                leave(node3) {
                  if (map.has(node3))
                    child_scope = child_scope.parent;
                }
              });
            } else {
              const { func_declaration } = extract_functions();
              this.replace(func_declaration[0]);
            }
          } else if (dependencies.size === 0 && contextual_dependencies.size === 0) {
            component.fully_hoisted.push(declaration);
            this.replace(id);
            component.add_var(node2, {
              name: id.name,
              internal: true,
              hoistable: true,
              referenced: true
            });
          } else if (contextual_dependencies.size === 0) {
            component.partly_hoisted.push(declaration);
            block.renderer.add_to_context(id.name);
            this.replace(block.renderer.reference(id));
          } else {
            const { deps, func_declaration } = extract_functions();
            if (owner.type === "Attribute" && owner.parent.name === "slot") {
              const dep_scopes = new Set(deps.map((name8) => template_scope.get_owner(name8)));
              let node3 = owner.parent;
              while (node3 && !dep_scopes.has(node3)) {
                node3 = node3.parent;
              }
              const func_expression = func_declaration[0];
              if (node3.type === "SlotTemplate") {
                this.replace(func_expression);
              } else {
                const func_id = component.get_unique_name(id.name + "_func");
                block.renderer.add_to_context(func_id.name, true);
                walk(func_expression, {
                  /** @param {import('estree').Node} node */
                  enter(node4) {
                    if (node4.type === "Identifier" && node4.name === "#ctx") {
                      node4.name = "child_ctx";
                    }
                  }
                });
                template_scope.get_owner(deps[0]).contexts.push({
                  type: "DestructuredVariable",
                  key: func_id,
                  modifier: () => func_expression,
                  default_modifier: (node4) => node4
                });
                this.replace(block.renderer.reference(func_id));
              }
            } else {
              declarations.push(func_declaration);
            }
          }
          function_expression = null;
          dependencies = null;
          contextual_dependencies = null;
          if (parent && parent.type === "Property") {
            parent.method = false;
          }
        }
        if (node2.type === "AssignmentExpression" || node2.type === "UpdateExpression") {
          const assignee = node2.type === "AssignmentExpression" ? node2.left : node2.argument;
          const object_name = get_object(assignee).name;
          if (scope.has(object_name))
            return;
          const names = new Set(extract_names(
            /** @type {import('estree').Node} */
            assignee
          ));
          const traced = /* @__PURE__ */ new Set();
          names.forEach((name8) => {
            const dependencies2 = template_scope.dependencies_for_name.get(name8);
            if (dependencies2) {
              dependencies2.forEach((name9) => traced.add(name9));
            } else {
              traced.add(name8);
            }
          });
          const context = block.bindings.get(object_name);
          if (context) {
            const { snippet, object, property } = context;
            const replaced = replace_object(assignee, snippet);
            if (node2.type === "AssignmentExpression") {
              node2.left = replaced;
            } else {
              node2.argument = replaced;
            }
            contextual_dependencies.add(object.name);
            contextual_dependencies.add(property.name);
          }
          this.replace(invalidate(block.renderer, scope, node2, traced));
        }
      }
    });
    if (declarations.length > 0) {
      block.maintain_context = true;
      declarations.forEach((declaration) => {
        block.chunks.init.push(declaration);
      });
    }
    return this.manipulated = /** @type {import('estree').Node} */
    node;
  }
};
function get_function_name(_node, parent) {
  if (parent.type === "EventHandler") {
    return `${parent.name}_handler`;
  }
  if (parent.type === "Action") {
    return `${parent.name}_function`;
  }
  return "func";
}

// node_modules/svelte/src/compiler/compile/nodes/shared/Context.js
function unpack_destructuring({
  contexts,
  node,
  modifier = (node2) => node2,
  default_modifier = (node2) => node2,
  scope,
  component,
  context_rest_properties,
  in_rest_element = false
}) {
  if (!node)
    return;
  if (node.type === "Identifier") {
    contexts.push({
      type: "DestructuredVariable",
      key: (
        /** @type {import('estree').Identifier} */
        node
      ),
      modifier,
      default_modifier
    });
    if (in_rest_element) {
      context_rest_properties.set(node.name, node);
    }
    component.used_names.add(node.name);
  } else if (node.type === "ArrayPattern") {
    node.elements.forEach((element, i) => {
      if (!element) {
        return;
      } else if (element.type === "RestElement") {
        unpack_destructuring({
          contexts,
          node: element.argument,
          modifier: (node2) => (
            /** @type {import('estree').Node} */
            x`${modifier(node2)}.slice(${i})`
          ),
          default_modifier,
          scope,
          component,
          context_rest_properties,
          in_rest_element: true
        });
      } else if (element.type === "AssignmentPattern") {
        const n = contexts.length;
        mark_referenced(element.right, scope, component);
        unpack_destructuring({
          contexts,
          node: element.left,
          modifier: (node2) => x`${modifier(node2)}[${i}]`,
          default_modifier: (node2, to_ctx) => (
            /** @type {import('estree').Node} */
            x`${node2} !== undefined ? ${node2} : ${update_reference(
              contexts,
              n,
              element.right,
              to_ctx
            )}`
          ),
          scope,
          component,
          context_rest_properties,
          in_rest_element
        });
      } else {
        unpack_destructuring({
          contexts,
          node: element,
          modifier: (node2) => (
            /** @type {import('estree').Node} */
            x`${modifier(node2)}[${i}]`
          ),
          default_modifier,
          scope,
          component,
          context_rest_properties,
          in_rest_element
        });
      }
    });
  } else if (node.type === "ObjectPattern") {
    const used_properties = [];
    node.properties.forEach((property) => {
      if (property.type === "RestElement") {
        unpack_destructuring({
          contexts,
          node: property.argument,
          modifier: (node2) => (
            /** @type {import('estree').Node} */
            x`@object_without_properties(${modifier(node2)}, [${used_properties}])`
          ),
          default_modifier,
          scope,
          component,
          context_rest_properties,
          in_rest_element: true
        });
      } else if (property.type === "Property") {
        const key = property.key;
        const value = property.value;
        let new_modifier;
        if (property.computed) {
          const property_name = component.get_unique_name("computed_property");
          contexts.push({
            type: "ComputedProperty",
            property_name,
            key
          });
          new_modifier = (node2) => x`${modifier(node2)}[${property_name}]`;
          used_properties.push(x`${property_name}`);
        } else if (key.type === "Identifier") {
          const property_name = key.name;
          new_modifier = (node2) => x`${modifier(node2)}.${property_name}`;
          used_properties.push(x`"${property_name}"`);
        } else if (key.type === "Literal") {
          const property_name = key.value;
          new_modifier = (node2) => x`${modifier(node2)}["${property_name}"]`;
          used_properties.push(x`"${property_name}"`);
        }
        if (value.type === "AssignmentPattern") {
          const n = contexts.length;
          mark_referenced(value.right, scope, component);
          unpack_destructuring({
            contexts,
            node: value.left,
            modifier: new_modifier,
            default_modifier: (node2, to_ctx) => (
              /** @type {import('estree').Node} */
              x`${node2} !== undefined ? ${node2} : ${update_reference(
                contexts,
                n,
                value.right,
                to_ctx
              )}`
            ),
            scope,
            component,
            context_rest_properties,
            in_rest_element
          });
        } else {
          unpack_destructuring({
            contexts,
            node: value,
            modifier: new_modifier,
            default_modifier,
            scope,
            component,
            context_rest_properties,
            in_rest_element
          });
        }
      }
    });
  }
}
function update_reference(contexts, n, expression, to_ctx) {
  const find_from_context = (node) => {
    for (let i = n; i < contexts.length; i++) {
      const cur_context = contexts[i];
      if (cur_context.type !== "DestructuredVariable")
        continue;
      const { key } = cur_context;
      if (node.name === key.name) {
        throw new Error(`Cannot access '${node.name}' before initialization`);
      }
    }
    return to_ctx(node.name);
  };
  if (expression.type === "Identifier") {
    return find_from_context(expression);
  }
  expression = /** @type {import('estree').Expression} */
  clone(expression);
  walk(expression, {
    enter(node, parent) {
      if (is_reference(
        /** @type {import('is-reference').NodeWithPropertyDefinition} */
        node,
        /** @type {import('is-reference').NodeWithPropertyDefinition} */
        parent
      )) {
        this.replace(find_from_context(
          /** @type {import('estree').Identifier} */
          node
        ));
        this.skip();
      }
    }
  });
  return expression;
}
function mark_referenced(node, scope, component) {
  walk(node, {
    enter(node2, parent) {
      if (is_reference(node2, parent)) {
        const { name: name8 } = flatten_reference(node2);
        if (!scope.is_let(name8) && !scope.names.has(name8)) {
          component.add_reference(node2, name8);
        }
      }
    }
  });
}

// node_modules/svelte/src/compiler/compile/nodes/ConstTag.js
var allowed_parents = /* @__PURE__ */ new Set([
  "EachBlock",
  "CatchBlock",
  "ThenBlock",
  "InlineComponent",
  "SlotTemplate",
  "IfBlock",
  "ElseBlock"
]);
var ConstTag = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./interfaces.js').INodeAllowConstTag} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').ConstTag} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {import('./shared/Context.js').Context[]} */
    __publicField(this, "contexts", []);
    /** @type {import('../../interfaces.js').ConstTag} */
    __publicField(this, "node");
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {Map<string, import('estree').Node>} */
    __publicField(this, "context_rest_properties", /* @__PURE__ */ new Map());
    /** @type {Set<string>} */
    __publicField(this, "assignees", /* @__PURE__ */ new Set());
    /** @type {Set<string>} */
    __publicField(this, "dependencies", /* @__PURE__ */ new Set());
    if (!allowed_parents.has(parent.type)) {
      component.error(info, compiler_errors_default.invalid_const_placement);
    }
    this.node = info;
    this.scope = scope;
    const { assignees, dependencies } = this;
    extract_identifiers(info.expression.left).forEach(({ name: name8 }) => {
      assignees.add(name8);
      const owner = this.scope.get_owner(name8);
      if (owner === parent) {
        component.error(info, compiler_errors_default.invalid_const_declaration(name8));
      }
    });
    walk(info.expression.right, {
      /**
       * @type {import('estree-walker').SyncHandler}
       */
      enter(node, parent2) {
        if (is_reference(
          /** @type {import('is-reference').NodeWithPropertyDefinition} */
          node,
          /** @type {import('is-reference').NodeWithPropertyDefinition} */
          parent2
        )) {
          const identifier = get_object(node);
          const { name: name8 } = identifier;
          dependencies.add(name8);
        }
      }
    });
  }
  parse_expression() {
    unpack_destructuring({
      contexts: this.contexts,
      node: this.node.expression.left,
      scope: this.scope,
      component: this.component,
      context_rest_properties: this.context_rest_properties
    });
    this.expression = new Expression(this.component, this, this.scope, this.node.expression.right);
    this.contexts.forEach((context) => {
      if (context.type !== "DestructuredVariable")
        return;
      const owner = this.scope.get_owner(context.key.name);
      if (owner && owner.type === "ConstTag" && owner.parent === this.parent) {
        this.component.error(
          this.node,
          compiler_errors_default.invalid_const_declaration(context.key.name)
        );
      }
      this.scope.add(context.key.name, this.expression.dependencies, this);
    });
  }
};

// node_modules/svelte/src/compiler/compile/nodes/PendingBlock.js
var PendingBlock = class extends AbstractBlock {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    this.children = map_children(component, parent, scope, info.children);
    if (!info.skip) {
      this.warn_if_empty_block();
    }
  }
};

// node_modules/svelte/src/compiler/compile/nodes/CatchBlock.js
var CatchBlock = class extends AbstractBlock {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./AwaitBlock.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {import('./ConstTag.js').default[]} */
    __publicField(this, "const_tags");
    this.scope = scope.child();
    if (parent.catch_node) {
      parent.catch_contexts.forEach((context) => {
        if (context.type !== "DestructuredVariable")
          return;
        this.scope.add(context.key.name, parent.expression.dependencies, this);
      });
    }
    [this.const_tags, this.children] = get_const_tags(info.children, component, this, parent);
    if (!info.skip) {
      this.warn_if_empty_block();
    }
  }
};

// node_modules/svelte/src/compiler/compile/nodes/AwaitBlock.js
var AwaitBlock = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {import('./shared/Context.js').Context[]} */
    __publicField(this, "then_contexts");
    /** @type {import('./shared/Context.js').Context[]} */
    __publicField(this, "catch_contexts");
    /** @type {import('estree').Node | null} */
    __publicField(this, "then_node");
    /** @type {import('estree').Node | null} */
    __publicField(this, "catch_node");
    /** @type {import('./PendingBlock.js').default} */
    __publicField(this, "pending");
    /** @type {import('./ThenBlock.js').default} */
    __publicField(this, "then");
    /** @type {import('./CatchBlock.js').default} */
    __publicField(this, "catch");
    /** @type {Map<string, import('estree').Node>} */
    __publicField(this, "context_rest_properties", /* @__PURE__ */ new Map());
    this.cannot_use_innerhtml();
    this.not_static_content();
    this.expression = new Expression(component, this, scope, info.expression);
    this.then_node = info.value;
    this.catch_node = info.error;
    if (this.then_node) {
      this.then_contexts = [];
      unpack_destructuring({
        contexts: this.then_contexts,
        node: info.value,
        scope,
        component,
        context_rest_properties: this.context_rest_properties
      });
    }
    if (this.catch_node) {
      this.catch_contexts = [];
      unpack_destructuring({
        contexts: this.catch_contexts,
        node: info.error,
        scope,
        component,
        context_rest_properties: this.context_rest_properties
      });
    }
    this.pending = new PendingBlock(component, this, scope, info.pending);
    this.then = new ThenBlock(component, this, scope, info.then);
    this.catch = new CatchBlock(component, this, scope, info.catch);
  }
};

// node_modules/svelte/src/compiler/compile/nodes/EventHandler.js
var regex_contains_term_function_expression2 = /FunctionExpression/;
var EventHandler = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} template_scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, template_scope, info) {
    super(component, parent, template_scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {Set<string>} */
    __publicField(this, "modifiers");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {import('estree').Identifier} */
    __publicField(this, "handler_name");
    /** */
    __publicField(this, "uses_context", false);
    /** */
    __publicField(this, "can_make_passive", false);
    this.name = info.name;
    this.modifiers = new Set(info.modifiers);
    if (info.expression) {
      this.expression = new Expression(component, this, template_scope, info.expression);
      this.uses_context = this.expression.uses_context;
      if (regex_contains_term_function_expression2.test(info.expression.type) && info.expression.params.length === 0) {
        this.can_make_passive = true;
      } else if (info.expression.type === "Identifier") {
        let node = component.node_for_declaration.get(info.expression.name);
        if (node) {
          if (node.type === "VariableDeclaration") {
            const declarator = node.declarations.find(
              (d) => (
                /** @type {import('estree').Identifier} */
                d.id.name === info.expression.name
              )
            );
            node = declarator && declarator.init;
          }
          if (node && (node.type === "FunctionExpression" || node.type === "FunctionDeclaration" || node.type === "ArrowFunctionExpression") && node.params.length === 0) {
            this.can_make_passive = true;
          }
        }
      }
    } else {
      this.handler_name = component.get_unique_name(`${sanitize(this.name)}_handler`);
    }
  }
  /** @returns {boolean} */
  get reassigned() {
    if (!this.expression) {
      return false;
    }
    const node = this.expression.node;
    if (regex_contains_term_function_expression2.test(node.type)) {
      return false;
    }
    return this.expression.dynamic_dependencies().length > 0;
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Action.js
var Action = class extends Node {
  /**
   * @param {import('../Component.js').default} component  *
   * @param {import('./shared/Node.js').default} parent  *
   * @param {import('./shared/TemplateScope.js').default} scope  *
   * @param {import('../../interfaces.js').Directive} info  undefined
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {boolean} */
    __publicField(this, "uses_context");
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "template_scope");
    const object = info.name.split(".")[0];
    component.warn_if_undefined(object, info, scope);
    this.name = info.name;
    component.add_reference(
      /** @type {any} */
      this,
      object
    );
    this.expression = info.expression ? new Expression(component, this, scope, info.expression) : null;
    this.template_scope = scope;
    this.uses_context = this.expression && this.expression.uses_context;
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Body.js
var Body = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').Element} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./EventHandler.js').default[]} */
    __publicField(this, "handlers", []);
    /** @type {import('./Action.js').default[]} */
    __publicField(this, "actions", []);
    info.attributes.forEach((node) => {
      if (node.type === "EventHandler") {
        this.handlers.push(new EventHandler(component, this, scope, node));
      } else if (node.type === "Action") {
        this.actions.push(new Action(component, this, scope, node));
      } else {
      }
    });
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Comment.js
var Comment2 = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "data");
    /** @type {string[]} */
    __publicField(this, "ignores");
    this.data = info.data;
    this.ignores = info.ignores;
  }
};

// node_modules/svelte/src/compiler/compile/nodes/ElseBlock.js
var ElseBlock = class extends AbstractBlock {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {import('./ConstTag.js').default[]} */
    __publicField(this, "const_tags");
    this.scope = scope.child();
    [this.const_tags, this.children] = get_const_tags(info.children, component, this, this);
    this.warn_if_empty_block();
  }
};

// node_modules/svelte/src/compiler/compile/nodes/EachBlock.js
var EachBlock = class extends AbstractBlock {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('estree').Node} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {import('estree').Node} */
    __publicField(this, "context_node");
    /** @type {string} */
    __publicField(this, "iterations");
    /** @type {string} */
    __publicField(this, "index");
    /** @type {string} */
    __publicField(this, "context");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "key");
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {import('./shared/Context.js').Context[]} */
    __publicField(this, "contexts");
    /** @type {import('./ConstTag.js').default[]} */
    __publicField(this, "const_tags");
    /** @type {boolean} */
    __publicField(this, "has_animation");
    /** */
    __publicField(this, "has_binding", false);
    /** */
    __publicField(this, "has_index_binding", false);
    /** @type {Map<string, import('estree').Node>} */
    __publicField(this, "context_rest_properties");
    /** @type {import('./ElseBlock.js').default} */
    __publicField(this, "else");
    this.cannot_use_innerhtml();
    this.not_static_content();
    this.expression = new Expression(component, this, scope, info.expression);
    this.context = info.context.name || "each";
    this.context_node = info.context;
    this.index = info.index;
    this.scope = scope.child();
    this.context_rest_properties = /* @__PURE__ */ new Map();
    this.contexts = [];
    unpack_destructuring({
      contexts: this.contexts,
      node: info.context,
      scope,
      component,
      context_rest_properties: this.context_rest_properties
    });
    this.contexts.forEach((context) => {
      if (context.type !== "DestructuredVariable")
        return;
      this.scope.add(context.key.name, this.expression.dependencies, this);
    });
    if (this.index) {
      const dependencies = info.key ? this.expression.dependencies : /* @__PURE__ */ new Set([]);
      this.scope.add(this.index, dependencies, this);
    }
    this.key = info.key ? new Expression(component, this, this.scope, info.key) : null;
    this.has_animation = false;
    [this.const_tags, this.children] = get_const_tags(info.children, component, this, this);
    if (this.has_animation) {
      this.children = this.children.filter(
        (child) => !is_empty_node(child) && !is_comment_node(child)
      );
      if (this.children.length !== 1) {
        const child = this.children.find(
          (child2) => !!/** @type {import('./Element.js').default} */
          child2.animation
        );
        component.error(
          /** @type {import('./Element.js').default} */
          child.animation,
          compiler_errors_default.invalid_animation_sole
        );
        return;
      }
    }
    this.warn_if_empty_block();
    this.else = info.else ? new ElseBlock(component, this, this.scope, info.else) : null;
  }
};
function is_empty_node(node) {
  return node.type === "Text" && node.data.trim() === "";
}
function is_comment_node(node) {
  return node.type === "Comment";
}

// node_modules/svelte/src/compiler/compile/nodes/Binding.js
var read_only_media_attributes = /* @__PURE__ */ new Set([
  "duration",
  "buffered",
  "seekable",
  "played",
  "seeking",
  "ended",
  "videoHeight",
  "videoWidth",
  "naturalWidth",
  "naturalHeight",
  "readyState"
]);
var Binding = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./Element.js').default | import('./InlineComponent.js').default | import('./Window.js').default | import('./Document.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {import('estree').Node} */
    __publicField(this, "raw_expression");
    // TODO exists only for bind:this â€” is there a more elegant solution?
    /** @type {boolean} */
    __publicField(this, "is_contextual");
    /** @type {boolean} */
    __publicField(this, "is_readonly");
    if (info.expression.type !== "Identifier" && info.expression.type !== "MemberExpression") {
      component.error(info, compiler_errors_default.invalid_directive_value);
      return;
    }
    this.name = info.name;
    this.expression = new Expression(component, this, scope, info.expression);
    this.raw_expression = clone(info.expression);
    const { name: name8 } = get_object(this.expression.node);
    this.is_contextual = Array.from(this.expression.references).some(
      (name9) => scope.names.has(name9)
    );
    if (this.is_contextual)
      this.validate_binding_rest_properties(scope);
    if (scope.is_let(name8)) {
      component.error(this, compiler_errors_default.invalid_binding_let);
      return;
    } else if (scope.names.has(name8)) {
      if (scope.is_await(name8)) {
        component.error(this, compiler_errors_default.invalid_binding_await);
        return;
      }
      if (scope.is_const(name8)) {
        component.error(this, compiler_errors_default.invalid_binding_const);
      }
      scope.dependencies_for_name.get(name8).forEach((name9) => {
        const variable = component.var_lookup.get(name9);
        if (variable) {
          variable.mutated = true;
        }
      });
    } else {
      const variable = component.var_lookup.get(name8);
      if (!variable || variable.global) {
        component.error(
          /** @type {any} */
          this.expression.node,
          compiler_errors_default.binding_undeclared(name8)
        );
        return;
      }
      variable[this.expression.node.type === "MemberExpression" ? "mutated" : "reassigned"] = true;
      if (info.expression.type === "Identifier" && !variable.writable) {
        component.error(
          /** @type {any} */
          this.expression.node,
          compiler_errors_default.invalid_binding_writable
        );
        return;
      }
    }
    const type = parent.get_static_attribute_value("type");
    this.is_readonly = regex_dimensions.test(this.name) || regex_box_size.test(this.name) || is_element(parent) && (parent.is_media_node() && read_only_media_attributes.has(this.name) || parent.name === "input" && type === "file");
  }
  is_readonly_media_attribute() {
    return read_only_media_attributes.has(this.name);
  }
  /** @param {import('./shared/TemplateScope.js').default} scope */
  validate_binding_rest_properties(scope) {
    this.expression.references.forEach((name8) => {
      const each_block = scope.get_owner(name8);
      if (each_block && each_block.type === "EachBlock") {
        const rest_node = each_block.context_rest_properties.get(name8);
        if (rest_node) {
          this.component.warn(
            /** @type {any} */
            rest_node,
            compiler_warnings_default.invalid_rest_eachblock_binding(name8)
          );
        }
      }
    });
  }
};
function is_element(node) {
  return !!/** @type {any} */
  node.is_media_node;
}

// node_modules/svelte/src/compiler/compile/nodes/Document.js
var valid_bindings = ["fullscreenElement", "visibilityState"];
var Document = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').Element} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./EventHandler.js').default[]} */
    __publicField(this, "handlers", []);
    /** @type {import('./Binding.js').default[]} */
    __publicField(this, "bindings", []);
    /** @type {import('./Action.js').default[]} */
    __publicField(this, "actions", []);
    info.attributes.forEach((node) => {
      if (node.type === "EventHandler") {
        this.handlers.push(new EventHandler(component, this, scope, node));
      } else if (node.type === "Binding") {
        if (!~valid_bindings.indexOf(node.name)) {
          const match = fuzzymatch(node.name, valid_bindings);
          if (match) {
            return component.error(
              node,
              compiler_errors_default.invalid_binding_on(
                node.name,
                "<svelte:document>",
                ` (did you mean '${match}'?)`
              )
            );
          } else {
            return component.error(
              node,
              compiler_errors_default.invalid_binding_on(
                node.name,
                "<svelte:document>",
                ` â€” valid bindings are ${list(valid_bindings)}`
              )
            );
          }
        }
        this.bindings.push(new Binding(component, this, scope, node));
      } else if (node.type === "Action") {
        this.actions.push(new Action(component, this, scope, node));
      } else {
      }
    });
    this.validate();
  }
  /** @private */
  validate() {
    const handlers_map = /* @__PURE__ */ new Set();
    this.handlers.forEach((handler) => handlers_map.add(handler.name));
    if (handlers_map.has("mouseenter") || handlers_map.has("mouseleave")) {
      this.component.warn(this, compiler_warnings_default.avoid_mouse_events_on_document);
    }
  }
};

// node_modules/svelte/src/compiler/compile/utils/stringify.js
function string_literal(data) {
  return {
    type: "Literal",
    value: data
  };
}
var escaped = {
  '"': "&quot;",
  "'": "&#39;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
var regex_html_characters_to_escape = /["'&<>]/g;
function escape_html(html2) {
  return String(html2).replace(regex_html_characters_to_escape, (match) => escaped[match]);
}
var regex_template_characters_to_escape = /(\${|`|\\)/g;
function escape_template(str) {
  return str.replace(regex_template_characters_to_escape, "\\$1");
}

// node_modules/svelte/src/compiler/compile/utils/add_to_set.js
function add_to_set(a, b2) {
  b2.forEach((item) => {
    a.add(item);
  });
}

// node_modules/svelte/src/compiler/compile/nodes/Attribute.js
var Attribute = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {string} */
    __publicField(this, "name");
    /** @type {boolean} */
    __publicField(this, "is_spread");
    /** @type {boolean} */
    __publicField(this, "is_true");
    /** @type {boolean} */
    __publicField(this, "is_static");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {Array<import('./Text.js').default | import('./shared/Expression.js').default>} */
    __publicField(this, "chunks");
    /** @type {Set<string>} */
    __publicField(this, "dependencies");
    this.scope = scope;
    if (info.type === "Spread") {
      this.name = null;
      this.is_spread = true;
      this.is_true = false;
      this.expression = new Expression(component, this, scope, info.expression);
      this.dependencies = this.expression.dependencies;
      this.chunks = null;
      this.is_static = false;
    } else {
      this.name = info.name;
      this.is_true = info.value === true;
      this.is_static = true;
      this.dependencies = /* @__PURE__ */ new Set();
      this.chunks = this.is_true ? [] : info.value.map((node) => {
        if (node.type === "Text")
          return node;
        this.is_static = false;
        const expression = new Expression(component, this, scope, node.expression);
        add_to_set(this.dependencies, expression.dependencies);
        return expression;
      });
    }
    if (this.dependencies.size > 0) {
      parent.cannot_use_innerhtml();
      parent.not_static_content();
    }
    if (this.name && this.name.includes(":") && !this.name.startsWith("xmlns:") && !this.name.startsWith("xlink:") && !this.name.startsWith("xml:")) {
      component.warn(this, compiler_warnings_default.illegal_attribute_character);
    }
  }
  get_dependencies() {
    if (this.is_spread)
      return this.expression.dynamic_dependencies();
    const dependencies = /* @__PURE__ */ new Set();
    this.chunks.forEach((chunk) => {
      if (chunk.type === "Expression") {
        add_to_set(dependencies, chunk.dynamic_dependencies());
      }
    });
    return Array.from(dependencies);
  }
  /** @param {any} block */
  get_value(block) {
    if (this.is_true)
      return x`true`;
    if (this.chunks.length === 0)
      return x`""`;
    if (this.chunks.length === 1) {
      return this.chunks[0].type === "Text" ? string_literal(
        /** @type {import('./Text.js').default} */
        this.chunks[0].data
      ) : (
        /** @type {import('./shared/Expression.js').default} */
        this.chunks[0].manipulate(
          block
        )
      );
    }
    let expression = this.chunks.map(
      /** @param {any} chunk */
      (chunk) => chunk.type === "Text" ? string_literal(chunk.data) : chunk.manipulate(block)
    ).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
    if (this.chunks[0].type !== "Text") {
      expression = x`"" + ${expression}`;
    }
    return expression;
  }
  get_static_value() {
    if (!this.is_static)
      return null;
    return this.is_true ? true : this.chunks[0] ? (
      // method should be called only when `is_static = true`
      /** @type {import('./Text.js').default} */
      this.chunks[0].data
    ) : "";
  }
  should_cache() {
    return this.is_static ? false : this.chunks.length === 1 ? (
      // @ts-ignore todo: probably error
      this.chunks[0].node.type !== "Identifier" || this.scope.names.has(this.chunks[0].node.name)
    ) : true;
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Transition.js
var Transition = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./Element.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {string} */
    __publicField(this, "directive");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {boolean} */
    __publicField(this, "is_local");
    component.warn_if_undefined(info.name, info, scope);
    this.name = info.name;
    component.add_reference(
      /** @type {any} */
      this,
      info.name.split(".")[0]
    );
    this.directive = info.intro && info.outro ? "transition" : info.intro ? "in" : "out";
    this.is_local = !info.modifiers.includes("global");
    if (info.intro && parent.intro || info.outro && parent.outro) {
      const parent_transition = parent.intro || parent.outro;
      component.error(
        info,
        compiler_errors_default.duplicate_transition(this.directive, parent_transition.directive)
      );
      return;
    }
    this.expression = info.expression ? new Expression(component, this, scope, info.expression) : null;
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Animation.js
var Animation = class extends Node {
  /**
   * @param {import('../Component.js').default} component  *
   * @param {import('./Element.js').default} parent  *
   * @param {import('./shared/TemplateScope.js').default} scope  *
   * @param {import('../../interfaces.js').TemplateNode} info  undefined
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    component.warn_if_undefined(info.name, info, scope);
    this.name = info.name;
    component.add_reference(
      /** @type {any} */
      this,
      info.name.split(".")[0]
    );
    if (parent.animation) {
      component.error(this, compiler_errors_default.duplicate_animation);
      return;
    }
    const block = parent.parent;
    if (!block || block.type !== "EachBlock") {
      component.error(this, compiler_errors_default.invalid_animation_immediate);
      return;
    }
    if (!block.key) {
      component.error(this, compiler_errors_default.invalid_animation_key);
      return;
    }
    block.has_animation = true;
    this.expression = info.expression ? new Expression(component, this, scope, info.expression, true) : null;
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Class.js
var Class = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    this.name = info.name;
    this.expression = info.expression ? new Expression(component, this, scope, info.expression) : null;
  }
};

// node_modules/svelte/src/compiler/compile/utils/nodes_to_template_literal.js
function nodes_to_template_literal(value) {
  const literal = {
    type: "TemplateLiteral",
    expressions: [],
    quasis: []
  };
  let quasi = {
    type: "TemplateElement",
    value: { raw: "", cooked: null },
    tail: false
  };
  value.forEach((node) => {
    if (node.type === "Text") {
      quasi.value.raw += node.raw;
    } else if (node.type === "MustacheTag") {
      literal.quasis.push(quasi);
      literal.expressions.push(
        /** @type {any} */
        node.expression
      );
      quasi = {
        type: "TemplateElement",
        value: { raw: "", cooked: null },
        tail: false
      };
    }
  });
  quasi.tail = true;
  literal.quasis.push(quasi);
  return literal;
}

// node_modules/svelte/src/compiler/compile/nodes/StyleDirective.js
var valid_modifiers = /* @__PURE__ */ new Set(["important"]);
var StyleDirective = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {Set<string>} */
    __publicField(this, "modifiers");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {boolean} */
    __publicField(this, "should_cache");
    this.name = info.name;
    this.modifiers = new Set(info.modifiers);
    for (const modifier of this.modifiers) {
      if (!valid_modifiers.has(modifier)) {
        component.error(
          this,
          compiler_errors_default.invalid_style_directive_modifier(list([...valid_modifiers]))
        );
      }
    }
    if (info.value === true || info.value.length === 1 && info.value[0].type === "MustacheTag") {
      const identifier = info.value === true ? {
        type: "Identifier",
        start: info.end - info.name.length,
        end: info.end,
        name: info.name
      } : info.value[0].expression;
      this.expression = new Expression(component, this, scope, identifier);
      this.should_cache = false;
    } else {
      const raw_expression = nodes_to_template_literal(info.value);
      this.expression = new Expression(component, this, scope, raw_expression);
      this.should_cache = raw_expression.expressions.length > 0;
    }
  }
  get important() {
    return this.modifiers.has("important");
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Text.js
var elements_without_text = /* @__PURE__ */ new Set(["audio", "datalist", "dl", "optgroup", "select", "video"]);
var regex_ends_with_svg = /svg$/;
var regex_non_whitespace_characters2 = /[\S\u00A0]/;
var Text = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./interfaces.js').INode} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "data");
    /** @type {boolean} */
    __publicField(this, "synthetic");
    this.data = info.data;
    this.synthetic = info.synthetic || false;
  }
  should_skip() {
    if (regex_non_whitespace_character.test(this.data))
      return false;
    const parent_element = this.find_nearest(/(?:Element|InlineComponent|SlotTemplate|Head)/);
    if (!parent_element)
      return false;
    if (parent_element.type === "Head")
      return true;
    if (parent_element.type === "InlineComponent")
      return parent_element.children.length === 1 && this === parent_element.children[0];
    if (regex_ends_with_svg.test(parent_element.namespace)) {
      if (this.prev && this.prev.type === "Element" && this.prev.name === "tspan")
        return false;
    }
    return parent_element.namespace || elements_without_text.has(parent_element.name);
  }
  /** @returns {boolean} */
  keep_space() {
    if (this.component.component_options.preserveWhitespace)
      return true;
    return this.within_pre();
  }
  /** @returns {boolean} */
  within_pre() {
    let node = this.parent;
    while (node) {
      if (node.type === "Element" && node.name === "pre") {
        return true;
      }
      node = node.parent;
    }
    return false;
  }
  /** @returns {boolean} */
  use_space() {
    if (this.component.compile_options.preserveWhitespace)
      return false;
    if (regex_non_whitespace_characters2.test(this.data))
      return false;
    return !this.within_pre();
  }
};

// node_modules/svelte/src/compiler/utils/namespaces.js
var foreign = "https://svelte.dev/docs/special-elements#svelte-options";
var html = "http://www.w3.org/1999/xhtml";
var mathml = "http://www.w3.org/1998/Math/MathML";
var svg = "http://www.w3.org/2000/svg";
var xlink = "http://www.w3.org/1999/xlink";
var xml = "http://www.w3.org/XML/1998/namespace";
var xmlns = "http://www.w3.org/2000/xmlns";
var valid_namespaces = [
  "foreign",
  "html",
  "mathml",
  "svg",
  "xlink",
  "xml",
  "xmlns",
  foreign,
  html,
  mathml,
  svg,
  xlink,
  xml,
  xmlns
];
var namespaces = (
  /** @type {const} */
  { foreign, html, mathml, svg, xlink, xml, xmlns }
);

// node_modules/svelte/src/compiler/compile/utils/contenteditable.js
var CONTENTEDITABLE_BINDINGS = ["textContent", "innerHTML", "innerText"];
function is_input_or_textarea(node) {
  return node.name === "textarea" || node.name === "input";
}
function is_attr_contenteditable(attribute) {
  return attribute.name === "contenteditable";
}
function has_contenteditable_attr(node) {
  return node.attributes.some(is_attr_contenteditable);
}
function is_contenteditable(node) {
  return !is_input_or_textarea(node) && has_contenteditable_attr(node);
}
function is_name_contenteditable(name8) {
  return CONTENTEDITABLE_BINDINGS.includes(name8);
}
function get_contenteditable_attr(node) {
  return node.attributes.find(is_attr_contenteditable);
}

// node_modules/svelte/src/compiler/compile/utils/hash.js
var regex_return_characters = /\r/g;
function hash(str) {
  str = str.replace(regex_return_characters, "");
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return (hash2 >>> 0).toString(36);
}

// node_modules/svelte/src/compiler/compile/nodes/Let.js
var applicable = /* @__PURE__ */ new Set(["Identifier", "ObjectExpression", "ArrayExpression", "Property"]);
var Let = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('estree').Identifier} */
    __publicField(this, "name");
    /** @type {import('estree').Identifier} */
    __publicField(this, "value");
    /** @type {string[]} */
    __publicField(this, "names", []);
    this.name = { type: "Identifier", name: info.name };
    const { names } = this;
    if (info.expression) {
      this.value = info.expression;
      walk(info.expression, {
        /** @param {import('estree').Identifier | import('estree').BasePattern} node */
        enter(node) {
          if (!applicable.has(node.type)) {
            return component.error(
              /** @type {any} */
              node,
              compiler_errors_default.invalid_let
            );
          }
          if (node.type === "Identifier") {
            names.push(
              /** @type {import('estree').Identifier} */
              node.name
            );
          }
          if (node.type === "ArrayExpression") {
            node.type = "ArrayPattern";
          }
          if (node.type === "ObjectExpression") {
            node.type = "ObjectPattern";
          }
        }
      });
    } else {
      names.push(this.name.name);
    }
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Element.js
var import_aria_query2 = __toESM(require_lib(), 1);

// node_modules/svelte/src/compiler/compile/utils/a11y.js
var import_aria_query = __toESM(require_lib(), 1);
var import_axobject_query = __toESM(require_lib2(), 1);
var aria_roles = import_aria_query.roles.keys();
var abstract_roles = new Set(aria_roles.filter((role) => import_aria_query.roles.get(role).abstract));
var non_abstract_roles = aria_roles.filter((name8) => !abstract_roles.has(name8));
var non_interactive_roles = new Set(
  non_abstract_roles.filter((name8) => {
    const role = import_aria_query.roles.get(name8);
    return (
      // 'toolbar' does not descend from widget, but it does support
      // aria-activedescendant, thus in practice we treat it as a widget.
      // focusable tabpanel elements are recommended if any panels in a set contain content where the first element in the panel is not focusable.
      // 'generic' is meant to have no semantic meaning.
      // 'cell' is treated as CellRole by the AXObject which is interactive, so we treat 'cell' it as interactive as well.
      !["toolbar", "tabpanel", "generic", "cell"].includes(name8) && !role.superClass.some((classes) => classes.includes("widget"))
    );
  }).concat(
    // The `progressbar` is descended from `widget`, but in practice, its
    // value is always `readonly`, so we treat it as a non-interactive role.
    "progressbar"
  )
);
var interactive_roles = new Set(
  non_abstract_roles.filter(
    (name8) => !non_interactive_roles.has(name8) && // 'generic' is meant to have no semantic meaning.
    name8 !== "generic"
  )
);
function is_non_interactive_roles(role) {
  return non_interactive_roles.has(role);
}
function is_interactive_roles(role) {
  return interactive_roles.has(role);
}
function is_abstract_role(role) {
  return abstract_roles.has(role);
}
var presentation_roles = /* @__PURE__ */ new Set(["presentation", "none"]);
function is_presentation_role(role) {
  return presentation_roles.has(role);
}
function is_hidden_from_screen_reader(tag_name, attribute_map) {
  var _a;
  if (tag_name === "input") {
    const type = (_a = attribute_map.get("type")) == null ? void 0 : _a.get_static_value();
    if (type && type === "hidden") {
      return true;
    }
  }
  const aria_hidden = attribute_map.get("aria-hidden");
  if (!aria_hidden)
    return false;
  if (!aria_hidden.is_static)
    return true;
  const aria_hidden_value = aria_hidden.get_static_value();
  return aria_hidden_value === true || aria_hidden_value === "true";
}
function has_disabled_attribute(attribute_map) {
  const disabled_attr = attribute_map.get("disabled");
  const disabled_attr_value = disabled_attr && disabled_attr.get_static_value();
  if (disabled_attr_value) {
    return true;
  }
  const aria_disabled_attr = attribute_map.get("aria-disabled");
  if (aria_disabled_attr) {
    const aria_disabled_attr_value = aria_disabled_attr.get_static_value();
    if (aria_disabled_attr_value === true) {
      return true;
    }
  }
  return false;
}
var non_interactive_element_role_schemas = [];
import_aria_query.elementRoles.entries().forEach(([schema, roles2]) => {
  if ([...roles2].every((role) => role !== "generic" && non_interactive_roles.has(role))) {
    non_interactive_element_role_schemas.push(schema);
  }
});
var interactive_element_role_schemas = [];
import_aria_query.elementRoles.entries().forEach(([schema, roles2]) => {
  if ([...roles2].every((role) => interactive_roles.has(role))) {
    interactive_element_role_schemas.push(schema);
  }
});
var interactive_ax_objects = new Set(
  [...import_axobject_query.AXObjects.keys()].filter((name8) => import_axobject_query.AXObjects.get(name8).type === "widget")
);
var non_interactive_ax_objects = new Set(
  [...import_axobject_query.AXObjects.keys()].filter(
    (name8) => ["windows", "structure"].includes(import_axobject_query.AXObjects.get(name8).type)
  )
);
var interactive_element_ax_object_schemas = [];
import_axobject_query.elementAXObjects.entries().forEach(([schema, ax_object]) => {
  if ([...ax_object].every((role) => interactive_ax_objects.has(role))) {
    interactive_element_ax_object_schemas.push(schema);
  }
});
var non_interactive_element_ax_object_schemas = [];
import_axobject_query.elementAXObjects.entries().forEach(([schema, ax_object]) => {
  if ([...ax_object].every((role) => non_interactive_ax_objects.has(role))) {
    non_interactive_element_ax_object_schemas.push(schema);
  }
});
function match_schema(schema, tag_name, attribute_map) {
  if (schema.name !== tag_name)
    return false;
  if (!schema.attributes)
    return true;
  return schema.attributes.every((schema_attribute) => {
    const attribute = attribute_map.get(schema_attribute.name);
    if (!attribute)
      return false;
    if (schema_attribute.value && schema_attribute.value !== attribute.get_static_value()) {
      return false;
    }
    return true;
  });
}
var ElementInteractivity = (
  /** @type {const} */
  {
    Interactive: "interactive",
    NonInteractive: "non-interactive",
    Static: "static"
  }
);
function element_interactivity(tag_name, attribute_map) {
  if (interactive_element_role_schemas.some((schema) => match_schema(schema, tag_name, attribute_map))) {
    return ElementInteractivity.Interactive;
  }
  if (tag_name !== "header" && non_interactive_element_role_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.NonInteractive;
  }
  if (interactive_element_ax_object_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.Interactive;
  }
  if (non_interactive_element_ax_object_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.NonInteractive;
  }
  return ElementInteractivity.Static;
}
function is_interactive_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Interactive;
}
function is_non_interactive_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.NonInteractive;
}
function is_static_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Static;
}
function is_semantic_role_element(role, tag_name, attribute_map) {
  for (const [schema, ax_object] of import_axobject_query.elementAXObjects.entries()) {
    if (schema.name === tag_name && (!schema.attributes || schema.attributes.every(
      (attr) => attribute_map.has(attr.name) && attribute_map.get(attr.name).get_static_value() === attr.value
    ))) {
      for (const name8 of ax_object) {
        const roles2 = import_axobject_query.AXObjectRoles.get(name8);
        if (roles2) {
          for (const { name: name9 } of roles2) {
            if (name9 === role) {
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}
var address_type_tokens = /* @__PURE__ */ new Set(["shipping", "billing"]);
var autofill_field_name_tokens = /* @__PURE__ */ new Set([
  "",
  "on",
  "off",
  "name",
  "honorific-prefix",
  "given-name",
  "additional-name",
  "family-name",
  "honorific-suffix",
  "nickname",
  "username",
  "new-password",
  "current-password",
  "one-time-code",
  "organization-title",
  "organization",
  "street-address",
  "address-line1",
  "address-line2",
  "address-line3",
  "address-level4",
  "address-level3",
  "address-level2",
  "address-level1",
  "country",
  "country-name",
  "postal-code",
  "cc-name",
  "cc-given-name",
  "cc-additional-name",
  "cc-family-name",
  "cc-number",
  "cc-exp",
  "cc-exp-month",
  "cc-exp-year",
  "cc-csc",
  "cc-type",
  "transaction-currency",
  "transaction-amount",
  "language",
  "bday",
  "bday-day",
  "bday-month",
  "bday-year",
  "sex",
  "url",
  "photo"
]);
var contact_type_tokens = /* @__PURE__ */ new Set(["home", "work", "mobile", "fax", "pager"]);
var autofill_contact_field_name_tokens = /* @__PURE__ */ new Set([
  "tel",
  "tel-country-code",
  "tel-national",
  "tel-area-code",
  "tel-local",
  "tel-local-prefix",
  "tel-local-suffix",
  "tel-extension",
  "email",
  "impp"
]);
function is_valid_autocomplete(autocomplete) {
  if (autocomplete === true) {
    return false;
  } else if (!autocomplete) {
    return true;
  }
  const tokens = autocomplete.trim().toLowerCase().split(regex_whitespaces);
  if (typeof tokens[0] === "string" && tokens[0].startsWith("section-")) {
    tokens.shift();
  }
  if (address_type_tokens.has(tokens[0])) {
    tokens.shift();
  }
  if (autofill_field_name_tokens.has(tokens[0])) {
    tokens.shift();
  } else {
    if (contact_type_tokens.has(tokens[0])) {
      tokens.shift();
    }
    if (autofill_contact_field_name_tokens.has(tokens[0])) {
      tokens.shift();
    } else {
      return false;
    }
  }
  if (tokens[0] === "webauthn") {
    tokens.shift();
  }
  return tokens.length === 0;
}

// node_modules/svelte/src/compiler/compile/nodes/Element.js
var aria_attributes = "activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext".split(
  " "
);
var aria_attribute_set = new Set(aria_attributes);
var aria_roles2 = import_aria_query2.roles.keys();
var aria_role_set = new Set(aria_roles2);
var a11y_required_attributes = {
  a: ["href"],
  area: ["alt", "aria-label", "aria-labelledby"],
  // html-has-lang
  html: ["lang"],
  // iframe-has-title
  iframe: ["title"],
  img: ["alt"],
  object: ["title", "aria-label", "aria-labelledby"]
};
var a11y_distracting_elements = /* @__PURE__ */ new Set(["blink", "marquee"]);
var a11y_required_content = /* @__PURE__ */ new Set([
  // anchor-has-content
  "a",
  // heading-has-content
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6"
]);
var a11y_labelable = /* @__PURE__ */ new Set([
  "button",
  "input",
  "keygen",
  "meter",
  "output",
  "progress",
  "select",
  "textarea"
]);
var a11y_interactive_handlers = /* @__PURE__ */ new Set([
  // Keyboard events
  "keypress",
  "keydown",
  "keyup",
  // Click events
  "click",
  "contextmenu",
  "dblclick",
  "drag",
  "dragend",
  "dragenter",
  "dragexit",
  "dragleave",
  "dragover",
  "dragstart",
  "drop",
  "mousedown",
  "mouseenter",
  "mouseleave",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup"
]);
var a11y_recommended_interactive_handlers = /* @__PURE__ */ new Set([
  "click",
  "mousedown",
  "mouseup",
  "keypress",
  "keydown",
  "keyup"
]);
var a11y_nested_implicit_semantics = /* @__PURE__ */ new Map([
  ["header", "banner"],
  ["footer", "contentinfo"]
]);
var a11y_implicit_semantics = /* @__PURE__ */ new Map([
  ["a", "link"],
  ["area", "link"],
  ["article", "article"],
  ["aside", "complementary"],
  ["body", "document"],
  ["button", "button"],
  ["datalist", "listbox"],
  ["dd", "definition"],
  ["dfn", "term"],
  ["dialog", "dialog"],
  ["details", "group"],
  ["dt", "term"],
  ["fieldset", "group"],
  ["figure", "figure"],
  ["form", "form"],
  ["h1", "heading"],
  ["h2", "heading"],
  ["h3", "heading"],
  ["h4", "heading"],
  ["h5", "heading"],
  ["h6", "heading"],
  ["hr", "separator"],
  ["img", "img"],
  ["li", "listitem"],
  ["link", "link"],
  ["main", "main"],
  ["menu", "list"],
  ["meter", "progressbar"],
  ["nav", "navigation"],
  ["ol", "list"],
  ["option", "option"],
  ["optgroup", "group"],
  ["output", "status"],
  ["progress", "progressbar"],
  ["section", "region"],
  ["summary", "button"],
  ["table", "table"],
  ["tbody", "rowgroup"],
  ["textarea", "textbox"],
  ["tfoot", "rowgroup"],
  ["thead", "rowgroup"],
  ["tr", "row"],
  ["ul", "list"]
]);
var menuitem_type_to_implicit_role = /* @__PURE__ */ new Map([
  ["command", "menuitem"],
  ["checkbox", "menuitemcheckbox"],
  ["radio", "menuitemradio"]
]);
var input_type_to_implicit_role = /* @__PURE__ */ new Map([
  ["button", "button"],
  ["image", "button"],
  ["reset", "button"],
  ["submit", "button"],
  ["checkbox", "checkbox"],
  ["radio", "radio"],
  ["range", "slider"],
  ["number", "spinbutton"],
  ["email", "textbox"],
  ["search", "searchbox"],
  ["tel", "textbox"],
  ["text", "textbox"],
  ["url", "textbox"]
]);
var a11y_non_interactive_element_to_interactive_role_exceptions = {
  ul: ["listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"],
  ol: ["listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"],
  li: ["menuitem", "option", "row", "tab", "treeitem"],
  table: ["grid"],
  td: ["gridcell"],
  fieldset: ["radiogroup", "presentation"]
};
var combobox_if_list = /* @__PURE__ */ new Set(["email", "search", "tel", "text", "url"]);
function input_implicit_role(attribute_map) {
  const type_attribute = attribute_map.get("type");
  if (!type_attribute || !type_attribute.is_static)
    return;
  const type = (
    /** @type {string} */
    type_attribute.get_static_value()
  );
  const list_attribute_exists = attribute_map.has("list");
  if (list_attribute_exists && combobox_if_list.has(type)) {
    return "combobox";
  }
  return input_type_to_implicit_role.get(type);
}
function menuitem_implicit_role(attribute_map) {
  const type_attribute = attribute_map.get("type");
  if (!type_attribute || !type_attribute.is_static)
    return;
  const type = (
    /** @type {string} */
    type_attribute.get_static_value()
  );
  return menuitem_type_to_implicit_role.get(type);
}
function get_implicit_role(name8, attribute_map) {
  if (name8 === "menuitem") {
    return menuitem_implicit_role(attribute_map);
  } else if (name8 === "input") {
    return input_implicit_role(attribute_map);
  } else {
    return a11y_implicit_semantics.get(name8);
  }
}
var invisible_elements = /* @__PURE__ */ new Set(["meta", "html", "script", "style"]);
var valid_modifiers2 = /* @__PURE__ */ new Set([
  "preventDefault",
  "stopPropagation",
  "stopImmediatePropagation",
  "capture",
  "once",
  "passive",
  "nonpassive",
  "self",
  "trusted"
]);
var passive_events = /* @__PURE__ */ new Set(["wheel", "touchstart", "touchmove", "touchend", "touchcancel"]);
var react_attributes = /* @__PURE__ */ new Map([
  ["className", "class"],
  ["htmlFor", "for"]
]);
var attributes_to_compact_whitespace = ["class", "style"];
function is_parent(parent, elements) {
  let check = false;
  while (parent) {
    const parent_name = (
      /** @type {Element} */
      parent.name
    );
    if (elements.includes(parent_name)) {
      check = true;
      break;
    }
    if (parent.type === "Element") {
      break;
    }
    parent = parent.parent;
  }
  return check;
}
function get_namespace(parent, element, explicit_namespace) {
  const parent_element = parent.find_nearest(/^Element/);
  if (!parent_element) {
    return explicit_namespace || (is_svg(element.name) ? namespaces.svg : null);
  }
  if (parent_element.namespace !== namespaces.foreign) {
    if (is_svg(element.name.toLowerCase()))
      return namespaces.svg;
    if (parent_element.name.toLowerCase() === "foreignobject")
      return null;
  }
  return parent_element.namespace;
}
function is_valid_aria_attribute_value(schema, value) {
  switch (schema.type) {
    case "boolean":
      return typeof value === "boolean";
    case "string":
    case "id":
      return typeof value === "string";
    case "tristate":
      return typeof value === "boolean" || value === "mixed";
    case "integer":
    case "number":
      return typeof value !== "boolean" && isNaN(Number(value)) === false;
    case "token":
      return (schema.values || []).indexOf(typeof value === "string" ? value.toLowerCase() : value) > -1;
    case "idlist":
      return typeof value === "string" && value.split(regex_any_repeated_whitespaces).every((id) => typeof id === "string");
    case "tokenlist":
      return typeof value === "string" && value.split(regex_any_repeated_whitespaces).every((token) => (schema.values || []).indexOf(token.toLowerCase()) > -1);
    default:
      return false;
  }
}
var regex_any_repeated_whitespaces = /[\s]+/g;
var regex_heading_tags = /^h[1-6]$/;
var regex_illegal_attribute_character = /(^[0-9-.])|[\^$@%&#?!|()[\]{}^*+~;]/;
var Element = class _Element extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {any} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {import('./Action.js').default[]} */
    __publicField(this, "actions", []);
    /** @type {import('./Binding.js').default[]} */
    __publicField(this, "bindings", []);
    /** @type {import('./Class.js').default[]} */
    __publicField(this, "classes", []);
    /** @type {import('./StyleDirective.js').default[]} */
    __publicField(this, "styles", []);
    /** @type {import('./EventHandler.js').default[]} */
    __publicField(this, "handlers", []);
    /** @type {import('./Let.js').default[]} */
    __publicField(this, "lets", []);
    /** @type {import('./Transition.js').default} */
    __publicField(this, "intro", null);
    /** @type {import('./Transition.js').default} */
    __publicField(this, "outro", null);
    /** @type {import('./Animation.js').default} */
    __publicField(this, "animation", null);
    /** @type {import('./interfaces.js').INode[]} */
    __publicField(this, "children");
    /** @type {string} */
    __publicField(this, "namespace");
    /** @type {boolean} */
    __publicField(this, "needs_manual_style_scoping");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "tag_expr");
    /** @type {boolean} */
    __publicField(this, "contains_a11y_label");
    this.name = info.name;
    if (info.name === "svelte:element") {
      if (typeof info.tag !== "string") {
        this.tag_expr = new Expression(component, this, scope, info.tag);
      } else {
        this.tag_expr = new Expression(
          component,
          this,
          scope,
          /** @type {import('estree').Literal} */
          string_literal(info.tag)
        );
        this.name = info.tag;
      }
    } else {
      this.tag_expr = new Expression(
        component,
        this,
        scope,
        /** @type {import('estree').Literal} */
        string_literal(this.name)
      );
    }
    this.namespace = get_namespace(
      /** @type {Element} */
      parent,
      this,
      component.namespace
    );
    if (this.namespace !== namespaces.foreign) {
      if (this.name === "pre" || this.name === "textarea") {
        const first = info.children[0];
        if (first && first.type === "Text") {
          first.data = first.data.replace(regex_starts_with_newline, "");
        }
      }
      if (this.name === "textarea") {
        if (info.children.length > 0) {
          const value_attribute = get_value_attribute(info.attributes);
          if (value_attribute) {
            component.error(value_attribute, compiler_errors_default.textarea_duplicate_value);
            return;
          }
          info.attributes.push({
            type: "Attribute",
            name: "value",
            value: info.children
          });
          info.children = [];
        }
      }
      if (this.name === "option") {
        const value_attribute = get_value_attribute(info.attributes);
        if (!value_attribute) {
          info.attributes.push({
            type: "Attribute",
            name: "value",
            value: info.children,
            synthetic: true
          });
        }
      }
    }
    const has_let = info.attributes.some((node) => node.type === "Let");
    if (has_let) {
      scope = scope.child();
    }
    const order = ["Binding"];
    info.attributes.sort((a, b2) => order.indexOf(a.type) - order.indexOf(b2.type));
    info.attributes.forEach((node) => {
      switch (node.type) {
        case "Action":
          this.actions.push(new Action(component, this, scope, node));
          break;
        case "Attribute":
        case "Spread":
          if (node.name === "xmlns")
            this.namespace = node.value[0].data;
          this.attributes.push(new Attribute(component, this, scope, node));
          break;
        case "Binding":
          this.bindings.push(new Binding(component, this, scope, node));
          break;
        case "Class":
          this.classes.push(new Class(component, this, scope, node));
          break;
        case "StyleDirective":
          this.styles.push(new StyleDirective(component, this, scope, node));
          break;
        case "EventHandler":
          this.handlers.push(new EventHandler(component, this, scope, node));
          break;
        case "Let": {
          const l = new Let(component, this, scope, node);
          this.lets.push(l);
          const dependencies = /* @__PURE__ */ new Set([l.name.name]);
          l.names.forEach((name8) => {
            scope.add(name8, dependencies, this);
          });
          break;
        }
        case "Transition": {
          const transition = new Transition(component, this, scope, node);
          if (node.intro)
            this.intro = transition;
          if (node.outro)
            this.outro = transition;
          break;
        }
        case "Animation":
          this.animation = new Animation(component, this, scope, node);
          break;
        default:
          throw new Error(`Not implemented: ${node.type}`);
      }
    });
    this.scope = scope;
    this.children = map_children(component, this, this.scope, info.children);
    this.validate();
    this.optimise();
    component.apply_stylesheet(this);
    if (this.parent) {
      if (this.actions.length > 0 || this.animation || this.bindings.length > 0 || this.classes.length > 0 || this.intro || this.outro || this.handlers.length > 0 || this.styles.length > 0 || this.name === "option" || this.is_dynamic_element || this.tag_expr.dynamic_dependencies().length || component.compile_options.dev) {
        this.parent.cannot_use_innerhtml();
        this.parent.not_static_content();
      }
    }
  }
  get is_dynamic_element() {
    return this.name === "svelte:element";
  }
  validate() {
    if (this.component.var_lookup.has(this.name) && this.component.var_lookup.get(this.name).imported && !is_svg(this.name) && !is_html(this.name)) {
      this.component.warn(this, compiler_warnings_default.component_name_lowercase(this.name));
    }
    this.validate_attributes();
    this.validate_event_handlers();
    if (this.namespace === namespaces.foreign) {
      this.validate_bindings_foreign();
    } else {
      this.validate_attributes_a11y();
      this.validate_special_cases();
      this.validate_bindings();
      this.validate_content();
    }
  }
  validate_attributes() {
    const { component, parent } = this;
    this.attributes.forEach((attribute) => {
      if (attribute.is_spread)
        return;
      const name8 = attribute.name.toLowerCase();
      if (regex_illegal_attribute_character.test(name8)) {
        return component.error(attribute, compiler_errors_default.illegal_attribute(name8));
      }
      if (name8 === "slot") {
        if (!attribute.is_static) {
          return component.error(attribute, compiler_errors_default.invalid_slot_attribute);
        }
        if (component.slot_outlets.has(name8)) {
          return component.error(attribute, compiler_errors_default.duplicate_slot_attribute(name8));
        }
        if (!(parent.type === "SlotTemplate" || within_custom_element(parent))) {
          return component.error(attribute, compiler_errors_default.invalid_slotted_content);
        }
      }
      if (this.namespace !== namespaces.foreign) {
        if (name8 === "is") {
          component.warn(attribute, compiler_warnings_default.avoid_is);
        }
        if (react_attributes.has(attribute.name)) {
          component.warn(
            attribute,
            compiler_warnings_default.invalid_html_attribute(
              attribute.name,
              react_attributes.get(attribute.name)
            )
          );
        }
      }
    });
  }
  validate_attributes_a11y() {
    const { component, attributes, handlers: handlers2 } = this;
    const attribute_map = /* @__PURE__ */ new Map();
    const handlers_map = /* @__PURE__ */ new Map();
    attributes.forEach((attribute) => attribute_map.set(attribute.name, attribute));
    handlers2.forEach((handler) => handlers_map.set(handler.name, handler));
    attributes.forEach((attribute) => {
      if (attribute.is_spread)
        return;
      const name8 = attribute.name.toLowerCase();
      if (name8.startsWith("aria-")) {
        if (invisible_elements.has(this.name)) {
          component.warn(attribute, compiler_warnings_default.a11y_aria_attributes(this.name));
        }
        const type = name8.slice(5);
        if (!aria_attribute_set.has(type)) {
          const match = fuzzymatch(type, aria_attributes);
          component.warn(attribute, compiler_warnings_default.a11y_unknown_aria_attribute(type, match));
        }
        if (name8 === "aria-hidden" && regex_heading_tags.test(this.name)) {
          component.warn(attribute, compiler_warnings_default.a11y_hidden(this.name));
        }
        let value = attribute.get_static_value();
        if (value === "true")
          value = true;
        if (value === "false")
          value = false;
        if (value !== null && value !== void 0 && import_aria_query2.aria.has(
          /** @type {import('aria-query').ARIAProperty} */
          name8
        )) {
          const schema = import_aria_query2.aria.get(
            /** @type {import('aria-query').ARIAProperty} */
            name8
          );
          if (!is_valid_aria_attribute_value(schema, value)) {
            component.warn(
              attribute,
              compiler_warnings_default.a11y_incorrect_attribute_type(schema, name8)
            );
          }
        }
        if (name8 === "aria-activedescendant" && !this.is_dynamic_element && !is_interactive_element(this.name, attribute_map) && !attribute_map.has("tabindex")) {
          component.warn(attribute, compiler_warnings_default.a11y_aria_activedescendant_has_tabindex);
        }
      }
      if (name8 === "role") {
        if (invisible_elements.has(this.name)) {
          component.warn(attribute, compiler_warnings_default.a11y_misplaced_role(this.name));
        }
        const value = attribute.get_static_value();
        if (typeof value === "string") {
          value.split(regex_any_repeated_whitespaces).forEach(
            /** @param {import('aria-query').ARIARoleDefinitionKey} current_role */
            (current_role) => {
              var _a;
              if (current_role && is_abstract_role(current_role)) {
                component.warn(attribute, compiler_warnings_default.a11y_no_abstract_role(current_role));
              } else if (current_role && !aria_role_set.has(current_role)) {
                const match = fuzzymatch(current_role, aria_roles2);
                component.warn(attribute, compiler_warnings_default.a11y_unknown_role(current_role, match));
              }
              if (current_role === get_implicit_role(this.name, attribute_map) && // <ul role="list"> is ok because CSS list-style:none removes the semantics and this is a way to bring them back
              !["ul", "ol", "li"].includes(this.name)) {
                component.warn(attribute, compiler_warnings_default.a11y_no_redundant_roles(current_role));
              }
              const is_parent_section_or_article = is_parent(this.parent, ["section", "article"]);
              if (!is_parent_section_or_article) {
                const has_nested_redundant_role = current_role === a11y_nested_implicit_semantics.get(this.name);
                if (has_nested_redundant_role) {
                  component.warn(
                    attribute,
                    compiler_warnings_default.a11y_no_redundant_roles(current_role)
                  );
                }
              }
              if (!this.is_dynamic_element && !is_semantic_role_element(current_role, this.name, attribute_map)) {
                const role2 = import_aria_query2.roles.get(current_role);
                if (role2) {
                  const required_role_props = Object.keys(role2.requiredProps);
                  const has_missing_props = required_role_props.some(
                    (prop) => !attributes.find((a) => a.name === prop)
                  );
                  if (has_missing_props) {
                    component.warn(
                      attribute,
                      compiler_warnings_default.a11y_role_has_required_aria_props(
                        current_role,
                        required_role_props
                      )
                    );
                  }
                }
              }
              if (!has_disabled_attribute(attribute_map) && !is_hidden_from_screen_reader(this.name, attribute_map) && !is_presentation_role(current_role) && is_interactive_roles(current_role) && is_static_element(this.name, attribute_map) && !attribute_map.get("tabindex")) {
                const has_interactive_handlers = handlers2.some(
                  (handler) => a11y_interactive_handlers.has(handler.name)
                );
                if (has_interactive_handlers) {
                  component.warn(
                    this,
                    compiler_warnings_default.a11y_interactive_supports_focus(current_role)
                  );
                }
              }
              if (is_interactive_element(this.name, attribute_map) && (is_non_interactive_roles(current_role) || is_presentation_role(current_role))) {
                component.warn(
                  this,
                  compiler_warnings_default.a11y_no_interactive_element_to_noninteractive_role(
                    current_role,
                    this.name
                  )
                );
              }
              if (is_non_interactive_element(this.name, attribute_map) && is_interactive_roles(current_role) && !((_a = a11y_non_interactive_element_to_interactive_role_exceptions[this.name]) == null ? void 0 : _a.includes(
                current_role
              ))) {
                component.warn(
                  this,
                  compiler_warnings_default.a11y_no_noninteractive_element_to_interactive_role(
                    current_role,
                    this.name
                  )
                );
              }
            }
          );
        }
      }
      if (name8 === "accesskey") {
        component.warn(attribute, compiler_warnings_default.a11y_accesskey);
      }
      if (name8 === "autofocus") {
        component.warn(attribute, compiler_warnings_default.a11y_autofocus);
      }
      if (name8 === "scope" && !this.is_dynamic_element && this.name !== "th") {
        component.warn(attribute, compiler_warnings_default.a11y_misplaced_scope);
      }
      if (name8 === "tabindex") {
        const value = attribute.get_static_value();
        if (!isNaN(value) && +value > 0) {
          component.warn(attribute, compiler_warnings_default.a11y_positive_tabindex);
        }
      }
    });
    if (handlers_map.has("click")) {
      const role2 = attribute_map.get("role");
      const is_non_presentation_role = (role2 == null ? void 0 : role2.is_static) && !is_presentation_role(
        /** @type {import('aria-query').ARIARoleDefinitionKey} */
        role2.get_static_value()
      );
      if (!this.is_dynamic_element && !is_hidden_from_screen_reader(this.name, attribute_map) && (!role2 || is_non_presentation_role) && !is_interactive_element(this.name, attribute_map) && !this.attributes.find((attr) => attr.is_spread)) {
        const has_key_event = handlers_map.has("keydown") || handlers_map.has("keyup") || handlers_map.has("keypress");
        if (!has_key_event) {
          component.warn(this, compiler_warnings_default.a11y_click_events_have_key_events);
        }
      }
    }
    const role = attribute_map.get("role");
    const role_static_value = (
      /** @type {import('aria-query').ARIARoleDefinitionKey} */
      role == null ? void 0 : role.get_static_value()
    );
    const role_value = (
      /** @type {import('aria-query').ARIARoleDefinitionKey} */
      role ? role_static_value : get_implicit_role(this.name, attribute_map)
    );
    if (!this.is_dynamic_element && !is_interactive_element(this.name, attribute_map) && !is_interactive_roles(role_static_value)) {
      const tab_index = attribute_map.get("tabindex");
      if (tab_index && (!tab_index.is_static || Number(tab_index.get_static_value()) >= 0)) {
        component.warn(this, compiler_warnings_default.a11y_no_noninteractive_tabindex);
      }
    }
    if (typeof role_value === "string" && import_aria_query2.roles.has(role_value)) {
      const { props } = import_aria_query2.roles.get(role_value);
      const invalid_aria_props = new Set(import_aria_query2.aria.keys().filter((attribute) => !(attribute in props)));
      const is_implicit = role_value && role === void 0;
      attributes.filter((prop) => prop.type !== "Spread").forEach((prop) => {
        if (invalid_aria_props.has(
          /** @type {import('aria-query').ARIAProperty} */
          prop.name
        )) {
          component.warn(
            prop,
            compiler_warnings_default.a11y_role_supports_aria_props(
              prop.name,
              role_value,
              is_implicit,
              this.name
            )
          );
        }
      });
    }
    if (!has_contenteditable_attr(this) && !is_hidden_from_screen_reader(this.name, attribute_map) && !is_presentation_role(role_static_value) && (!is_interactive_element(this.name, attribute_map) && is_non_interactive_roles(role_static_value) || is_non_interactive_element(this.name, attribute_map) && !role)) {
      const has_interactive_handlers = handlers2.some(
        (handler) => a11y_recommended_interactive_handlers.has(handler.name)
      );
      if (has_interactive_handlers) {
        component.warn(
          this,
          compiler_warnings_default.a11y_no_noninteractive_element_interactions(this.name)
        );
      }
    }
    const has_dynamic_role = attribute_map.get("role") && !attribute_map.get("role").is_static;
    if (!has_dynamic_role && !is_hidden_from_screen_reader(this.name, attribute_map) && !is_presentation_role(role_static_value) && !is_interactive_element(this.name, attribute_map) && !is_interactive_roles(role_static_value) && !is_non_interactive_element(this.name, attribute_map) && !is_non_interactive_roles(role_static_value) && !is_abstract_role(role_static_value)) {
      const interactive_handlers = handlers2.map((handler) => handler.name).filter((handler_name) => a11y_interactive_handlers.has(handler_name));
      if (interactive_handlers.length > 0) {
        component.warn(
          this,
          compiler_warnings_default.a11y_no_static_element_interactions(this.name, interactive_handlers)
        );
      }
    }
  }
  validate_special_cases() {
    const { component, attributes, handlers: handlers2 } = this;
    const attribute_map = /* @__PURE__ */ new Map();
    const handlers_map = /* @__PURE__ */ new Map();
    attributes.forEach((attribute) => attribute_map.set(attribute.name, attribute));
    handlers2.forEach((handler) => handlers_map.set(handler.name, handler));
    if (this.name === "a") {
      const href_attribute = attribute_map.get("href") || attribute_map.get("xlink:href");
      const id_attribute = attribute_map.get("id");
      const name_attribute = attribute_map.get("name");
      const target_attribute = attribute_map.get("target");
      const aria_label_attribute = attribute_map.get("aria-label");
      if (component.compile_options.legacy && target_attribute && target_attribute.get_static_value() === "_blank" && href_attribute) {
        const href_static_value = href_attribute.get_static_value() ? href_attribute.get_static_value().toLowerCase() : null;
        if (href_static_value === null || href_static_value.match(/^(https?:)?\/\//i)) {
          const rel = attribute_map.get("rel");
          if (rel == null || rel.is_static) {
            const rel_values = rel ? rel.get_static_value().split(regex_any_repeated_whitespaces) : [];
            if (!rel || !rel_values.includes("noreferrer")) {
              component.warn(this, {
                code: "security-anchor-rel-noreferrer",
                message: 'Security: Anchor with "target=_blank" should have rel attribute containing the value "noreferrer"'
              });
            }
          }
        }
      }
      if (aria_label_attribute) {
        const aria_value = aria_label_attribute.get_static_value();
        if (aria_value != "") {
          this.contains_a11y_label = true;
        }
      }
      if (href_attribute) {
        const href_value = href_attribute.get_static_value();
        if (href_value === "" || href_value === "#" || /^\W*javascript:/i.test(href_value)) {
          component.warn(
            href_attribute,
            compiler_warnings_default.a11y_invalid_attribute(href_attribute.name, href_value)
          );
        }
      } else {
        const id_attribute_valid = id_attribute && id_attribute.get_static_value() !== "";
        const name_attribute_valid = name_attribute && name_attribute.get_static_value() !== "";
        if (!id_attribute_valid && !name_attribute_valid) {
          component.warn(this, compiler_warnings_default.a11y_missing_attribute("a", "an", "href"));
        }
      }
    } else {
      const required_attributes = a11y_required_attributes[this.name];
      if (required_attributes) {
        const has_attribute = required_attributes.some((name8) => attribute_map.has(name8));
        if (!has_attribute) {
          should_have_attribute(this, required_attributes);
        }
      }
    }
    if (this.name === "input") {
      const type = attribute_map.get("type");
      if (type && type.get_static_value() === "image") {
        const required_attributes = ["alt", "aria-label", "aria-labelledby"];
        const has_attribute = required_attributes.some((name8) => attribute_map.has(name8));
        if (!has_attribute) {
          should_have_attribute(this, required_attributes, 'input type="image"');
        }
      }
      const autocomplete = attribute_map.get("autocomplete");
      if (type && autocomplete) {
        const type_value = type.get_static_value();
        const autocomplete_value = autocomplete.get_static_value();
        if (!is_valid_autocomplete(autocomplete_value)) {
          component.warn(
            autocomplete,
            compiler_warnings_default.a11y_autocomplete_valid(type_value, autocomplete_value)
          );
        }
      }
    }
    if (this.name === "img") {
      const alt_attribute = attribute_map.get("alt");
      const aria_hidden_attribute = attribute_map.get("aria-hidden");
      const aria_hidden_exist = aria_hidden_attribute && aria_hidden_attribute.get_static_value();
      if (alt_attribute && !aria_hidden_exist) {
        const alt_value = alt_attribute.get_static_value();
        if (/\b(image|picture|photo)\b/i.test(alt_value)) {
          component.warn(this, compiler_warnings_default.a11y_img_redundant_alt);
        }
      }
    }
    if (this.name === "label") {
      const has_input_child = (children) => {
        if (children.some(
          (child) => child instanceof _Element && (a11y_labelable.has(child.name) || child.name === "slot")
        )) {
          return true;
        }
        for (const child of children) {
          if (!("children" in child) || child.children.length === 0) {
            continue;
          }
          if (has_input_child(child.children)) {
            return true;
          }
        }
        return false;
      };
      if (!attribute_map.has("for") && !has_input_child(this.children)) {
        component.warn(this, compiler_warnings_default.a11y_label_has_associated_control);
      }
    }
    if (this.name === "video") {
      const aria_hidden_attribute = attribute_map.get("aria-hidden");
      const aria_hidden_exist = aria_hidden_attribute && aria_hidden_attribute.get_static_value();
      if (attribute_map.has("muted") || aria_hidden_exist === "true") {
        return;
      }
      let has_caption;
      const track = this.children.find(
        /** @param {Element} i */
        (i) => i.name === "track"
      );
      if (track) {
        has_caption = track.attributes.find(
          (a) => a.name === "kind" && a.get_static_value() === "captions"
        );
      }
      if (!has_caption) {
        component.warn(this, compiler_warnings_default.a11y_media_has_caption);
      }
    }
    if (a11y_distracting_elements.has(this.name)) {
      component.warn(this, compiler_warnings_default.a11y_distracting_elements(this.name));
    }
    if (this.name === "figcaption") {
      let { parent } = this;
      let is_figure_parent = false;
      while (parent) {
        if (
          /** @type {Element} */
          parent.name === "figure"
        ) {
          is_figure_parent = true;
          break;
        }
        if (parent.type === "Element") {
          break;
        }
        parent = parent.parent;
      }
      if (!is_figure_parent) {
        component.warn(this, compiler_warnings_default.a11y_structure_immediate);
      }
    }
    if (this.name === "figure") {
      const children = this.children.filter((node) => {
        if (node.type === "Comment")
          return false;
        if (node.type === "Text")
          return regex_non_whitespace_character.test(node.data);
        return true;
      });
      const index = children.findIndex(
        (child) => (
          /** @type {Element} */
          child.name === "figcaption"
        )
      );
      if (index !== -1 && index !== 0 && index !== children.length - 1) {
        component.warn(children[index], compiler_warnings_default.a11y_structure_first_or_last);
      }
    }
    if (handlers_map.has("mouseover") && !handlers_map.has("focus")) {
      component.warn(
        this,
        compiler_warnings_default.a11y_mouse_events_have_key_events("mouseover", "focus")
      );
    }
    if (handlers_map.has("mouseout") && !handlers_map.has("blur")) {
      component.warn(this, compiler_warnings_default.a11y_mouse_events_have_key_events("mouseout", "blur"));
    }
  }
  validate_bindings_foreign() {
    this.bindings.forEach((binding) => {
      if (binding.name !== "this") {
        return this.component.error(binding, compiler_errors_default.invalid_binding_foreign(binding.name));
      }
    });
  }
  validate_bindings() {
    const { component } = this;
    const check_type_attribute = () => {
      const attribute = this.attributes.find(
        /** @param {import('./Attribute.js').default} attribute */
        (attribute2) => attribute2.name === "type"
      );
      if (!attribute)
        return null;
      if (!attribute.is_static) {
        return component.error(attribute, compiler_errors_default.invalid_type);
      }
      const value = attribute.get_static_value();
      if (value === true) {
        return component.error(attribute, compiler_errors_default.missing_type);
      }
      return value;
    };
    this.bindings.forEach((binding) => {
      const { name: name8 } = binding;
      if (name8 === "value") {
        if (this.name !== "input" && this.name !== "textarea" && this.name !== "select") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_elements(this.name, "value")
          );
        }
        if (this.name === "select") {
          const attribute = this.attributes.find(
            /** @param {import('./Attribute.js').default} attribute */
            (attribute2) => attribute2.name === "multiple"
          );
          if (attribute && !attribute.is_static) {
            return component.error(attribute, compiler_errors_default.dynamic_multiple_attribute);
          }
        } else {
          check_type_attribute();
        }
      } else if (name8 === "checked" || name8 === "indeterminate") {
        if (this.name !== "input") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_elements(this.name, name8)
          );
        }
        const type = check_type_attribute();
        if (type !== "checkbox") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_no_checkbox(name8, type === "radio")
          );
        }
      } else if (name8 === "group") {
        if (this.name !== "input") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_elements(this.name, "group")
          );
        }
        const type = check_type_attribute();
        if (type !== "checkbox" && type !== "radio") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_element_with(
              '<input type="checkbox"> or <input type="radio">',
              "group"
            )
          );
        }
      } else if (name8 === "files") {
        if (this.name !== "input") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_elements(this.name, "files")
          );
        }
        const type = check_type_attribute();
        if (type !== "file") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_element_with('<input type="file">', "files")
          );
        }
      } else if (name8 === "open") {
        if (this.name !== "details") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_element_with("<details>", name8)
          );
        }
      } else if (name8 === "currentTime" || name8 === "duration" || name8 === "paused" || name8 === "buffered" || name8 === "seekable" || name8 === "played" || name8 === "volume" || name8 === "muted" || name8 === "playbackRate" || name8 === "seeking" || name8 === "ended" || name8 === "readyState") {
        if (this.name !== "audio" && this.name !== "video") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_element_with("audio> or <video>", name8)
          );
        }
      } else if (name8 === "videoHeight" || name8 === "videoWidth") {
        if (this.name !== "video") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_element_with("<video>", name8)
          );
        }
      } else if (regex_dimensions.test(name8)) {
        if (this.name === "svg" && (name8 === "offsetWidth" || name8 === "offsetHeight")) {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_on(
              binding.name,
              `<svg>. Use '${name8.replace("offset", "client")}' instead`
            )
          );
        } else if (is_svg(this.name)) {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_on(binding.name, "SVG elements")
          );
        } else if (is_void(this.name)) {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_on(
              binding.name,
              `void elements like <${this.name}>. Use a wrapper element instead`
            )
          );
        }
      } else if (name8 === "naturalWidth" || name8 === "naturalHeight") {
        if (this.name !== "img") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_element_with("<img>", name8)
          );
        }
      } else if (is_name_contenteditable(name8)) {
        const contenteditable = get_contenteditable_attr(this);
        if (!contenteditable) {
          return component.error(binding, compiler_errors_default.missing_contenteditable_attribute);
        } else if (contenteditable && !contenteditable.is_static) {
          return component.error(
            contenteditable,
            compiler_errors_default.dynamic_contenteditable_attribute
          );
        }
      } else if (name8 !== "this" && !regex_box_size.test(name8)) {
        return component.error(binding, compiler_errors_default.invalid_binding(binding.name));
      }
    });
  }
  validate_content() {
    if (!a11y_required_content.has(this.name))
      return;
    if (this.contains_a11y_label)
      return;
    if (this.bindings.some((binding) => ["textContent", "innerHTML"].includes(binding.name)))
      return;
    if (this.children.length === 0) {
      this.component.warn(this, compiler_warnings_default.a11y_missing_content(this.name));
    }
  }
  validate_event_handlers() {
    const { component } = this;
    this.handlers.forEach((handler) => {
      if (handler.modifiers.has("passive") && handler.modifiers.has("preventDefault")) {
        return component.error(
          handler,
          compiler_errors_default.invalid_event_modifier_combination("passive", "preventDefault")
        );
      }
      if (handler.modifiers.has("passive") && handler.modifiers.has("nonpassive")) {
        return component.error(
          handler,
          compiler_errors_default.invalid_event_modifier_combination("passive", "nonpassive")
        );
      }
      handler.modifiers.forEach((modifier) => {
        if (!valid_modifiers2.has(modifier)) {
          return component.error(
            handler,
            compiler_errors_default.invalid_event_modifier(list(Array.from(valid_modifiers2)))
          );
        }
        if (modifier === "passive") {
          if (passive_events.has(handler.name)) {
            if (handler.can_make_passive) {
              component.warn(handler, compiler_warnings_default.redundant_event_modifier_for_touch);
            }
          } else {
            component.warn(handler, compiler_warnings_default.redundant_event_modifier_passive);
          }
        }
        if (component.compile_options.legacy && (modifier === "once" || modifier === "passive")) {
          return component.error(handler, compiler_errors_default.invalid_event_modifier_legacy(modifier));
        }
      });
      if (passive_events.has(handler.name) && handler.can_make_passive && !handler.modifiers.has("preventDefault") && !handler.modifiers.has("nonpassive")) {
        handler.modifiers.add("passive");
      }
    });
  }
  is_media_node() {
    return this.name === "audio" || this.name === "video";
  }
  add_css_class() {
    if (this.attributes.some((attr) => attr.is_spread)) {
      this.needs_manual_style_scoping = true;
      return;
    }
    const { id } = this.component.stylesheet;
    const class_attribute = this.attributes.find((a) => a.name === "class");
    if (class_attribute && !class_attribute.is_true) {
      if (class_attribute.chunks.length === 1 && class_attribute.chunks[0].type === "Text") {
        class_attribute.chunks[0].data += ` ${id}`;
      } else {
        class_attribute.chunks.push(
          new Text(
            this.component,
            this,
            this.scope,
            /** @type {any} */
            {
              type: "Text",
              data: ` ${id}`,
              synthetic: true
            }
          )
        );
      }
    } else {
      this.attributes.push(
        new Attribute(
          this.component,
          this,
          this.scope,
          /** @type {any} */
          {
            type: "Attribute",
            name: "class",
            value: [{ type: "Text", data: id, synthetic: true }]
          }
        )
      );
    }
  }
  get slot_template_name() {
    return (
      /** @type {string} */
      this.attributes.find((attribute) => attribute.name === "slot").get_static_value()
    );
  }
  optimise() {
    attributes_to_compact_whitespace.forEach((attribute_name) => {
      const attribute = this.attributes.find((a) => a.name === attribute_name);
      if (attribute && !attribute.is_true) {
        attribute.chunks.forEach((chunk, index) => {
          if (chunk.type === "Text") {
            let data = chunk.data.replace(regex_any_repeated_whitespaces, " ");
            if (index === 0) {
              data = data.trimLeft();
            } else if (index === attribute.chunks.length - 1) {
              data = data.trimRight();
            }
            chunk.data = data;
          }
        });
      }
    });
  }
  get can_use_textcontent() {
    return this.is_static_content && this.children.every((node) => node.type === "Text" || node.type === "MustacheTag");
  }
  get can_optimise_to_html_string() {
    const can_use_textcontent = this.can_use_textcontent;
    const is_template_with_text_content = this.name === "template" && can_use_textcontent;
    return !is_template_with_text_content && !this.namespace && (this.can_use_innerhtml || can_use_textcontent) && this.children.length > 0;
  }
  get can_optimise_hydration() {
    const is_static_text_content = this.is_static_content && this.children.every((node) => node.type === "Text");
    return this.can_optimise_to_html_string && (this.can_use_innerhtml || is_static_text_content);
  }
  hash() {
    return `svelte-${hash(this.component.source.slice(this.start, this.end))}`;
  }
};
var regex_starts_with_vowel = /^[aeiou]/;
function should_have_attribute(node, attributes, name8 = node.name) {
  const article = regex_starts_with_vowel.test(attributes[0]) ? "an" : "a";
  const sequence = attributes.length > 1 ? attributes.slice(0, -1).join(", ") + ` or ${attributes[attributes.length - 1]}` : attributes[0];
  node.component.warn(node, compiler_warnings_default.a11y_missing_attribute(name8, article, sequence));
}
var regex_minus_sign = /-/;
function within_custom_element(parent) {
  while (parent) {
    if (parent.type === "InlineComponent")
      return false;
    if (parent.type === "Element") {
      if (regex_minus_sign.test(parent.name) || parent.is_dynamic_element)
        return true;
    }
    parent = parent.parent;
  }
  return false;
}
function get_value_attribute(attributes) {
  let node_value;
  attributes.forEach((node) => {
    if (node.type !== "Spread" && node.name.toLowerCase() === "value") {
      node_value = node;
    }
    if (node.type === "Spread") {
      walk(
        /** @type {any} */
        node.expression,
        {
          enter(node2) {
            if (node_value) {
              this.skip();
            }
            if (node2.type === "Identifier") {
              if (
                /** @type {import('estree').Identifier} */
                node2.name.toLowerCase() === "value"
              ) {
                node_value = node2;
              }
            }
          }
        }
      );
    }
  });
  return node_value;
}

// node_modules/svelte/src/compiler/compile/nodes/Head.js
var Head = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {any[]} */
    __publicField(this, "children");
    // TODO
    /** @type {string} */
    __publicField(this, "id");
    this.cannot_use_innerhtml();
    if (info.attributes.length) {
      component.error(info.attributes[0], compiler_errors_default.invalid_attribute_head);
      return;
    }
    this.children = map_children(
      component,
      parent,
      scope,
      info.children.filter((child) => {
        return child.type !== "Text" || regex_non_whitespace_character.test(child.data);
      })
    );
    if (this.children.length > 0) {
      this.id = `svelte-${hash(this.component.source.slice(this.start, this.end))}`;
    }
  }
};

// node_modules/svelte/src/compiler/compile/nodes/IfBlock.js
var IfBlock = class extends AbstractBlock {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {import('./ElseBlock.js').default} */
    __publicField(this, "else");
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {import('./ConstTag.js').default[]} */
    __publicField(this, "const_tags");
    this.scope = scope.child();
    this.cannot_use_innerhtml();
    this.not_static_content();
    this.expression = new Expression(component, this, this.scope, info.expression);
    [this.const_tags, this.children] = get_const_tags(info.children, component, this, this);
    this.else = info.else ? new ElseBlock(component, this, scope, info.else) : null;
    this.warn_if_empty_block();
  }
};

// node_modules/svelte/src/compiler/compile/nodes/InlineComponent.js
var InlineComponent = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {import('./Binding.js').default[]} */
    __publicField(this, "bindings", []);
    /** @type {import('./EventHandler.js').default[]} */
    __publicField(this, "handlers", []);
    /** @type {import('./Attribute.js').default[]} */
    __publicField(this, "css_custom_properties", []);
    /** @type {import('./interfaces.js').INode[]} */
    __publicField(this, "children");
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {string} */
    __publicField(this, "namespace");
    /** @type {Attribute[]} */
    __publicField(this, "let_attributes");
    this.cannot_use_innerhtml();
    this.not_static_content();
    if (info.name !== "svelte:component" && info.name !== "svelte:self") {
      const name8 = info.name.split(".")[0];
      component.warn_if_undefined(name8, info, scope);
      component.add_reference(
        /** @type {any} */
        this,
        name8
      );
    }
    this.name = info.name;
    this.namespace = get_namespace2(parent, component.namespace);
    this.expression = this.name === "svelte:component" ? new Expression(component, this, scope, info.expression) : null;
    const let_attributes = this.let_attributes = [];
    info.attributes.forEach(
      /** @param {import('../../interfaces.js').BaseDirective | import('../../interfaces.js').Attribute | import('../../interfaces.js').SpreadAttribute} node */
      (node) => {
        switch (node.type) {
          case "Action":
            return component.error(node, compiler_errors_default.invalid_action);
          case "Attribute":
            if (node.name.startsWith("--")) {
              this.css_custom_properties.push(new Attribute(component, this, scope, node));
              break;
            }
          case "Spread":
            this.attributes.push(new Attribute(component, this, scope, node));
            break;
          case "Binding":
            this.bindings.push(new Binding(component, this, scope, node));
            break;
          case "Class":
            return component.error(node, compiler_errors_default.invalid_class);
          case "EventHandler":
            this.handlers.push(new EventHandler(component, this, scope, node));
            break;
          case "Let":
            let_attributes.push(node);
            break;
          case "Transition":
            return component.error(node, compiler_errors_default.invalid_transition);
          case "StyleDirective":
            return component.error(node, compiler_errors_default.invalid_component_style_directive);
          case "Animation":
            return component.error(node, compiler_errors_default.invalid_animation);
          default:
            throw new Error(`Not implemented: ${node.type}`);
        }
      }
    );
    this.scope = scope;
    this.handlers.forEach((handler) => {
      handler.modifiers.forEach((modifier) => {
        if (modifier !== "once") {
          return component.error(handler, compiler_errors_default.invalid_event_modifier_component);
        }
      });
    });
    const children = [];
    for (let i = info.children.length - 1; i >= 0; i--) {
      const child = info.children[i];
      if (child.type === "SlotTemplate") {
        children.push(child);
        info.children.splice(i, 1);
      } else if ((child.type === "Element" || child.type === "InlineComponent" || child.type === "Slot") && child.attributes.find((attribute) => attribute.name === "slot")) {
        const slot_template = {
          start: child.start,
          end: child.end,
          type: "SlotTemplate",
          name: "svelte:fragment",
          attributes: [],
          children: [child]
        };
        for (let i2 = child.attributes.length - 1; i2 >= 0; i2--) {
          const attribute = child.attributes[i2];
          if (attribute.type === "Let") {
            slot_template.attributes.push(attribute);
            child.attributes.splice(i2, 1);
          } else if (attribute.type === "Attribute" && attribute.name === "slot") {
            slot_template.attributes.push(attribute);
          }
        }
        for (let i2 = child.children.length - 1; i2 >= 0; i2--) {
          const child_child = child.children[i2];
          if (child_child.type === "ConstTag") {
            slot_template.children.push(child_child);
            child.children.splice(i2, 1);
          }
        }
        children.push(slot_template);
        info.children.splice(i, 1);
      } else if (child.type === "Comment" && children.length > 0) {
        children[children.length - 1].children.unshift(child);
      }
    }
    if (info.children.some((node) => not_whitespace_text(node))) {
      children.push({
        start: info.start,
        end: info.end,
        type: "SlotTemplate",
        name: "svelte:fragment",
        attributes: [],
        children: info.children
      });
    }
    if (let_attributes.length) {
      children.forEach((child) => {
        const slot = child.attributes.find((attribute) => attribute.name === "slot");
        if (!slot || slot.value[0].data === "default") {
          child.attributes.push(...let_attributes);
        }
      });
    }
    this.children = map_children(component, this, this.scope, children);
  }
  get slot_template_name() {
    return (
      /** @type {string} */
      this.attributes.find((attribute) => attribute.name === "slot").get_static_value()
    );
  }
};
function not_whitespace_text(node) {
  return !(node.type === "Text" && regex_only_whitespaces.test(node.data));
}
function get_namespace2(parent, explicit_namespace) {
  const parent_element = parent.find_nearest(/^Element/);
  if (!parent_element) {
    return explicit_namespace;
  }
  return parent_element.namespace;
}

// node_modules/svelte/src/compiler/compile/nodes/KeyBlock.js
var KeyBlock = class extends AbstractBlock {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    this.cannot_use_innerhtml();
    this.not_static_content();
    this.expression = new Expression(component, this, scope, info.expression);
    this.children = map_children(component, this, scope, info.children);
    this.warn_if_empty_block();
  }
};

// node_modules/svelte/src/compiler/compile/nodes/shared/Tag.js
var Tag = class extends Node {
  /**
   * @param {any} component
   * @param {any} parent
   * @param {any} scope
   * @param {any} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./Expression.js').default} */
    __publicField(this, "expression");
    /** @type {boolean} */
    __publicField(this, "should_cache");
    component.tags.push(this);
    this.cannot_use_innerhtml();
    this.expression = new Expression(component, this, scope, info.expression);
    this.should_cache = info.expression.type !== "Identifier" || this.expression.dependencies.size && scope.names.has(info.expression.name);
  }
  is_dependencies_static() {
    return this.expression.dynamic_contextual_dependencies().length === 0 && this.expression.dynamic_dependencies().length === 0;
  }
  check_if_content_dynamic() {
    if (!this.is_dependencies_static()) {
      this.not_static_content();
    }
  }
};

// node_modules/svelte/src/compiler/compile/nodes/MustacheTag.js
var MustacheTag = class extends Tag {
};

// node_modules/svelte/src/compiler/compile/nodes/Options.js
var Options = class extends Node {
};

// node_modules/svelte/src/compiler/compile/nodes/RawMustacheTag.js
var RawMustacheTag = class extends Tag {
  /**
   * @param {any} component
   * @param {any} parent
   * @param {any} scope
   * @param {any} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    this.cannot_use_innerhtml();
    this.not_static_content();
  }
};

// node_modules/svelte/src/compiler/compile/nodes/DebugTag.js
var DebugTag = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./interfaces.js').INode} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/Expression.js').default[]} */
    __publicField(this, "expressions");
    this.expressions = info.identifiers.map(
      /** @param {import('estree').Node} node */
      (node) => {
        return new Expression(component, parent, scope, node);
      }
    );
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Slot.js
var Slot = class extends Element {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./interfaces.js').INode} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {'Slot'} */
    // @ts-ignore Slot elements have the 'Slot' type, but TypeScript doesn't allow us to have 'Slot' when it extends Element
    __publicField(this, "type", "Slot");
    /** @type {string} */
    __publicField(this, "slot_name");
    /** @type {Map<string, import('./Attribute.js').default>} */
    __publicField(this, "values", /* @__PURE__ */ new Map());
    info.attributes.forEach((attr) => {
      if (attr.type !== "Attribute" && attr.type !== "Spread") {
        return component.error(attr, compiler_errors_default.invalid_slot_directive);
      }
      if (attr.name === "name") {
        if (attr.value.length !== 1 || attr.value[0].type !== "Text") {
          return component.error(attr, compiler_errors_default.dynamic_slot_name);
        }
        this.slot_name = attr.value[0].data;
        if (this.slot_name === "default") {
          return component.error(attr, compiler_errors_default.invalid_slot_name);
        }
      }
      this.values.set(attr.name, new Attribute(component, this, scope, attr));
    });
    if (!this.slot_name)
      this.slot_name = "default";
    component.slots.set(this.slot_name, this);
    this.cannot_use_innerhtml();
    this.not_static_content();
  }
};

// node_modules/svelte/src/compiler/compile/nodes/SlotTemplate.js
var SlotTemplate = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./interfaces.js').INode} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {any} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {import('./interfaces.js').INode[]} */
    __publicField(this, "children");
    /** @type {import('./Let.js').default[]} */
    __publicField(this, "lets", []);
    /** @type {import('./ConstTag.js').default[]} */
    __publicField(this, "const_tags");
    /** @type {import('./Attribute.js').default} */
    __publicField(this, "slot_attribute");
    /** @type {string} */
    __publicField(this, "slot_template_name", "default");
    this.validate_slot_template_placement();
    scope = scope.child();
    info.attributes.forEach((node) => {
      switch (node.type) {
        case "Let": {
          const l = new Let(component, this, scope, node);
          this.lets.push(l);
          const dependencies = /* @__PURE__ */ new Set([l.name.name]);
          l.names.forEach((name8) => {
            scope.add(name8, dependencies, this);
          });
          break;
        }
        case "Attribute": {
          if (node.name === "slot") {
            this.slot_attribute = new Attribute(component, this, scope, node);
            if (!this.slot_attribute.is_static) {
              return component.error(node, compiler_errors_default.invalid_slot_attribute);
            }
            const value = this.slot_attribute.get_static_value();
            if (typeof value === "boolean") {
              return component.error(node, compiler_errors_default.invalid_slot_attribute_value_missing);
            }
            this.slot_template_name = /** @type {string} */
            value;
            break;
          }
          throw new Error(`Invalid attribute '${node.name}' in <svelte:fragment>`);
        }
        default:
          throw new Error(`Not implemented: ${node.type}`);
      }
    });
    this.scope = scope;
    [this.const_tags, this.children] = get_const_tags(info.children, component, this, this);
  }
  validate_slot_template_placement() {
    if (this.parent.type !== "InlineComponent") {
      return this.component.error(this, compiler_errors_default.invalid_slotted_content_fragment);
    }
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Title.js
var Title = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/map_children.js').Children} */
    __publicField(this, "children");
    /** @type {boolean} */
    __publicField(this, "should_cache");
    this.children = map_children(component, parent, scope, info.children);
    if (info.attributes.length > 0) {
      component.error(info.attributes[0], compiler_errors_default.illegal_attribute_title);
      return;
    }
    info.children.forEach((child) => {
      if (child.type !== "Text" && child.type !== "MustacheTag") {
        return component.error(child, compiler_errors_default.illegal_structure_title);
      }
    });
    this.should_cache = info.children.length === 1 ? info.children[0].type !== "Identifier" || scope.names.has(info.children[0].name) : true;
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Window.js
var valid_bindings2 = [
  "innerWidth",
  "innerHeight",
  "outerWidth",
  "outerHeight",
  "scrollX",
  "scrollY",
  "devicePixelRatio",
  "online"
];
var Window = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./EventHandler.js').default[]} */
    __publicField(this, "handlers", []);
    /** @type {import('./Binding.js').default[]} */
    __publicField(this, "bindings", []);
    /** @type {import('./Action.js').default[]} */
    __publicField(this, "actions", []);
    info.attributes.forEach((node) => {
      if (node.type === "EventHandler") {
        this.handlers.push(new EventHandler(component, this, scope, node));
      } else if (node.type === "Binding") {
        if (node.expression.type !== "Identifier") {
          const { parts } = flatten_reference(node.expression);
          return component.error(node.expression, compiler_errors_default.invalid_binding_window(parts));
        }
        if (!~valid_bindings2.indexOf(node.name)) {
          const match = node.name === "width" ? "innerWidth" : node.name === "height" ? "innerHeight" : fuzzymatch(node.name, valid_bindings2);
          if (match) {
            return component.error(
              node,
              compiler_errors_default.invalid_binding_on(
                node.name,
                "<svelte:window>",
                ` (did you mean '${match}'?)`
              )
            );
          } else {
            return component.error(
              node,
              compiler_errors_default.invalid_binding_on(
                node.name,
                "<svelte:window>",
                ` â€” valid bindings are ${list(valid_bindings2)}`
              )
            );
          }
        }
        this.bindings.push(new Binding(component, this, scope, node));
      } else if (node.type === "Action") {
        this.actions.push(new Action(component, this, scope, node));
      } else {
      }
    });
  }
};

// node_modules/svelte/src/compiler/utils/push_array.js
function push_array(array, items) {
  for (let i = 0; i < items.length; i++) {
    array.push(items[i]);
  }
}

// node_modules/svelte/src/compiler/compile/nodes/shared/map_children.js
function get_constructor(type) {
  switch (type) {
    case "AwaitBlock":
      return AwaitBlock;
    case "Body":
      return Body;
    case "Comment":
      return Comment2;
    case "ConstTag":
      return ConstTag;
    case "Document":
      return Document;
    case "EachBlock":
      return EachBlock;
    case "Element":
      return Element;
    case "Head":
      return Head;
    case "IfBlock":
      return IfBlock;
    case "InlineComponent":
      return InlineComponent;
    case "KeyBlock":
      return KeyBlock;
    case "MustacheTag":
      return MustacheTag;
    case "Options":
      return Options;
    case "RawMustacheTag":
      return RawMustacheTag;
    case "DebugTag":
      return DebugTag;
    case "Slot":
      return Slot;
    case "SlotTemplate":
      return SlotTemplate;
    case "Text":
      return Text;
    case "Title":
      return Title;
    case "Window":
      return Window;
    default:
      throw new Error(`Not implemented: ${type}`);
  }
}
function map_children(component, parent, scope, children) {
  let last = null;
  let ignores = [];
  return children.map((child) => {
    const constructor = get_constructor(child.type);
    const use_ignores = child.type !== "Text" && child.type !== "Comment" && ignores.length;
    if (use_ignores)
      component.push_ignores(ignores);
    const node = new constructor(component, parent, scope, child);
    if (use_ignores)
      component.pop_ignores(), ignores = [];
    if (node.type === "Comment" && node.ignores.length) {
      push_array(ignores, node.ignores);
    }
    if (last)
      last.next = node;
    node.prev = last;
    last = node;
    return node;
  });
}

// node_modules/svelte/src/compiler/compile/utils/check_graph_for_cycles.js
function check_graph_for_cycles(edges) {
  const graph = edges.reduce((g, edge) => {
    const [u, v] = edge;
    if (!g.has(u))
      g.set(u, []);
    if (!g.has(v))
      g.set(v, []);
    g.get(u).push(v);
    return g;
  }, /* @__PURE__ */ new Map());
  const visited = /* @__PURE__ */ new Set();
  const on_stack = /* @__PURE__ */ new Set();
  const cycles = [];
  function visit(v) {
    visited.add(v);
    on_stack.add(v);
    graph.get(v).forEach((w) => {
      if (!visited.has(w)) {
        visit(w);
      } else if (on_stack.has(w)) {
        cycles.push([...on_stack, w]);
      }
    });
    on_stack.delete(v);
  }
  graph.forEach((_, v) => {
    if (!visited.has(v)) {
      visit(v);
    }
  });
  return cycles[0];
}

// node_modules/svelte/src/compiler/compile/nodes/shared/get_const_tags.js
function get_const_tags(children, component, node, parent) {
  const const_tags = [];
  const others = [];
  for (const child of children) {
    if (child.type === "ConstTag") {
      const_tags.push(
        /** @type {import('../../../interfaces.js').ConstTag} */
        child
      );
    } else {
      others.push(child);
    }
  }
  const consts_nodes = const_tags.map((tag2) => new ConstTag(component, node, node.scope, tag2));
  const sorted_consts_nodes = sort_consts_nodes(consts_nodes, component);
  sorted_consts_nodes.forEach((node2) => node2.parse_expression());
  const children_nodes = map_children(component, parent, node.scope, others);
  return [
    sorted_consts_nodes,
    /** @type {Array<Exclude<import('../interfaces.js').INode, ConstTag>>} */
    children_nodes
  ];
}
function sort_consts_nodes(consts_nodes, component) {
  const sorted_consts_nodes = [];
  const unsorted_consts_nodes = consts_nodes.map((node) => {
    return {
      assignees: node.assignees,
      dependencies: node.dependencies,
      node
    };
  });
  const lookup = /* @__PURE__ */ new Map();
  unsorted_consts_nodes.forEach((node) => {
    node.assignees.forEach((name8) => {
      if (!lookup.has(name8)) {
        lookup.set(name8, []);
      }
      lookup.get(name8).push(node);
    });
  });
  const cycle = check_graph_for_cycles(
    unsorted_consts_nodes.reduce((acc, node) => {
      node.assignees.forEach((v) => {
        node.dependencies.forEach((w) => {
          if (!node.assignees.has(w)) {
            acc.push([v, w]);
          }
        });
      });
      return acc;
    }, [])
  );
  if (cycle && cycle.length) {
    const node_list = lookup.get(cycle[0]);
    const node = node_list[0];
    component.error(node.node, compiler_errors_default.cyclical_const_tags(cycle));
  }
  const add_node = (node) => {
    if (sorted_consts_nodes.includes(node))
      return;
    node.dependencies.forEach((name8) => {
      if (node.assignees.has(name8))
        return;
      const earlier_nodes = lookup.get(name8);
      if (earlier_nodes) {
        earlier_nodes.forEach(add_node);
      }
    });
    sorted_consts_nodes.push(node);
  };
  unsorted_consts_nodes.forEach(add_node);
  return sorted_consts_nodes.map((node) => node.node);
}

// node_modules/svelte/src/compiler/compile/nodes/ThenBlock.js
var ThenBlock = class extends AbstractBlock {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./AwaitBlock.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {import('./ConstTag.js').default[]} */
    __publicField(this, "const_tags");
    this.scope = scope.child();
    if (parent.then_node) {
      parent.then_contexts.forEach((context) => {
        if (context.type !== "DestructuredVariable")
          return;
        this.scope.add(context.key.name, parent.expression.dependencies, this);
      });
    }
    [this.const_tags, this.children] = get_const_tags(info.children, component, this, parent);
    if (!info.skip) {
      this.warn_if_empty_block();
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/add_const_tags.js
function add_const_tags(block, const_tags, ctx) {
  const const_tags_props = [];
  const_tags.forEach((const_tag, i) => {
    const name8 = `#constants_${i}`;
    const_tags_props.push(b`const ${name8} = ${const_tag.expression.manipulate(block, ctx)}`);
    const to_ctx = (name9) => block.renderer.context_lookup.has(name9) ? x`${ctx}[${block.renderer.context_lookup.get(name9).index}]` : (
      /** @type {import('code-red').Node} */
      { type: "Identifier", name: name9 }
    );
    const_tag.contexts.forEach((context) => {
      if (context.type === "DestructuredVariable") {
        const_tags_props.push(
          b`${ctx}[${block.renderer.context_lookup.get(context.key.name).index}] = ${context.default_modifier(context.modifier({ type: "Identifier", name: name8 }), to_ctx)}`
        );
      } else {
        const expression = new Expression(
          block.renderer.component,
          const_tag,
          const_tag.scope,
          context.key
        );
        const_tags_props.push(
          b`const ${context.property_name} = ${expression.manipulate(block, ctx)}`
        );
      }
    });
  });
  return const_tags_props;
}
function add_const_tags_context(renderer, const_tags) {
  const_tags.forEach((const_tag) => {
    const_tag.contexts.forEach((context) => {
      if (context.type !== "DestructuredVariable")
        return;
      renderer.add_to_context(context.key.name, true);
    });
  });
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/AwaitBlock.js
var AwaitBlockBranch = class extends Wrapper {
  /**
   * @param {Status} status
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {AwaitBlockWrapper} parent
   * @param {import('../../nodes/PendingBlock.js').default | import('../../nodes/ThenBlock.js').default | import('../../nodes/CatchBlock.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(status, renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @typedef {'pending' | 'then' | 'catch'} Status */
    /** @type {import('../Block.js').default} */
    __publicField(this, "block");
    /** @type {import('./Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {boolean} */
    __publicField(this, "is_dynamic");
    __publicField(this, "var", null);
    /** @type {Status} */
    __publicField(this, "status");
    /** @type {string} */
    __publicField(this, "value");
    /** @type {import('estree').Literal} */
    __publicField(this, "value_index");
    /** @type {import('../../nodes/shared/Context.js').Context[]} */
    __publicField(this, "value_contexts");
    /** @type {boolean} */
    __publicField(this, "is_destructured");
    this.status = status;
    this.block = block.child({
      comment: create_debugging_comment(node, this.renderer.component),
      name: this.renderer.component.get_unique_name(`create_${status}_block`),
      type: status
    });
    this.add_context(parent.node[status + "_node"], parent.node[status + "_contexts"]);
    this.fragment = new FragmentWrapper(
      renderer,
      this.block,
      this.node.children,
      parent,
      strip_whitespace,
      next_sibling
    );
    this.is_dynamic = this.block.dependencies.size > 0;
  }
  /**
   * @param {import('estree').Node | null} node
   * @param {import('../../nodes/shared/Context.js').Context[]} contexts
   */
  add_context(node, contexts) {
    if (!node)
      return;
    if (node.type === "Identifier") {
      this.value = node.name;
      this.renderer.add_to_context(this.value, true);
    } else {
      contexts.forEach((context) => {
        if (context.type !== "DestructuredVariable")
          return;
        this.renderer.add_to_context(context.key.name, true);
      });
      this.value = this.block.parent.get_unique_name("value").name;
      this.value_contexts = contexts;
      this.renderer.add_to_context(this.value, true);
      this.is_destructured = true;
    }
    this.value_index = this.renderer.context_lookup.get(this.value).index;
    if (this.has_consts(this.node)) {
      add_const_tags_context(this.renderer, this.node.const_tags);
    }
  }
  /**
   * @param {import('../../nodes/PendingBlock.js').default | import('../../nodes/ThenBlock.js').default | import('../../nodes/CatchBlock.js').default} node
   * @returns {node is import('../../nodes/ThenBlock.js').default | import('../../nodes/CatchBlock.js').default}
   */
  has_consts(node) {
    return node instanceof ThenBlock || node instanceof CatchBlock;
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    this.fragment.render(block, parent_node, parent_nodes);
    if (this.is_destructured || this.has_consts(this.node) && this.node.const_tags.length > 0) {
      this.render_get_context();
    }
  }
  render_get_context() {
    const props = this.is_destructured ? this.value_contexts.map((prop) => {
      if (prop.type === "ComputedProperty") {
        const expression = new Expression(
          this.renderer.component,
          this.node,
          this.has_consts(this.node) ? this.node.scope : null,
          prop.key
        );
        return b`const ${prop.property_name} = ${expression.manipulate(this.block, "#ctx")};`;
      } else {
        const to_ctx = (name8) => this.renderer.reference(name8);
        return b`#ctx[${this.block.renderer.context_lookup.get(prop.key.name).index}] = ${prop.default_modifier(prop.modifier(x`#ctx[${this.value_index}]`), to_ctx)};`;
      }
    }) : null;
    const const_tags_props = this.has_consts(this.node) ? add_const_tags(this.block, this.node.const_tags, "#ctx") : null;
    const get_context2 = this.block.renderer.component.get_unique_name(`get_${this.status}_context`);
    this.block.renderer.blocks.push(b`
			function ${get_context2}(#ctx) {
				${props}
				${const_tags_props}
			}
		`);
    this.block.chunks.declarations.push(b`${get_context2}(#ctx)`);
    if (this.block.has_update_method) {
      this.block.chunks.update.unshift(b`${get_context2}(#ctx)`);
    }
  }
};
var AwaitBlockWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/AwaitBlock.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {AwaitBlockBranch} */
    __publicField(this, "pending");
    /** @type {AwaitBlockBranch} */
    __publicField(this, "then");
    /** @type {AwaitBlockBranch} */
    __publicField(this, "catch");
    /** @type {import('estree').Identifier} */
    __publicField(this, "var", { type: "Identifier", name: "await_block" });
    block.add_dependencies(this.node.expression.dependencies);
    let is_dynamic3 = false;
    let has_intros = false;
    let has_outros = false;
    ["pending", "then", "catch"].forEach((status) => {
      const child = this.node[status];
      const branch = new AwaitBlockBranch(
        status,
        renderer,
        block,
        this,
        child,
        strip_whitespace,
        next_sibling
      );
      renderer.blocks.push(branch.block);
      if (branch.is_dynamic) {
        is_dynamic3 = true;
        block.add_dependencies(branch.block.dependencies);
      }
      if (branch.block.has_intros)
        has_intros = true;
      if (branch.block.has_outros)
        has_outros = true;
      this[status] = branch;
    });
    ["pending", "then", "catch"].forEach((status) => {
      this[status].block.has_update_method = is_dynamic3;
      this[status].block.has_intro_method = has_intros;
      this[status].block.has_outro_method = has_outros;
    });
    if (has_outros) {
      block.add_outro();
    }
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
    const update_mount_node = this.get_update_mount_node(anchor);
    const snippet = this.node.expression.manipulate(block);
    const info = block.get_unique_name("info");
    const promise = block.get_unique_name("promise");
    block.add_variable(promise);
    block.maintain_context = true;
    const info_props = x`{
			ctx: #ctx,
			current: null,
			token: null,
			hasCatch: ${this.catch.node.start !== null ? "true" : "false"},
			pending: ${this.pending.block.name},
			then: ${this.then.block.name},
			catch: ${this.catch.block.name},
			value: ${this.then.value_index},
			error: ${this.catch.value_index},
			blocks: ${this.pending.block.has_outro_method && x`[,,,]`}
		}`;
    block.chunks.init.push(b`
			let ${info} = ${info_props};
		`);
    block.chunks.init.push(b`
			@handle_promise(${promise} = ${snippet}, ${info});
		`);
    block.chunks.create.push(b`
			${info}.block.c();
		`);
    if (parent_nodes && this.renderer.options.hydratable) {
      block.chunks.claim.push(b`
				${info}.block.l(${parent_nodes});
			`);
    }
    const initial_mount_node = parent_node || "#target";
    const anchor_node = parent_node ? "null" : "#anchor";
    const has_transitions = this.pending.block.has_intro_method || this.pending.block.has_outro_method;
    block.chunks.mount.push(b`
			${info}.block.m(${initial_mount_node}, ${info}.anchor = ${anchor_node});
			${info}.mount = () => ${update_mount_node};
			${info}.anchor = ${anchor};
		`);
    if (has_transitions) {
      block.chunks.intro.push(b`@transition_in(${info}.block);`);
    }
    const dependencies = this.node.expression.dynamic_dependencies();
    const update_await_block_branch = b`@update_await_block_branch(${info}, #ctx, #dirty)`;
    if (dependencies.length > 0) {
      const condition = x`
				${block.renderer.dirty(dependencies)} &&
				${promise} !== (${promise} = ${snippet}) &&
				@handle_promise(${promise}, ${info})`;
      block.chunks.update.push(b`${info}.ctx = #ctx;`);
      if (this.pending.block.has_update_method) {
        block.chunks.update.push(b`
					if (${condition}) {

					} else {
						${update_await_block_branch}
					}
				`);
      } else {
        block.chunks.update.push(b`
					${condition}
				`);
      }
    } else {
      if (this.pending.block.has_update_method) {
        block.chunks.update.push(b`
					${update_await_block_branch}
				`);
      }
    }
    if (this.pending.block.has_outro_method) {
      block.chunks.outro.push(b`
				for (let #i = 0; #i < 3; #i += 1) {
					const block = ${info}.blocks[#i];
					@transition_out(block);
				}
			`);
    }
    block.chunks.destroy.push(b`
			${info}.block.d(${parent_node ? null : "detaching"});
			${info}.token = null;
			${info} = null;
		`);
    [this.pending, this.then, this.catch].forEach((branch) => {
      branch.render(
        branch.block,
        null,
        /** @type {import('estree').Identifier} */
        x`#nodes`
      );
    });
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Element/EventHandler.js
var TRUE = x`true`;
var FALSE = x`false`;
var EventHandlerWrapper = class {
  /**
   * @param {import('../../../nodes/EventHandler.js').default} node
   * @param {import('../shared/Wrapper.js').default} parent
   */
  constructor(node, parent) {
    /** @type {import('../../../nodes/EventHandler.js').default} */
    __publicField(this, "node");
    /** @type {import('../shared/Wrapper.js').default} */
    __publicField(this, "parent");
    this.node = node;
    this.parent = parent;
    if (!node.expression) {
      this.parent.renderer.add_to_context(node.handler_name.name);
      this.parent.renderer.component.partly_hoisted.push(b`
				function ${node.handler_name.name}(event) {
					@bubble.call(this, $$self, event);
				}
			`);
    }
  }
  /** @param {import('../../Block.js').default} block */
  get_snippet(block) {
    const snippet = this.node.expression ? this.node.expression.manipulate(block) : block.renderer.reference(this.node.handler_name);
    if (this.node.reassigned) {
      block.maintain_context = true;
      return x`function () { if (@is_function(${snippet})) ${snippet}.apply(this, arguments); }`;
    }
    return snippet;
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {string | import('estree').Expression} target
   */
  render(block, target) {
    let snippet = this.get_snippet(block);
    if (this.node.modifiers.has("preventDefault"))
      snippet = x`@prevent_default(${snippet})`;
    if (this.node.modifiers.has("stopPropagation"))
      snippet = x`@stop_propagation(${snippet})`;
    if (this.node.modifiers.has("stopImmediatePropagation"))
      snippet = x`@stop_immediate_propagation(${snippet})`;
    if (this.node.modifiers.has("self"))
      snippet = x`@self(${snippet})`;
    if (this.node.modifiers.has("trusted"))
      snippet = x`@trusted(${snippet})`;
    const args = [];
    const opts = ["nonpassive", "passive", "once", "capture"].filter(
      (mod) => this.node.modifiers.has(mod)
    );
    if (opts.length) {
      if (opts.length === 1 && opts[0] === "capture") {
        args.push(TRUE);
      } else {
        args.push(
          x`{ ${opts.map((opt) => opt === "nonpassive" ? p`passive: false` : p`${opt}: true`)} }`
        );
      }
    } else if (block.renderer.options.dev) {
      args.push(FALSE);
    }
    if (block.renderer.options.dev) {
      args.push(this.node.modifiers.has("preventDefault") ? TRUE : FALSE);
      args.push(this.node.modifiers.has("stopPropagation") ? TRUE : FALSE);
      args.push(this.node.modifiers.has("stopImmediatePropagation") ? TRUE : FALSE);
    }
    block.event_listeners.push(x`@listen(${target}, "${this.node.name}", ${snippet}, ${args})`);
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/add_event_handlers.js
function add_event_handlers(block, target, handlers2) {
  handlers2.forEach((handler) => add_event_handler(block, target, handler));
}
function add_event_handler(block, target, handler) {
  handler.render(block, target);
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/add_actions.js
function add_actions(block, target, actions) {
  actions.forEach((action) => add_action(block, target, action));
}
var regex_invalid_variable_identifier_characters = /[^a-zA-Z0-9_$]/g;
function add_action(block, target, action) {
  const { expression, template_scope } = action;
  let snippet;
  let dependencies;
  if (expression) {
    snippet = expression.manipulate(block);
    dependencies = expression.dynamic_dependencies();
  }
  const id = block.get_unique_name(
    `${action.name.replace(regex_invalid_variable_identifier_characters, "_")}_action`
  );
  block.add_variable(id);
  const [obj, ...properties2] = action.name.split(".");
  const fn = is_contextual(action.component, template_scope, obj) ? block.renderer.reference(obj) : obj;
  if (properties2.length) {
    const member_expression = properties2.reduce((lhs, rhs) => x`${lhs}.${rhs}`, fn);
    block.event_listeners.push(
      x`@action_destroyer(${id} = ${member_expression}(${target}, ${snippet}))`
    );
  } else {
    block.event_listeners.push(
      x`@action_destroyer(${id} = ${fn}.call(null, ${target}, ${snippet}))`
    );
  }
  if (dependencies && dependencies.length > 0) {
    let condition = x`${id} && @is_function(${id}.update)`;
    if (dependencies.length > 0) {
      condition = x`${condition} && ${block.renderer.dirty(dependencies)}`;
    }
    block.chunks.update.push(b`if (${condition}) ${id}.update.call(null, ${snippet});`);
  }
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Body.js
var BodyWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/Body.js').default} node
   */
  constructor(renderer, block, parent, node) {
    super(renderer, block, parent, node);
    /** @type {import('./Element/EventHandler.js').default[]} */
    __publicField(this, "handlers");
    this.handlers = this.node.handlers.map((handler) => new EventHandlerWrapper(handler, this));
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} _parent_node
   * @param {import('estree').Identifier} _parent_nodes
   */
  render(block, _parent_node, _parent_nodes) {
    add_event_handlers(block, x`@_document.body`, this.handlers);
    add_actions(block, x`@_document.body`, this.node.actions);
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/DebugTag.js
var DebugTagWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/DebugTag.js').default} node
   * @param {boolean} _strip_whitespace
   * @param {import('./shared/Wrapper.js').default} _next_sibling
   */
  constructor(renderer, block, parent, node, _strip_whitespace, _next_sibling) {
    super(renderer, block, parent, node);
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} _parent_node
   * @param {import('estree').Identifier} _parent_nodes
   */
  render(block, _parent_node, _parent_nodes) {
    const { renderer } = this;
    const { component } = renderer;
    if (!renderer.options.dev)
      return;
    const { var_lookup } = component;
    const start = component.locate(this.node.start + 1);
    const end = { line: start.line, column: start.column + 6 };
    const loc = { start, end };
    const debug = {
      type: "DebuggerStatement",
      loc
    };
    if (this.node.expressions.length === 0) {
      block.chunks.create.push(debug);
      block.chunks.update.push(debug);
    } else {
      const log = {
        type: "Identifier",
        name: "log",
        loc
      };
      const dependencies = /* @__PURE__ */ new Set();
      this.node.expressions.forEach((expression) => {
        add_to_set(dependencies, expression.dependencies);
      });
      const contextual_identifiers = this.node.expressions.filter((e) => {
        const variable = var_lookup.get(
          /** @type {import('estree').Identifier} */
          e.node.name
        );
        return !(variable && variable.hoistable);
      }).map((e) => (
        /** @type {import('estree').Identifier} */
        e.node.name
      ));
      const logged_identifiers = this.node.expressions.map(
        (e) => p`${/** @type {import('estree').Identifier} */
        e.node.name}`
      );
      const debug_statements = b`
				${contextual_identifiers.map((name8) => b`const ${name8} = ${renderer.reference(name8)};`)}
				@_console.${log}({ ${logged_identifiers} });
				debugger;`;
      if (dependencies.size) {
        const condition = renderer.dirty(Array.from(dependencies));
        block.chunks.update.push(b`
					if (${condition}) {
						${debug_statements}
					}
				`);
      }
      block.chunks.create.push(b`{
				${debug_statements}
			}`);
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Document.js
var associated_events = {
  fullscreenElement: ["fullscreenchange"],
  visibilityState: ["visibilitychange"]
};
var readonly = /* @__PURE__ */ new Set(["fullscreenElement", "visibilityState"]);
var DocumentWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/Document.js').default} node
   */
  constructor(renderer, block, parent, node) {
    super(renderer, block, parent, node);
    /** @type {import('./Element/EventHandler.js').default[]} */
    __publicField(this, "handlers");
    this.handlers = this.node.handlers.map((handler) => new EventHandlerWrapper(handler, this));
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} _parent_node
   * @param {import('estree').Identifier} _parent_nodes
   */
  render(block, _parent_node, _parent_nodes) {
    const { renderer } = this;
    const { component } = renderer;
    const events2 = {};
    const bindings = {};
    add_event_handlers(block, x`@_document`, this.handlers);
    add_actions(block, x`@_document`, this.node.actions);
    this.node.bindings.forEach((binding) => {
      const binding_name = (
        /** @type {import('estree').Identifier} */
        binding.expression.node.name
      );
      if (readonly.has(binding.name)) {
        renderer.readonly.add(binding_name);
      }
      bindings[binding.name] = binding_name;
      const binding_events = associated_events[binding.name];
      const property = binding.name;
      binding_events.forEach((associated_event) => {
        if (!events2[associated_event])
          events2[associated_event] = [];
        events2[associated_event].push({
          name: binding_name,
          value: property
        });
      });
    });
    Object.keys(events2).forEach((event) => {
      const id = block.get_unique_name(`ondocument${event}`);
      const props = events2[event];
      renderer.add_to_context(id.name);
      const fn = renderer.reference(id.name);
      props.forEach((prop) => {
        renderer.meta_bindings.push(b`this._state.${prop.name} = @_document.${prop.value};`);
      });
      block.event_listeners.push(x`
				@listen(@_document, "${event}", ${fn})
			`);
      component.partly_hoisted.push(b`
				function ${id}() {
					${props.map((prop) => renderer.invalidate(prop.name, x`${prop.name} = @_document.${prop.value}`))}
				}
			`);
      block.chunks.init.push(b`
				@add_render_callback(${fn});
			`);
      component.has_reactive_assignments = true;
    });
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/EachBlock.js
var ElseBlockWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/ElseBlock.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {import('../Block.js').default} */
    __publicField(this, "block");
    /** @type {import('./Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {boolean} */
    __publicField(this, "is_dynamic");
    __publicField(this, "var", null);
    add_const_tags_context(renderer, this.node.const_tags);
    this.block = block.child({
      comment: create_debugging_comment(node, this.renderer.component),
      name: this.renderer.component.get_unique_name("create_else_block"),
      type: "else"
    });
    this.fragment = new FragmentWrapper(
      renderer,
      this.block,
      this.node.children,
      parent,
      strip_whitespace,
      next_sibling
    );
    this.is_dynamic = this.block.dependencies.size > 0;
  }
};
var EachBlockWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/EachBlock.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {import('../Block.js').default} */
    __publicField(this, "block");
    /** @type {import('./Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {ElseBlockWrapper} */
    __publicField(this, "else");
    /**
     * @type {{
     * 		create_each_block: import('estree').Identifier;
     * 		each_block_value: import('estree').Identifier;
     * 		get_each_context: import('estree').Identifier;
     * 		iterations: import('estree').Identifier;
     * 		fixed_length: number;
     * 		data_length: import('estree').Node | number;
     * 		view_length: import('estree').Node | number;
     * 	}}
     */
    __publicField(this, "vars");
    /** @type {Array<import('estree').Node | import('estree').Node[]>} */
    __publicField(this, "context_props");
    /** @type {import('estree').Identifier} */
    __publicField(this, "index_name");
    /** @type {Array<import('estree').Node | import('estree').Node[]>} */
    __publicField(this, "updates", []);
    /** @type {Set<string>} */
    __publicField(this, "dependencies");
    /** @type {import('estree').Identifier} */
    __publicField(this, "var", { type: "Identifier", name: "each" });
    const { dependencies } = node.expression;
    block.add_dependencies(dependencies);
    this.node.contexts.forEach((context) => {
      if (context.type !== "DestructuredVariable")
        return;
      renderer.add_to_context(context.key.name, true);
    });
    add_const_tags_context(renderer, this.node.const_tags);
    this.block = block.child({
      comment: create_debugging_comment(this.node, this.renderer.component),
      name: renderer.component.get_unique_name("create_each_block"),
      type: "each",
      // @ts-ignore todo: probably error
      key: (
        /** @type {string} */
        node.key
      ),
      bindings: new Map(block.bindings)
    });
    this.block.has_animation = this.node.has_animation;
    this.index_name = this.node.index ? { type: "Identifier", name: this.node.index } : renderer.component.get_unique_name(`${this.node.context}_index`);
    const fixed_length = node.expression.node.type === "ArrayExpression" && node.expression.node.elements.every((element) => element.type !== "SpreadElement") ? node.expression.node.elements.length : null;
    let c = this.node.start + 2;
    while (renderer.component.source[c] !== "e")
      c += 1;
    const start = renderer.component.locate(c);
    const end = { line: start.line, column: start.column + 4 };
    const length = {
      type: "Identifier",
      name: "length",
      loc: { start, end }
    };
    const each_block_value = renderer.component.get_unique_name(`${this.var.name}_value`);
    const iterations = block.get_unique_name(`${this.var.name}_blocks`);
    renderer.add_to_context(each_block_value.name, true);
    renderer.add_to_context(this.index_name.name, true);
    this.vars = {
      create_each_block: this.block.name,
      each_block_value,
      get_each_context: renderer.component.get_unique_name(`get_${this.var.name}_context`),
      iterations,
      // optimisation for array literal
      fixed_length,
      data_length: fixed_length === null ? x`${each_block_value}.${length}` : fixed_length,
      view_length: fixed_length === null ? x`${iterations}.length` : fixed_length
    };
    const object = get_object(node.expression.node);
    const store = object.type === "Identifier" && object.name[0] === "$" ? object.name.slice(1) : null;
    node.contexts.forEach((prop) => {
      if (prop.type !== "DestructuredVariable")
        return;
      this.block.bindings.set(prop.key.name, {
        object: this.vars.each_block_value,
        property: this.index_name,
        modifier: prop.modifier,
        snippet: prop.modifier(
          /** @type {import('estree').Node} */
          x`${this.vars.each_block_value}[${this.index_name}]`
        ),
        store
      });
    });
    if (this.node.index) {
      this.block.get_unique_name(this.node.index);
    }
    renderer.blocks.push(this.block);
    this.fragment = new FragmentWrapper(
      renderer,
      this.block,
      node.children,
      this,
      strip_whitespace,
      next_sibling
    );
    if (this.node.else) {
      this.else = new ElseBlockWrapper(
        renderer,
        block,
        this,
        this.node.else,
        strip_whitespace,
        next_sibling
      );
      renderer.blocks.push(this.else.block);
      if (this.else.is_dynamic) {
        this.block.add_dependencies(this.else.block.dependencies);
      }
    }
    block.add_dependencies(this.block.dependencies);
    if (this.block.has_outros || this.else && this.else.block.has_outros) {
      block.add_outro();
    }
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    if (this.fragment.nodes.length === 0)
      return;
    const { renderer } = this;
    const { component } = renderer;
    const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
    const snippet = x`@ensure_array_like(${this.node.expression.manipulate(block)})`;
    block.chunks.init.push(b`let ${this.vars.each_block_value} = ${snippet};`);
    const initial_anchor_node = {
      type: "Identifier",
      name: parent_node ? "null" : "#anchor"
    };
    const initial_mount_node = parent_node || { type: "Identifier", name: "#target" };
    const update_anchor_node = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || { type: "Identifier", name: "null" };
    const update_mount_node = this.get_update_mount_node(
      /** @type {import('estree').Identifier} */
      update_anchor_node
    );
    const args = {
      block,
      parent_node,
      parent_nodes,
      snippet,
      initial_anchor_node,
      initial_mount_node,
      update_anchor_node,
      update_mount_node
    };
    const all_dependencies = new Set(this.block.dependencies);
    this.node.expression.dynamic_dependencies().forEach((dependency) => {
      all_dependencies.add(dependency);
    });
    if (this.node.key) {
      this.node.key.dynamic_dependencies().forEach((dependency) => {
        all_dependencies.add(dependency);
      });
    }
    this.dependencies = all_dependencies;
    if (this.node.key) {
      this.render_keyed(args);
    } else {
      this.render_unkeyed(args);
    }
    if (this.block.has_intro_method || this.block.has_outro_method) {
      block.chunks.intro.push(b`
				for (let #i = 0; #i < ${this.vars.data_length}; #i += 1) {
					@transition_in(${this.vars.iterations}[#i]);
				}
			`);
    }
    if (needs_anchor) {
      block.add_element(
        /** @type {import('estree').Identifier} */
        update_anchor_node,
        x`@empty()`,
        parent_nodes && x`@empty()`,
        parent_node
      );
    }
    if (this.else) {
      let else_ctx = x`#ctx`;
      if (this.else.node.const_tags.length > 0) {
        const get_ctx_name = this.renderer.component.get_unique_name("get_else_ctx");
        this.renderer.blocks.push(b`
					function ${get_ctx_name}(#ctx) {
						const child_ctx = #ctx.slice();
						${add_const_tags(block, this.else.node.const_tags, "child_ctx")}
						return child_ctx;
					}
				`);
        else_ctx = x`${get_ctx_name}(#ctx)`;
      }
      const each_block_else = component.get_unique_name(`${this.var.name}_else`);
      block.chunks.init.push(b`let ${each_block_else} = null;`);
      block.chunks.init.push(b`
				if (!${this.vars.data_length}) {
					${each_block_else} = ${this.else.block.name}(${else_ctx});
				}
			`);
      block.chunks.create.push(b`
				if (${each_block_else}) {
					${each_block_else}.c();
				}
			`);
      if (this.renderer.options.hydratable) {
        block.chunks.claim.push(b`
					if (${each_block_else}) {
						${each_block_else}.l(${parent_nodes});
					}
				`);
      }
      block.chunks.mount.push(b`
				if (${each_block_else}) {
					${each_block_else}.m(${initial_mount_node}, ${initial_anchor_node});
				}
			`);
      const has_transitions = !!(this.else.block.has_intro_method || this.else.block.has_outro_method);
      const destroy_block_else = this.else.block.has_outro_method ? b`
					@group_outros();
					@transition_out(${each_block_else}, 1, 1, () => {
						${each_block_else} = null;
					});
					@check_outros();` : b`
					${each_block_else}.d(1);
					${each_block_else} = null;`;
      if (this.else.block.has_update_method) {
        this.updates.push(b`
					if (!${this.vars.data_length} && ${each_block_else}) {
						${each_block_else}.p(${else_ctx}, #dirty);
					} else if (!${this.vars.data_length}) {
						${each_block_else} = ${this.else.block.name}(${else_ctx});
						${each_block_else}.c();
						${has_transitions && b`@transition_in(${each_block_else}, 1);`}
						${each_block_else}.m(${update_mount_node}, ${update_anchor_node});
					} else if (${each_block_else}) {
						${destroy_block_else};
					}
				`);
      } else {
        this.updates.push(b`
					if (${this.vars.data_length}) {
						if (${each_block_else}) {
							${destroy_block_else};
						}
					} else if (!${each_block_else}) {
						${each_block_else} = ${this.else.block.name}(${else_ctx});
						${each_block_else}.c();
						${has_transitions && b`@transition_in(${each_block_else}, 1);`}
						${each_block_else}.m(${update_mount_node}, ${update_anchor_node});
					}
				`);
      }
      block.chunks.destroy.push(b`
				if (${each_block_else}) ${each_block_else}.d(${parent_node ? "" : "detaching"});
			`);
    }
    if (this.updates.length) {
      block.chunks.update.push(b`
				if (${block.renderer.dirty(Array.from(all_dependencies))}) {
					${this.updates}
				}
			`);
    }
    this.fragment.render(
      this.block,
      null,
      /** @type {import('estree').Identifier} */
      x`#nodes`
    );
    if (this.else) {
      this.else.fragment.render(
        this.else.block,
        null,
        /** @type {import('estree').Identifier} */
        x`#nodes`
      );
    }
    this.context_props = this.node.contexts.map((prop) => {
      if (prop.type === "DestructuredVariable") {
        const to_ctx = (name8) => renderer.context_lookup.has(name8) ? x`child_ctx[${renderer.context_lookup.get(name8).index}]` : (
          /** @type {import('estree').Node} */
          { type: "Identifier", name: name8 }
        );
        return b`child_ctx[${renderer.context_lookup.get(prop.key.name).index}] = ${prop.default_modifier(prop.modifier(x`list[i]`), to_ctx)};`;
      } else {
        const expression = new Expression(
          this.renderer.component,
          this.node,
          this.node.scope,
          prop.key
        );
        return b`const ${prop.property_name} = ${expression.manipulate(block, "child_ctx")};`;
      }
    });
    if (this.node.has_binding)
      this.context_props.push(
        b`child_ctx[${renderer.context_lookup.get(this.vars.each_block_value.name).index}] = list;`
      );
    if (this.node.has_binding || this.node.has_index_binding || this.node.index)
      this.context_props.push(
        b`child_ctx[${renderer.context_lookup.get(this.index_name.name).index}] = i;`
      );
    renderer.blocks.push(b`
			function ${this.vars.get_each_context}(#ctx, list, i) {
				const child_ctx = #ctx.slice();
				${this.context_props}
				${add_const_tags(this.block, this.node.const_tags, "child_ctx")}
				return child_ctx;
			}
		`);
  }
  /**
   * @param {{
   * 		block: import('../Block.js').default;
   * 		parent_node: import('estree').Identifier;
   * 		parent_nodes: import('estree').Identifier;
   * 		snippet: import('estree').Node;
   * 		initial_anchor_node: import('estree').Identifier;
   * 		initial_mount_node: import('estree').Identifier;
   * 		update_anchor_node: import('estree').Identifier;
   * 		update_mount_node: import('estree').Identifier;
   * 	}} params
   */
  render_keyed({
    block,
    parent_node,
    parent_nodes,
    snippet,
    initial_anchor_node,
    initial_mount_node,
    update_anchor_node,
    update_mount_node
  }) {
    const { create_each_block, iterations, data_length, view_length } = this.vars;
    const get_key = block.get_unique_name("get_key");
    const lookup = block.get_unique_name(`${this.var.name}_lookup`);
    block.add_variable(iterations, x`[]`);
    block.add_variable(lookup, x`new @_Map()`);
    if (this.fragment.nodes[0].is_dom_node()) {
      this.block.first = this.fragment.nodes[0].var;
    } else {
      this.block.first = this.block.get_unique_name("first");
      this.block.add_element(this.block.first, x`@empty()`, parent_nodes && x`@empty()`, null);
    }
    block.chunks.init.push(b`
			const ${get_key} = #ctx => ${this.node.key.manipulate(block)};

			${this.renderer.options.dev && b`@validate_each_keys(#ctx, ${this.vars.each_block_value}, ${this.vars.get_each_context}, ${get_key});`}
			for (let #i = 0; #i < ${data_length}; #i += 1) {
				let child_ctx = ${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i);
				let key = ${get_key}(child_ctx);
				${lookup}.set(key, ${iterations}[#i] = ${create_each_block}(key, child_ctx));
			}
		`);
    block.chunks.create.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].c();
			}
		`);
    if (parent_nodes && this.renderer.options.hydratable) {
      block.chunks.claim.push(b`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					${iterations}[#i].l(${parent_nodes});
				}
			`);
    }
    block.chunks.mount.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				if (${iterations}[#i]) {
					${iterations}[#i].m(${initial_mount_node}, ${initial_anchor_node});
				}
			}
		`);
    const dynamic = this.block.has_update_method;
    const destroy = this.node.has_animation ? this.block.has_outros ? "@fix_and_outro_and_destroy_block" : "@fix_and_destroy_block" : this.block.has_outros ? "@outro_and_destroy_block" : "@destroy_block";
    if (this.dependencies.size) {
      this.block.maintain_context = true;
      this.updates.push(b`
				${this.vars.each_block_value} = ${snippet};

				${this.block.has_outros && b`@group_outros();`}
				${this.node.has_animation && b`for (let #i = 0; #i < ${view_length}; #i += 1) ${iterations}[#i].r();`}
				${this.renderer.options.dev && b`@validate_each_keys(#ctx, ${this.vars.each_block_value}, ${this.vars.get_each_context}, ${get_key});`}
				${iterations} = @update_keyed_each(${iterations}, #dirty, ${get_key}, ${dynamic ? 1 : 0}, #ctx, ${this.vars.each_block_value}, ${lookup}, ${update_mount_node}, ${destroy}, ${create_each_block}, ${update_anchor_node}, ${this.vars.get_each_context});
				${this.node.has_animation && b`for (let #i = 0; #i < ${view_length}; #i += 1) ${iterations}[#i].a();`}
				${this.block.has_outros && b`@check_outros();`}
			`);
    }
    if (this.block.has_outros) {
      block.chunks.outro.push(b`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					@transition_out(${iterations}[#i]);
				}
			`);
    }
    block.chunks.destroy.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].d(${parent_node ? null : "detaching"});
			}
		`);
  }
  /**
   * @param {{
   * 		block: import('../Block.js').default;
   * 		parent_nodes: import('estree').Identifier;
   * 		snippet: import('estree').Node;
   * 		initial_anchor_node: import('estree').Identifier;
   * 		initial_mount_node: import('estree').Identifier;
   * 		update_anchor_node: import('estree').Identifier;
   * 		update_mount_node: import('estree').Identifier;
   * 	}} params
   */
  render_unkeyed({
    block,
    parent_nodes,
    snippet,
    initial_anchor_node,
    initial_mount_node,
    update_anchor_node,
    update_mount_node
  }) {
    const { create_each_block, iterations, fixed_length, data_length, view_length } = this.vars;
    block.chunks.init.push(b`
			let ${iterations} = [];

			for (let #i = 0; #i < ${data_length}; #i += 1) {
				${iterations}[#i] = ${create_each_block}(${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i));
			}
		`);
    block.chunks.create.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].c();
			}
		`);
    if (parent_nodes && this.renderer.options.hydratable) {
      block.chunks.claim.push(b`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					${iterations}[#i].l(${parent_nodes});
				}
			`);
    }
    block.chunks.mount.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				if (${iterations}[#i]) {
					${iterations}[#i].m(${initial_mount_node}, ${initial_anchor_node});
				}
			}
		`);
    if (this.dependencies.size) {
      const has_transitions = !!(this.block.has_intro_method || this.block.has_outro_method);
      const for_loop_body = this.block.has_update_method ? b`
					if (${iterations}[#i]) {
						${iterations}[#i].p(child_ctx, #dirty);
						${has_transitions && b`@transition_in(${this.vars.iterations}[#i], 1);`}
					} else {
						${iterations}[#i] = ${create_each_block}(child_ctx);
						${iterations}[#i].c();
						${has_transitions && b`@transition_in(${this.vars.iterations}[#i], 1);`}
						${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
					}
				` : has_transitions ? b`
						if (${iterations}[#i]) {
							@transition_in(${this.vars.iterations}[#i], 1);
						} else {
							${iterations}[#i] = ${create_each_block}(child_ctx);
							${iterations}[#i].c();
							@transition_in(${this.vars.iterations}[#i], 1);
							${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
						}
					` : b`
						if (!${iterations}[#i]) {
							${iterations}[#i] = ${create_each_block}(child_ctx);
							${iterations}[#i].c();
							${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
						}
					`;
      const start = this.block.has_update_method ? 0 : "#old_length";
      let remove_old_blocks;
      if (this.block.has_outros) {
        const out = block.get_unique_name("out");
        block.chunks.init.push(b`
					const ${out} = i => @transition_out(${iterations}[i], 1, 1, () => {
						${iterations}[i] = null;
					});
				`);
        remove_old_blocks = b`
					@group_outros();
					for (#i = ${data_length}; #i < ${view_length}; #i += 1) {
						${out}(#i);
					}
					@check_outros();
				`;
      } else {
        remove_old_blocks = b`
					for (${this.block.has_update_method ? null : x`#i = ${data_length}`}; #i < ${this.block.has_update_method ? view_length : "#old_length"}; #i += 1) {
						${iterations}[#i].d(1);
					}
					${!fixed_length && b`${view_length} = ${data_length};`}
				`;
      }
      const update = b`
				${!this.block.has_update_method && b`const #old_length = ${this.vars.each_block_value}.length;`}
				${this.vars.each_block_value} = ${snippet};

				let #i;
				for (#i = ${start}; #i < ${data_length}; #i += 1) {
					const child_ctx = ${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i);

					${for_loop_body}
				}

				${remove_old_blocks}
			`;
      this.updates.push(update);
    }
    if (this.block.has_outros) {
      block.chunks.outro.push(b`
				${iterations} = ${iterations}.filter(@_Boolean);
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					@transition_out(${iterations}[#i]);
				}
			`);
    }
    block.chunks.destroy.push(b`@destroy_each(${iterations}, detaching);`);
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Text.js
var TextWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/Text.js').default} node
   * @param {string} data
   */
  constructor(renderer, block, parent, node, data) {
    super(renderer, block, parent, node);
    /** @type {string} */
    __publicField(this, "_data");
    /** @type {boolean} */
    __publicField(this, "skip");
    /** @type {import('estree').Identifier} */
    __publicField(this, "var");
    this.skip = this.node.should_skip();
    this._data = data;
    this.var = /** @type {unknown} */
    /** @type {import('estree').Identifier} */
    this.skip ? null : x`t`;
  }
  use_space() {
    return this.node.use_space();
  }
  set data(value) {
    this.node.data = this._data = value;
  }
  get data() {
    return this._data;
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    if (this.skip)
      return;
    const use_space = this.use_space();
    const string_literal2 = {
      type: "Literal",
      value: this.data,
      loc: {
        start: this.renderer.locate(this.node.start),
        end: this.renderer.locate(this.node.end)
      }
    };
    block.add_element(
      this.var,
      use_space ? x`@space()` : x`@text(${string_literal2})`,
      parent_nodes && (use_space ? x`@claim_space(${parent_nodes})` : x`@claim_text(${parent_nodes}, ${string_literal2})`),
      /** @type {import('estree').Identifier} */
      parent_node
    );
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Element/fix_attribute_casing.js
var svg_attributes = "accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan".split(
  " "
);
var svg_attribute_lookup = /* @__PURE__ */ new Map();
svg_attributes.forEach((name8) => {
  svg_attribute_lookup.set(name8.toLowerCase(), name8);
});
function fix_attribute_casing(name8) {
  name8 = name8.toLowerCase();
  return svg_attribute_lookup.get(name8) || name8;
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Element/handle_select_value_binding.js
function handle_select_value_binding(attr, dependencies) {
  const { parent } = attr;
  if (parent.node.name === "select") {
    parent.select_binding_dependencies = dependencies;
    dependencies.forEach((prop) => {
      parent.renderer.component.indirect_dependencies.set(prop, /* @__PURE__ */ new Set());
    });
  }
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Element/Attribute.js
var non_textlike_input_types = /* @__PURE__ */ new Set([
  "button",
  "checkbox",
  "color",
  "date",
  "datetime-local",
  "file",
  "hidden",
  "image",
  "radio",
  "range",
  "reset",
  "submit"
]);
var BaseAttributeWrapper = class {
  /**
   * @param {import('./index.js').default} parent
   * @param {import('../../Block.js').default} block
   * @param {import('../../../nodes/Attribute.js').default} node
   */
  constructor(parent, block, node) {
    /** @type {import('../../../nodes/Attribute.js').default} */
    __publicField(this, "node");
    /** @type {import('./index.js').default} */
    __publicField(this, "parent");
    this.node = node;
    this.parent = parent;
    if (node.dependencies.size > 0) {
      block.add_dependencies(node.dependencies);
    }
  }
  /** @param {import('../../Block.js').default} _block */
  render(_block) {
  }
};
var regex_minus_sign2 = /-/;
var regex_invalid_variable_identifier_characters2 = /[^a-zA-Z_$]/g;
var AttributeWrapper = class extends BaseAttributeWrapper {
  constructor(parent, block, node) {
    super(parent, block, node);
    /** @type {any} */
    __publicField(this, "metadata");
    /** @type {string} */
    __publicField(this, "name");
    /** @type {string} */
    __publicField(this, "property_name");
    /** @type {boolean} */
    __publicField(this, "is_indirectly_bound_value");
    /** @type {boolean} */
    __publicField(this, "is_src");
    /** @type {boolean} */
    __publicField(this, "is_srcset");
    /** @type {boolean} */
    __publicField(this, "is_select_value_attribute");
    /** @type {boolean} */
    __publicField(this, "is_input_value");
    /** @type {boolean} */
    __publicField(this, "should_cache");
    /** @type {import('estree').Identifier} */
    __publicField(this, "last");
    if (node.dependencies.size > 0) {
      if (this.parent.node.name === "option" && node.name === "value") {
        let select = this.parent;
        while (select && (select.node.type !== "Element" || select.node.name !== "select")) {
          select = select.parent;
        }
        if (select && select.select_binding_dependencies) {
          select.select_binding_dependencies.forEach((prop) => {
            this.node.dependencies.forEach((dependency) => {
              if (this.node.scope.is_top_level(dependency)) {
                this.parent.renderer.component.indirect_dependencies.get(prop).add(dependency);
              }
            });
          });
        }
      }
      if (node.name === "value") {
        handle_select_value_binding(this, node.dependencies);
        this.parent.has_dynamic_value = true;
      }
    }
    if (this.parent.node.namespace == namespaces.foreign || this.parent.node.name.includes("-")) {
      this.name = this.node.name;
      this.metadata = this.get_metadata();
      this.is_indirectly_bound_value = false;
      this.property_name = null;
      this.is_select_value_attribute = false;
      this.is_input_value = false;
    } else {
      this.name = fix_attribute_casing(this.node.name);
      this.metadata = this.get_metadata();
      this.is_indirectly_bound_value = is_indirectly_bound_value(this);
      this.property_name = this.is_indirectly_bound_value ? "__value" : this.metadata && this.metadata.property_name;
      this.is_select_value_attribute = this.name === "value" && this.parent.node.name === "select";
      this.is_input_value = this.name === "value" && this.parent.node.name === "input";
    }
    this.is_src = this.name === "src" && (!this.parent.node.namespace || this.parent.node.namespace === namespaces.html);
    this.is_srcset = this.name === "srcset" && (!this.parent.node.namespace || this.parent.node.namespace === namespaces.html);
    this.should_cache = should_cache(this);
  }
  /** @param {import('../../Block.js').default} block */
  render(block) {
    const element = this.parent;
    const { name: name8, property_name, should_cache: should_cache2, is_indirectly_bound_value: is_indirectly_bound_value2 } = this;
    const method = regex_minus_sign2.test(element.node.name) ? "@set_custom_element_data" : name8.slice(0, 6) === "xlink:" ? "@xlink_attr" : "@attr";
    const is_legacy_input_type = element.renderer.component.compile_options.legacy && name8 === "type" && this.parent.node.name === "input";
    const dependencies = this.get_dependencies();
    const value = this.get_value(block);
    let updater;
    const init = this.get_init(block, value);
    if (is_legacy_input_type) {
      block.chunks.hydrate.push(b`@set_input_type(${element.var}, ${init});`);
      updater = b`@set_input_type(${element.var}, ${should_cache2 ? this.last : value});`;
    } else if (this.is_select_value_attribute) {
      const is_multiple_select = element.node.get_static_attribute_value("multiple");
      if (is_multiple_select) {
        updater = b`@select_options(${element.var}, ${value});`;
      } else {
        updater = b`@select_option(${element.var}, ${value});`;
      }
      block.chunks.mount.push(b`
				${updater}
			`);
    } else if (this.is_src) {
      block.chunks.hydrate.push(
        b`if (!@src_url_equal(${element.var}.src, ${init})) ${method}(${element.var}, "${name8}", ${this.last});`
      );
      updater = b`${method}(${element.var}, "${name8}", ${should_cache2 ? this.last : value});`;
    } else if (this.is_srcset) {
      block.chunks.hydrate.push(
        b`if (!@srcset_url_equal(${element.var}, ${init})) ${method}(${element.var}, "${name8}", ${this.last});`
      );
      updater = b`${method}(${element.var}, "${name8}", ${should_cache2 ? this.last : value});`;
    } else if (property_name) {
      block.chunks.hydrate.push(b`${element.var}.${property_name} = ${init};`);
      updater = block.renderer.options.dev ? b`@prop_dev(${element.var}, "${property_name}", ${should_cache2 ? this.last : value});` : b`${element.var}.${property_name} = ${should_cache2 ? this.last : value};`;
    } else {
      block.chunks.hydrate.push(b`${method}(${element.var}, "${name8}", ${init});`);
      updater = b`${method}(${element.var}, "${name8}", ${should_cache2 ? this.last : value});`;
    }
    if (is_indirectly_bound_value2) {
      const update_value = b`@set_input_value(${element.var}, ${element.var}.__value);`;
      block.chunks.hydrate.push(update_value);
      updater = b`
				${updater}
				${update_value};
			`;
    }
    if (this.node.name === "value" && dependencies.length > 0) {
      if (this.parent.bindings.some((binding) => binding.node.name === "group")) {
        this.parent.dynamic_value_condition = block.get_unique_name("value_has_changed");
        block.add_variable(this.parent.dynamic_value_condition, x`false`);
        updater = b`
					${updater}
					${this.parent.dynamic_value_condition} = true;
				`;
      }
    }
    if (dependencies.length > 0) {
      const condition = this.get_dom_update_conditions(block, block.renderer.dirty(dependencies));
      block.chunks.update.push(b`
				if (${condition}) {
					${updater}
				}`);
    }
    if (name8 === "autofocus") {
      block.autofocus = {
        element_var: element.var,
        condition_expression: this.node.is_true ? void 0 : value
      };
    }
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {any} value
   */
  get_init(block, value) {
    this.last = this.should_cache && block.get_unique_name(
      `${this.parent.var.name}_${this.name.replace(
        regex_invalid_variable_identifier_characters2,
        "_"
      )}_value`
    );
    if (this.should_cache)
      block.add_variable(this.last);
    return this.should_cache ? x`${this.last} = ${value}` : value;
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Node} dependency_condition
   */
  get_dom_update_conditions(block, dependency_condition) {
    const { property_name, should_cache: should_cache2, last } = this;
    const element = this.parent;
    const value = this.get_value(block);
    let condition = dependency_condition;
    if (should_cache2) {
      condition = this.is_src ? x`${condition} && (!@src_url_equal(${element.var}.src, (${last} = ${value})))` : x`${condition} && (${last} !== (${last} = ${value}))`;
    }
    if (this.is_input_value) {
      const type = element.node.get_static_attribute_value("type");
      if (type !== true && !non_textlike_input_types.has(type)) {
        condition = x`${condition} && ${element.var}.${property_name} !== ${should_cache2 ? last : value}`;
      }
    }
    if (block.has_outros) {
      condition = x`!#current || ${condition}`;
    }
    return condition;
  }
  get_dependencies() {
    const node_dependencies = this.node.get_dependencies();
    const dependencies = new Set(node_dependencies);
    node_dependencies.forEach((prop) => {
      const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(prop);
      if (indirect_dependencies) {
        indirect_dependencies.forEach((indirect_dependency) => {
          dependencies.add(indirect_dependency);
        });
      }
    });
    return Array.from(dependencies);
  }
  get_metadata() {
    if (this.parent.node.namespace)
      return null;
    const metadata = attribute_lookup[this.name];
    if (metadata && metadata.applies_to && !metadata.applies_to.includes(this.parent.node.name))
      return null;
    return metadata;
  }
  /** @param {import('../../Block.js').default} block */
  get_value(block) {
    if (this.node.is_true) {
      if (this.metadata && boolean_attributes.has(this.metadata.property_name.toLowerCase())) {
        return x`true`;
      }
      return x`""`;
    }
    if (this.node.chunks.length === 0)
      return x`""`;
    if (this.node.chunks.length === 1) {
      return this.node.chunks[0].type === "Text" ? string_literal(
        /** @type {import('../../../nodes/Text.js').default} */
        this.node.chunks[0].data
      ) : (
        /** @type {import('../../../nodes/shared/Expression.js').default} */
        this.node.chunks[0].manipulate(block)
      );
    }
    let value = this.node.name === "class" ? this.get_class_name_text(block) : this.render_chunks(block).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
    if (this.node.chunks[0].type !== "Text") {
      value = x`"" + ${value}`;
    }
    return value;
  }
  /** @param {import('../../Block.js').default} block */
  get_class_name_text(block) {
    const scoped_css = this.node.chunks.some(
      (chunk) => chunk.synthetic
    );
    const rendered = this.render_chunks(block);
    if (scoped_css && rendered.length === 2) {
      rendered[0] = x`@null_to_empty(${rendered[0]})`;
    }
    return rendered.reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
  }
  /** @param {import('../../Block.js').default} block */
  render_chunks(block) {
    return this.node.chunks.map((chunk) => {
      if (chunk.type === "Text") {
        return string_literal(chunk.data);
      }
      return chunk.manipulate(block);
    });
  }
  stringify() {
    if (this.node.is_true)
      return "";
    const value = this.node.chunks;
    if (value.length === 0)
      return '=""';
    return `="${value.map((chunk) => {
      return chunk.type === "Text" ? chunk.data.replace(regex_double_quotes, '\\"') : `\${${chunk.manipulate()}}`;
    }).join("")}"`;
  }
};
var attribute_lookup = {
  allowfullscreen: { property_name: "allowFullscreen", applies_to: ["iframe"] },
  allowpaymentrequest: { property_name: "allowPaymentRequest", applies_to: ["iframe"] },
  async: { applies_to: ["script"] },
  autofocus: { applies_to: ["button", "input", "keygen", "select", "textarea"] },
  autoplay: { applies_to: ["audio", "video"] },
  checked: { applies_to: ["input"] },
  controls: { applies_to: ["audio", "video"] },
  default: { applies_to: ["track"] },
  defer: { applies_to: ["script"] },
  disabled: {
    applies_to: [
      "button",
      "fieldset",
      "input",
      "keygen",
      "optgroup",
      "option",
      "select",
      "textarea"
    ]
  },
  formnovalidate: { property_name: "formNoValidate", applies_to: ["button", "input"] },
  hidden: {},
  indeterminate: { applies_to: ["input"] },
  inert: {},
  ismap: { property_name: "isMap", applies_to: ["img"] },
  loop: { applies_to: ["audio", "bgsound", "video"] },
  multiple: { applies_to: ["input", "select"] },
  muted: { applies_to: ["audio", "video"] },
  nomodule: { property_name: "noModule", applies_to: ["script"] },
  novalidate: { property_name: "noValidate", applies_to: ["form"] },
  open: { applies_to: ["details", "dialog"] },
  playsinline: { property_name: "playsInline", applies_to: ["video"] },
  readonly: { property_name: "readOnly", applies_to: ["input", "textarea"] },
  required: { applies_to: ["input", "select", "textarea"] },
  reversed: { applies_to: ["ol"] },
  selected: { applies_to: ["option"] },
  value: {
    applies_to: [
      "button",
      "option",
      "input",
      "li",
      "meter",
      "progress",
      "param",
      "select",
      "textarea"
    ]
  }
};
Object.keys(attribute_lookup).forEach((name8) => {
  const metadata = attribute_lookup[name8];
  if (!metadata.property_name)
    metadata.property_name = name8;
});
function should_cache(attribute) {
  return attribute.is_src || attribute.is_srcset || attribute.node.should_cache();
}
var regex_contains_checked_or_group = /checked|group/;
function is_indirectly_bound_value(attribute) {
  const element = attribute.parent;
  return attribute.name === "value" && (element.node.name === "option" || // TODO check it's actually bound
  element.node.name === "input" && element.node.bindings.some(
    (binding) => regex_contains_checked_or_group.test(binding.name)
  ));
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Element/StyleAttribute.js
var StyleAttributeWrapper = class extends AttributeWrapper {
  /** @param {import('../../Block.js').default} block */
  render(block) {
    const style_props = optimize_style(this.node.chunks);
    if (!style_props)
      return super.render(block);
    style_props.forEach((prop) => {
      let value;
      if (is_dynamic2(prop.value)) {
        const prop_dependencies = /* @__PURE__ */ new Set();
        value = prop.value.map((chunk) => {
          if (chunk.type === "Text") {
            return string_literal(chunk.data);
          } else {
            add_to_set(prop_dependencies, chunk.dynamic_dependencies());
            return chunk.manipulate(block);
          }
        }).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
        if (prop_dependencies.size) {
          let condition = block.renderer.dirty(Array.from(prop_dependencies));
          if (block.has_outros) {
            condition = x`!#current || ${condition}`;
          }
          const update = b`
						if (${condition}) {
							@set_style(${this.parent.var}, "${prop.key}", ${value}, ${prop.important ? 1 : null});
						}`;
          block.chunks.update.push(update);
        }
      } else {
        value = string_literal(
          /** @type {import('../../../nodes/Text.js').default} */
          prop.value[0].data
        );
      }
      block.chunks.hydrate.push(
        b`@set_style(${this.parent.var}, "${prop.key}", ${value}, ${prop.important ? 1 : null});`
      );
    });
  }
};
var regex_style_prop_key = /^\s*([\w-]+):\s*/;
function optimize_style(value) {
  const props = [];
  let chunks = value.slice();
  while (chunks.length) {
    const chunk = chunks[0];
    if (chunk.type !== "Text")
      return null;
    const key_match = regex_style_prop_key.exec(chunk.data);
    if (!key_match)
      return null;
    const key = key_match[1];
    const offset = key_match.index + key_match[0].length;
    const remaining_data = chunk.data.slice(offset);
    if (remaining_data) {
      chunks[0] = /** @type {import('../../../nodes/Text.js').default} */
      {
        start: chunk.start + offset,
        end: chunk.end,
        type: "Text",
        data: remaining_data
      };
    } else {
      chunks.shift();
    }
    const result = get_style_value(chunks);
    props.push({ key, value: result.value, important: result.important });
    chunks = result.chunks;
  }
  return props;
}
var regex_important_flag = /\s*!important\s*$/;
var regex_semicolon_or_whitespace = /[;\s]/;
function get_style_value(chunks) {
  const value = [];
  let in_url = false;
  let quote_mark = null;
  let escaped2 = false;
  let closed = false;
  while (chunks.length && !closed) {
    const chunk = chunks.shift();
    if (chunk.type === "Text") {
      let c = 0;
      while (c < chunk.data.length) {
        const char = chunk.data[c];
        if (escaped2) {
          escaped2 = false;
        } else if (char === "\\") {
          escaped2 = true;
        } else if (char === quote_mark) {
          quote_mark = null;
        } else if (char === '"' || char === "'") {
          quote_mark = char;
        } else if (char === ")" && in_url) {
          in_url = false;
        } else if (char === "u" && chunk.data.slice(c, c + 4) === "url(") {
          in_url = true;
        } else if (char === ";" && !in_url && !quote_mark) {
          closed = true;
          break;
        }
        c += 1;
      }
      if (c > 0) {
        value.push(
          /** @type {import('../../../nodes/Text.js').default} */
          {
            type: "Text",
            start: chunk.start,
            end: chunk.start + c,
            data: chunk.data.slice(0, c)
          }
        );
      }
      while (regex_semicolon_or_whitespace.test(chunk.data[c]))
        c += 1;
      const remaining_data = chunk.data.slice(c);
      if (remaining_data) {
        chunks.unshift(
          /** @type {import('../../../nodes/Text.js').default} */
          {
            start: chunk.start + c,
            end: chunk.end,
            type: "Text",
            data: remaining_data
          }
        );
        break;
      }
    } else {
      value.push(chunk);
    }
  }
  let important = false;
  const last_chunk = value[value.length - 1];
  if (last_chunk && last_chunk.type === "Text" && regex_important_flag.test(last_chunk.data)) {
    important = true;
    last_chunk.data = last_chunk.data.replace(regex_important_flag, "");
    if (!last_chunk.data)
      value.pop();
  }
  return {
    chunks,
    value,
    important
  };
}
function is_dynamic2(value) {
  return value.length > 1 || value[0].type !== "Text";
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Element/SpreadAttribute.js
var SpreadAttributeWrapper = class extends BaseAttributeWrapper {
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/mark_each_block_bindings.js
function mark_each_block_bindings(parent, binding) {
  binding.expression.references.forEach((name8) => {
    const each_block = parent.node.scope.get_owner(name8);
    if (each_block) {
      each_block.has_binding = true;
    }
  });
  if (binding.name === "group") {
    const add_index_binding = (name8) => {
      const each_block = parent.node.scope.get_owner(name8);
      if (each_block.type === "EachBlock") {
        each_block.has_index_binding = true;
        for (const dep of each_block.expression.contextual_dependencies) {
          add_index_binding(dep);
        }
      }
    };
    for (const name8 of binding.expression.contextual_dependencies) {
      add_index_binding(name8);
    }
  }
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Element/Binding.js
var BindingWrapper = class {
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('../../../nodes/Binding.js').default} node
   * @param {import('./index.js').default | import('../InlineComponent/index.js').default} parent
   */
  constructor(block, node, parent) {
    /** @type {import('../../../nodes/Binding.js').default} */
    __publicField(this, "node");
    /** @type {import('./index.js').default | import('../InlineComponent/index.js').default} */
    __publicField(this, "parent");
    /** @type {string} */
    __publicField(this, "object");
    /**
     * @type {{
     * 		uses_context: boolean;
     * 		mutation: import('estree').Node | import('estree').Node[];
     * 		contextual_dependencies: Set<string>;
     * 		lhs?: import('estree').Node;
     * 	}}
     */
    __publicField(this, "handler");
    /** @type {import('estree').Node} */
    __publicField(this, "snippet");
    /** @type {boolean} */
    __publicField(this, "is_readonly");
    /** @type {boolean} */
    __publicField(this, "needs_lock");
    /** @type {import('../../Renderer.js').BindingGroup} */
    __publicField(this, "binding_group");
    this.node = node;
    this.parent = parent;
    const { dependencies } = this.node.expression;
    block.add_dependencies(dependencies);
    handle_select_value_binding(this, dependencies);
    if (node.is_contextual) {
      mark_each_block_bindings(this.parent, this.node);
    }
    this.object = get_object(this.node.expression.node).name;
    if (this.node.name === "group") {
      this.binding_group = get_binding_group(parent.renderer, this, block);
    }
    this.handler = get_event_handler(
      this,
      parent.renderer,
      block,
      this.object,
      this.node.raw_expression
    );
    this.snippet = this.node.expression.manipulate(block);
    this.is_readonly = this.node.is_readonly;
    this.needs_lock = this.node.name === "currentTime";
  }
  get_dependencies() {
    const dependencies = new Set(this.node.expression.dependencies);
    this.node.expression.dependencies.forEach((prop) => {
      const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(prop);
      if (indirect_dependencies) {
        indirect_dependencies.forEach((indirect_dependency) => {
          dependencies.add(indirect_dependency);
        });
      }
    });
    if (this.binding_group) {
      this.binding_group.list_dependencies.forEach((dep) => dependencies.add(dep));
    }
    return dependencies;
  }
  get_update_dependencies() {
    const object = this.object;
    const dependencies = /* @__PURE__ */ new Set();
    if (this.node.expression.template_scope.names.has(object)) {
      this.node.expression.template_scope.dependencies_for_name.get(object).forEach((name8) => dependencies.add(name8));
    } else {
      dependencies.add(object);
    }
    const result = new Set(dependencies);
    dependencies.forEach((dependency) => {
      const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(dependency);
      if (indirect_dependencies) {
        indirect_dependencies.forEach((indirect_dependency) => {
          result.add(indirect_dependency);
        });
      }
    });
    return result;
  }
  is_readonly_media_attribute() {
    return this.node.is_readonly_media_attribute();
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} lock
   */
  render(block, lock) {
    if (this.is_readonly)
      return;
    const { parent } = this;
    const update_conditions = this.needs_lock ? [x`!${lock}`] : [];
    const mount_conditions = [];
    let update_or_condition = null;
    const dependency_array = Array.from(this.get_dependencies());
    if (dependency_array.length > 0) {
      update_conditions.push(block.renderer.dirty(dependency_array));
    }
    if (parent.node.name === "input") {
      const type = parent.node.get_static_attribute_value("type");
      if (type === null || type === "" || type === "text" || type === "email" || type === "password" || type === "search" || type === "url") {
        update_conditions.push(x`${parent.var}.${this.node.name} !== ${this.snippet}`);
      } else if (type === "number") {
        update_conditions.push(x`@to_number(${parent.var}.${this.node.name}) !== ${this.snippet}`);
      }
    }
    let update_dom = get_dom_updater(parent, this, false);
    let mount_dom = get_dom_updater(parent, this, true);
    switch (this.node.name) {
      case "group": {
        block.renderer.add_to_context("$$binding_groups");
        this.binding_group.add_element(block, this.parent.var);
        if (
          /** @type {import('./index.js').default} */
          this.parent.has_dynamic_value
        ) {
          update_or_condition = /** @type {import('./index.js').default} */
          this.parent.dynamic_value_condition;
        }
        break;
      }
      case "textContent":
        update_conditions.push(x`${this.snippet} !== ${parent.var}.textContent`);
        mount_conditions.push(x`${this.snippet} !== void 0`);
        break;
      case "innerText":
        update_conditions.push(x`${this.snippet} !== ${parent.var}.innerText`);
        mount_conditions.push(x`${this.snippet} !== void 0`);
        break;
      case "innerHTML":
        update_conditions.push(x`${this.snippet} !== ${parent.var}.innerHTML`);
        mount_conditions.push(x`${this.snippet} !== void 0`);
        break;
      case "currentTime":
        update_conditions.push(x`!@_isNaN(${this.snippet})`);
        mount_dom = null;
        break;
      case "playbackRate":
      case "volume":
        update_conditions.push(x`!@_isNaN(${this.snippet})`);
        mount_conditions.push(x`!@_isNaN(${this.snippet})`);
        break;
      case "paused": {
        const last = block.get_unique_name(`${parent.var.name}_is_paused`);
        block.add_variable(last, x`true`);
        update_conditions.push(x`${last} !== (${last} = ${this.snippet})`);
        update_dom = b`${parent.var}[${last} ? "pause" : "play"]();`;
        mount_dom = null;
        break;
      }
      case "value":
        if (parent.node.get_static_attribute_value("type") === "file") {
          update_dom = null;
          mount_dom = null;
        }
    }
    if (update_dom) {
      if (update_conditions.length > 0) {
        let condition = update_conditions.reduce((lhs, rhs) => x`${lhs} && ${rhs}`);
        if (update_or_condition)
          condition = x`${update_or_condition} || (${condition})`;
        block.chunks.update.push(b`
					if (${condition}) {
						${update_dom}
					}
				`);
      } else {
        block.chunks.update.push(update_dom);
      }
    }
    if (mount_dom) {
      if (mount_conditions.length > 0) {
        const condition = mount_conditions.reduce((lhs, rhs) => x`${lhs} && ${rhs}`);
        block.chunks.mount.push(b`
					if (${condition}) {
						${mount_dom}
					}
				`);
      } else {
        block.chunks.mount.push(mount_dom);
      }
    }
  }
};
function get_dom_updater(element, binding, mounting) {
  const { node } = element;
  if (binding.is_readonly_media_attribute()) {
    return null;
  }
  if (binding.node.name === "this") {
    return null;
  }
  if (node.name === "select") {
    return node.get_static_attribute_value("multiple") === true ? b`@select_options(${element.var}, ${binding.snippet})` : mounting ? b`@select_option(${element.var}, ${binding.snippet}, true)` : b`@select_option(${element.var}, ${binding.snippet})`;
  }
  if (binding.node.name === "group") {
    const type = node.get_static_attribute_value("type");
    const condition = type === "checkbox" ? x`~(${binding.snippet} || []).indexOf(${element.var}.__value)` : x`${element.var}.__value === ${binding.snippet}`;
    return b`${element.var}.checked = ${condition};`;
  }
  if (binding.node.name === "value") {
    return b`@set_input_value(${element.var}, ${binding.snippet});`;
  }
  return b`${element.var}.${binding.node.name} = ${binding.snippet};`;
}
function get_binding_group(renderer, binding, block) {
  const value = binding.node;
  const { parts } = flatten_reference(value.raw_expression);
  let keypath = parts.join(".");
  const contexts = [];
  const contextual_dependencies = /* @__PURE__ */ new Set();
  const { template_scope } = value.expression;
  const add_contextual_dependency = (dep) => {
    contextual_dependencies.add(dep);
    const owner = template_scope.get_owner(dep);
    if (owner.type === "EachBlock") {
      for (const dep2 of owner.expression.contextual_dependencies) {
        add_contextual_dependency(dep2);
      }
    }
  };
  for (const dep of value.expression.contextual_dependencies) {
    add_contextual_dependency(dep);
  }
  for (const dep of contextual_dependencies) {
    const context = block.bindings.get(dep);
    let key;
    let name8;
    if (context) {
      key = context.object.name;
      name8 = context.property.name;
    } else {
      key = dep;
      name8 = dep;
    }
    keypath = `${key}@${keypath}`;
    contexts.push(name8);
  }
  if (!renderer.binding_groups.has(keypath)) {
    const index = renderer.binding_groups.size;
    const list_dependencies = /* @__PURE__ */ new Set();
    let parent = value.parent;
    while (parent) {
      if (parent.type === "EachBlock") {
        for (const dep of parent.expression.dynamic_dependencies()) {
          list_dependencies.add(dep);
        }
      }
      parent = parent.parent;
    }
    const elements = /* @__PURE__ */ new Map();
    contexts.forEach((context) => {
      renderer.add_to_context(context, true);
    });
    renderer.binding_groups.set(keypath, {
      binding_group: () => {
        let obj = x`$$binding_groups[${index}]`;
        if (contexts.length > 0) {
          contexts.forEach((secondary_index) => {
            obj = x`${obj}[${secondary_index}]`;
          });
        }
        return obj;
      },
      contexts,
      list_dependencies,
      keypath,
      add_element(block2, element) {
        if (!elements.has(block2)) {
          elements.set(block2, []);
        }
        elements.get(block2).push(element);
      },
      render(block2) {
        const local_name = block2.get_unique_name("binding_group");
        const binding_group2 = block2.renderer.reference("$$binding_groups");
        block2.add_variable(local_name);
        if (contexts.length > 0) {
          const indexes = {
            type: "ArrayExpression",
            elements: contexts.map((name8) => block2.renderer.reference(name8))
          };
          block2.chunks.init.push(
            b`${local_name} = @init_binding_group_dynamic(${binding_group2}[${index}], ${indexes})`
          );
          block2.chunks.update.push(
            b`if (${block2.renderer.dirty(
              Array.from(list_dependencies)
            )}) ${local_name}.u(${indexes})`
          );
        } else {
          block2.chunks.init.push(
            b`${local_name} = @init_binding_group(${binding_group2}[${index}])`
          );
        }
        block2.chunks.hydrate.push(b`${local_name}.p(${elements.get(block2)})`);
        block2.chunks.destroy.push(b`${local_name}.r()`);
      }
    });
  }
  const binding_group = renderer.binding_groups.get(keypath);
  block.binding_groups.add(binding_group);
  return binding_group;
}
function get_event_handler(binding, renderer, block, name8, lhs) {
  const contextual_dependencies = new Set(binding.node.expression.contextual_dependencies);
  const context = block.bindings.get(name8);
  let set_store;
  if (context) {
    const { object, property, store, snippet } = context;
    lhs = replace_object(lhs, snippet);
    contextual_dependencies.add(object.name);
    contextual_dependencies.add(property.name);
    contextual_dependencies.delete(name8);
    if (store) {
      set_store = b`${store}.set(${`$${store}`});`;
    }
  } else {
    const object = get_object(lhs);
    if (object.name[0] === "$") {
      const store = object.name.slice(1);
      set_store = b`${store}.set(${object.name});`;
    }
  }
  const value = get_value_from_dom(renderer, binding.parent, binding, contextual_dependencies);
  const mutation = b`
		${lhs} = ${value};
		${set_store}
	`;
  return {
    uses_context: binding.node.is_contextual || binding.node.expression.uses_context,
    mutation,
    contextual_dependencies,
    lhs
  };
}
function get_value_from_dom(_renderer, element, binding, contextual_dependencies) {
  const { node } = element;
  const { name: name8 } = binding.node;
  if (name8 === "this") {
    return x`$$value`;
  }
  if (regex_box_size.test(name8)) {
    return x`@ResizeObserverSingleton.entries.get(this)?.${name8}`;
  }
  if (node.name === "select") {
    return node.get_static_attribute_value("multiple") === true ? x`@select_multiple_value(this)` : x`@select_value(this)`;
  }
  const type = node.get_static_attribute_value("type");
  if (name8 === "group") {
    if (type === "checkbox") {
      const { binding_group, contexts } = binding.binding_group;
      add_to_set(contextual_dependencies, contexts);
      return x`@get_binding_group_value(${binding_group()}, this.__value, this.checked)`;
    }
    return x`this.__value`;
  }
  if (type === "range" || type === "number") {
    return x`@to_number(this.${name8})`;
  }
  if (name8 === "buffered" || name8 === "seekable" || name8 === "played") {
    return x`@time_ranges_to_array(this.${name8})`;
  }
  return x`this.${name8}`;
}

// node_modules/svelte/src/compiler/compile/utils/compare_node.js
function compare_node(a, b2) {
  if (a === b2)
    return true;
  if (!a || !b2)
    return false;
  if (a.type !== b2.type)
    return false;
  switch (a.type) {
    case "Identifier":
      return a.name === /** @type {import('estree').Identifier} */
      b2.name;
    case "MemberExpression":
      return compare_node(
        a.object,
        /** @type {import('estree').MemberExpression} */
        b2.object
      ) && compare_node(
        a.property,
        /** @type {import('estree').MemberExpression} */
        b2.property
      ) && a.computed === /** @type {import('estree').MemberExpression} */
      b2.computed;
    case "Literal":
      return a.value === /** @type {import('estree').Literal} */
      b2.value;
  }
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/bind_this.js
function bind_this(component, block, binding, variable) {
  const fn = component.get_unique_name(`${variable.name}_binding`);
  block.renderer.add_to_context(fn.name);
  const callee = block.renderer.reference(fn.name);
  const { contextual_dependencies, mutation } = binding.handler;
  const dependencies = binding.get_update_dependencies();
  const body = b`
		${mutation}
		${Array.from(dependencies).filter((dep) => dep[0] !== "$").filter((dep) => !contextual_dependencies.has(dep)).map((dep) => b`${block.renderer.invalidate(dep)};`)}
	`;
  if (contextual_dependencies.size) {
    const params = Array.from(contextual_dependencies).map((name8) => ({
      type: "Identifier",
      name: name8
    }));
    component.partly_hoisted.push(b`
			function ${fn}($$value, ${params}) {
				@binding_callbacks[$$value ? 'unshift' : 'push'](() => {
					${body}
				});
			}
		`);
    const alias_map = /* @__PURE__ */ new Map();
    const args = [];
    for (let id of params) {
      const value = block.renderer.reference(id.name);
      let found = false;
      if (block.variables.has(id.name)) {
        let alias = id.name;
        for (let i = 1; block.variables.has(alias) && !compare_node(block.variables.get(alias).init, value); alias = `${id.name}_${i++}`)
          ;
        alias_map.set(alias, id.name);
        id = { type: "Identifier", name: alias };
        found = block.variables.has(alias);
      }
      args.push(id);
      if (!found) {
        block.add_variable(id, value);
      }
    }
    const assign = block.get_unique_name(`assign_${variable.name}`);
    const unassign = block.get_unique_name(`unassign_${variable.name}`);
    block.chunks.init.push(b`
			const ${assign} = () => ${callee}(${variable}, ${args});
			const ${unassign} = () => ${callee}(null, ${args});
		`);
    const condition = Array.from(args).map(
      (name8) => x`${name8} !== ${block.renderer.reference(alias_map.get(name8.name) || name8.name)}`
    ).reduce((lhs, rhs) => x`${lhs} || ${rhs}`);
    block.chunks.update.push(b`
			if (${condition}) {
				${unassign}();
				${args.map((a) => b`${a} = ${block.renderer.reference(alias_map.get(a.name) || a.name)}`)};
				${assign}();
			}`);
    block.chunks.destroy.push(b`${unassign}();`);
    return b`${assign}();`;
  }
  component.partly_hoisted.push(b`
		function ${fn}($$value) {
			@binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				${body}
			});
		}
	`);
  block.chunks.destroy.push(b`${callee}(null);`);
  return b`${callee}(${variable});`;
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/Tag.js
var Tag2 = class extends Wrapper {
  /**
   * @param {import('../../Renderer.js').default} renderer
   * @param {import('../../Block.js').default} block
   * @param {import('./Wrapper.js').default} parent
   * @param {NodeType} node
   */
  constructor(renderer, block, parent, node) {
    super(renderer, block, parent, node);
    block.add_dependencies(node.expression.dependencies);
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {(value: import('estree').Node) => import('estree').Node | import('estree').Node[]} update
   */
  rename_this_method(block, update) {
    const dependencies = this.node.expression.dynamic_dependencies();
    let snippet = this.node.expression.manipulate(block);
    const value = this.node.should_cache && block.get_unique_name(`${this.var.name}_value`);
    const content = this.node.should_cache ? value : snippet;
    snippet = x`${snippet} + ""`;
    if (this.node.should_cache)
      block.add_variable(value, snippet);
    if (dependencies.length > 0) {
      let condition = block.renderer.dirty(dependencies);
      if (block.has_outros) {
        condition = x`!#current || ${condition}`;
      }
      const update_cached_value = x`${value} !== (${value} = ${snippet})`;
      if (this.node.should_cache) {
        condition = x`${condition} && ${update_cached_value}`;
      }
      block.chunks.update.push(
        b`if (${condition}) ${update(
          /** @type {import('estree').Node} */
          content
        )}`
      );
    }
    return { init: content };
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/MustacheTag.js
var MustacheTagWrapper = class extends Tag2 {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/MustacheTag.js').default | import('../../nodes/RawMustacheTag.js').default} node
   */
  constructor(renderer, block, parent, node) {
    super(renderer, block, parent, node);
    /** @type {import('estree').Identifier} */
    __publicField(this, "var", { type: "Identifier", name: "t" });
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   * @param {Record<string, unknown> | undefined} data
   */
  render(block, parent_node, parent_nodes, data) {
    const contenteditable_attributes = this.parent instanceof ElementWrapper && this.parent.attributes.filter((a) => a.node.name === "contenteditable");
    const spread_attributes = this.parent instanceof ElementWrapper && this.parent.attributes.filter((a) => a.node.is_spread);
    let contenteditable_attr_value = void 0;
    if (contenteditable_attributes.length > 0) {
      const attribute = (
        /** @type {import('./Element/Attribute.js').default} */
        contenteditable_attributes[0]
      );
      if ([true, "true", ""].includes(attribute.node.get_static_value())) {
        contenteditable_attr_value = true;
      } else {
        contenteditable_attr_value = x`${attribute.get_value(block)}`;
      }
    } else if (spread_attributes.length > 0 && data.element_data_name) {
      contenteditable_attr_value = x`${data.element_data_name}['contenteditable']`;
    }
    const { init } = this.rename_this_method(block, (value) => {
      if (contenteditable_attr_value) {
        if (contenteditable_attr_value === true) {
          return x`@set_data_contenteditable(${this.var}, ${value})`;
        } else {
          return x`@set_data_maybe_contenteditable(${this.var}, ${value}, ${contenteditable_attr_value})`;
        }
      } else {
        return x`@set_data(${this.var}, ${value})`;
      }
    });
    block.add_element(
      this.var,
      x`@text(${init})`,
      parent_nodes && x`@claim_text(${parent_nodes}, ${init})`,
      parent_node
    );
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/RawMustacheTag.js
var RawMustacheTagWrapper = class extends Tag2 {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/MustacheTag.js').default | import('../../nodes/RawMustacheTag.js').default} node
   */
  constructor(renderer, block, parent, node) {
    super(renderer, block, parent, node);
    /** @type {import('estree').Identifier} */
    __publicField(this, "var", { type: "Identifier", name: "raw" });
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} _parent_nodes
   */
  render(block, parent_node, _parent_nodes) {
    const in_head = is_head(parent_node);
    const can_use_innerhtml = !in_head && parent_node && !this.prev && !this.next;
    if (can_use_innerhtml && !this.renderer.options.hydratable) {
      const insert = (content) => b`${parent_node}.innerHTML = ${content};`[0];
      const { init } = this.rename_this_method(block, (content) => insert(content));
      block.chunks.mount.push(insert(init));
    } else {
      const needs_anchor = in_head || (this.next ? !this.next.is_dom_node() : !this.parent || !this.parent.is_dom_node());
      const html_tag = block.get_unique_name("html_tag");
      const html_anchor = needs_anchor && block.get_unique_name("html_anchor");
      block.add_variable(html_tag);
      const { init } = this.rename_this_method(block, (content) => x`${html_tag}.p(${content})`);
      const update_anchor = needs_anchor ? html_anchor : this.next ? this.next.var : "null";
      const parent_element = (
        /** @type {import('../../nodes/Element.js').default} */
        this.node.find_nearest(/^Element/)
      );
      const is_svg2 = parent_element && parent_element.namespace === namespaces.svg;
      block.chunks.create.push(b`${html_tag} = new @HtmlTag(${is_svg2 ? "true" : "false"});`);
      if (this.renderer.options.hydratable) {
        block.chunks.claim.push(
          b`${html_tag} = @claim_html_tag(${_parent_nodes}, ${is_svg2 ? "true" : "false"});`
        );
      }
      block.chunks.hydrate.push(b`${html_tag}.a = ${update_anchor};`);
      block.chunks.mount.push(
        b`${html_tag}.m(${init}, ${parent_node || "#target"}, ${parent_node ? null : "#anchor"});`
      );
      if (needs_anchor) {
        block.add_element(html_anchor, x`@empty()`, x`@empty()`, parent_node);
      }
      if (!parent_node || in_head) {
        block.chunks.destroy.push(b`if (detaching) ${html_tag}.d();`);
      }
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Comment.js
var CommentWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/Comment.js').default} node
   */
  constructor(renderer, block, parent, node) {
    super(renderer, block, parent, node);
    this.var = /** @type {import('estree').Identifier} */
    x`c`;
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    if (!this.renderer.options.preserveComments)
      return;
    const string_literal2 = {
      type: "Literal",
      value: this.node.data,
      loc: {
        start: this.renderer.locate(this.node.start),
        end: this.renderer.locate(this.node.end)
      }
    };
    block.add_element(
      this.var,
      x`@comment(${string_literal2})`,
      parent_nodes && x`@claim_comment(${parent_nodes}, ${string_literal2})`,
      parent_node
    );
  }
  text() {
    if (!this.renderer.options.preserveComments)
      return "";
    return `<!--${this.node.data}-->`;
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Element/index.js
var regex_contains_radio_or_checkbox_or_file = /radio|checkbox|file/;
var regex_contains_radio_or_checkbox_or_range_or_file = /radio|checkbox|range|file/;
var events = [
  {
    event_names: ["input"],
    filter: (node, _name) => node.name === "textarea" || node.name === "input" && !regex_contains_radio_or_checkbox_or_range_or_file.test(
      /** @type {string} */
      node.get_static_attribute_value("type")
    )
  },
  {
    event_names: ["input"],
    filter: (node, name8) => is_name_contenteditable(name8) && has_contenteditable_attr(node)
  },
  {
    event_names: ["change"],
    filter: (node, _name) => node.name === "select" || node.name === "input" && regex_contains_radio_or_checkbox_or_file.test(
      /** @type {string} */
      node.get_static_attribute_value("type")
    )
  },
  {
    event_names: ["change", "input"],
    filter: (node, _name) => node.name === "input" && node.get_static_attribute_value("type") === "range"
  },
  // resize events
  {
    event_names: ["elementresize"],
    filter: (_node, name8) => regex_dimensions.test(name8)
  },
  {
    event_names: ["elementresizecontentbox"],
    filter: (_node, name8) => regex_content_rect.test(name8) ?? regex_content_box_size.test(name8)
  },
  {
    event_names: ["elementresizeborderbox"],
    filter: (_node, name8) => regex_border_box_size.test(name8)
  },
  {
    event_names: ["elementresizedevicepixelcontentbox"],
    filter: (_node, name8) => regex_device_pixel_content_box_size.test(name8)
  },
  // media events
  {
    event_names: ["timeupdate"],
    filter: (node, name8) => node.is_media_node() && (name8 === "currentTime" || name8 === "played" || name8 === "ended")
  },
  {
    event_names: ["durationchange"],
    filter: (node, name8) => node.is_media_node() && name8 === "duration"
  },
  {
    event_names: ["play", "pause"],
    filter: (node, name8) => node.is_media_node() && name8 === "paused"
  },
  {
    event_names: ["progress"],
    filter: (node, name8) => node.is_media_node() && name8 === "buffered"
  },
  {
    event_names: ["loadedmetadata"],
    filter: (node, name8) => node.is_media_node() && (name8 === "buffered" || name8 === "seekable")
  },
  {
    event_names: ["volumechange"],
    filter: (node, name8) => node.is_media_node() && (name8 === "volume" || name8 === "muted")
  },
  {
    event_names: ["ratechange"],
    filter: (node, name8) => node.is_media_node() && name8 === "playbackRate"
  },
  {
    event_names: ["seeking", "seeked"],
    filter: (node, name8) => node.is_media_node() && name8 === "seeking"
  },
  {
    event_names: ["ended"],
    filter: (node, name8) => node.is_media_node() && name8 === "ended"
  },
  {
    event_names: ["resize"],
    filter: (node, name8) => node.is_media_node() && (name8 === "videoHeight" || name8 === "videoWidth")
  },
  {
    // from https://html.spec.whatwg.org/multipage/media.html#ready-states
    // and https://html.spec.whatwg.org/multipage/media.html#loading-the-media-resource
    event_names: [
      "loadedmetadata",
      "loadeddata",
      "canplay",
      "canplaythrough",
      "playing",
      "waiting",
      "emptied"
    ],
    filter: (node, name8) => node.is_media_node() && name8 === "readyState"
  },
  // details event
  {
    event_names: ["toggle"],
    filter: (node, _name) => node.name === "details"
  },
  {
    event_names: ["load"],
    filter: (_, name8) => name8 === "naturalHeight" || name8 === "naturalWidth"
  }
];
var CHILD_DYNAMIC_ELEMENT_BLOCK = "child_dynamic_element";
var regex_invalid_variable_identifier_characters3 = /[^a-zA-Z0-9_$]/g;
var regex_minus_signs = /-/g;
var ElementWrapper = class _ElementWrapper extends Wrapper {
  /**
   * @param {import('../../Renderer.js').default} renderer
   * @param {import('../../Block.js').default} block
   * @param {import('../shared/Wrapper.js').default} parent
   * @param {import('../../../nodes/Element.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('../shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {import('../Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {Array<AttributeWrapper | import('./StyleAttribute.js').default | import('./SpreadAttribute.js').default>} */
    __publicField(this, "attributes");
    /** @type {import('./Binding.js').default[]} */
    __publicField(this, "bindings");
    /** @type {import('./EventHandler.js').default[]} */
    __publicField(this, "event_handlers");
    /** @type {string[]} */
    __publicField(this, "class_dependencies");
    /** @type {Set<string>} */
    __publicField(this, "dynamic_style_dependencies");
    /** @type {boolean} */
    __publicField(this, "has_dynamic_attribute");
    /** @type {Set<string>} */
    __publicField(this, "select_binding_dependencies");
    /** @type {boolean} */
    __publicField(this, "has_dynamic_value");
    /** @type {any} */
    __publicField(this, "dynamic_value_condition");
    /** @type {any} */
    __publicField(this, "var");
    /** @type {boolean} */
    __publicField(this, "void");
    /** @type {import('../../Block.js').default} */
    __publicField(this, "child_dynamic_element_block", null);
    /** @type {ElementWrapper} */
    __publicField(this, "child_dynamic_element", null);
    /** */
    __publicField(this, "element_data_name", null);
    this.var = {
      type: "Identifier",
      name: node.name.replace(regex_invalid_variable_identifier_characters3, "_")
    };
    this.void = is_void(node.name);
    this.class_dependencies = [];
    if (node.is_dynamic_element && block.type !== CHILD_DYNAMIC_ELEMENT_BLOCK) {
      this.child_dynamic_element_block = block.child({
        comment: create_debugging_comment(node, renderer.component),
        name: renderer.component.get_unique_name("create_dynamic_element"),
        type: CHILD_DYNAMIC_ELEMENT_BLOCK
      });
      renderer.blocks.push(this.child_dynamic_element_block);
      this.child_dynamic_element = new _ElementWrapper(
        renderer,
        this.child_dynamic_element_block,
        parent,
        node,
        strip_whitespace,
        next_sibling
      );
      if (node.intro)
        block.add_intro(node.intro.is_local);
      if (node.outro)
        block.add_outro(node.outro.is_local);
      return;
    }
    this.dynamic_style_dependencies = /* @__PURE__ */ new Set();
    if (this.node.children.length) {
      this.node.lets.forEach((l) => {
        extract_names(l.value || l.name).forEach((name8) => {
          renderer.add_to_context(name8, true);
        });
      });
    }
    this.attributes = this.node.attributes.map((attribute) => {
      if (attribute.name === "style") {
        return new StyleAttributeWrapper(this, block, attribute);
      }
      if (attribute.type === "Spread") {
        return new SpreadAttributeWrapper(this, block, attribute);
      }
      return new AttributeWrapper(this, block, attribute);
    });
    this.has_dynamic_attribute = !!this.attributes.find(
      (attr) => attr.node.get_dependencies().length > 0
    );
    this.bindings = this.node.bindings.map((binding) => new BindingWrapper(block, binding, this));
    this.event_handlers = this.node.handlers.map(
      (event_handler) => new EventHandlerWrapper(event_handler, this)
    );
    if (node.intro)
      block.add_intro(node.intro.is_local);
    if (node.outro)
      block.add_outro(node.outro.is_local);
    if (node.animation) {
      block.add_animation();
    }
    block.add_dependencies(node.tag_expr.dependencies);
    [node.animation, node.outro, ...node.actions, ...node.classes, ...node.styles].forEach(
      (directive) => {
        if (directive && directive.expression) {
          block.add_dependencies(directive.expression.dependencies);
        }
      }
    );
    node.handlers.forEach((handler) => {
      if (handler.expression) {
        block.add_dependencies(handler.expression.dependencies);
      }
    });
    this.fragment = new FragmentWrapper(
      renderer,
      block,
      node.children,
      this,
      strip_whitespace,
      next_sibling
    );
    this.element_data_name = block.get_unique_name(`${this.var.name}_data`);
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    if (this.child_dynamic_element) {
      this.render_dynamic_element(block, parent_node, parent_nodes);
    } else {
      this.render_element(block, parent_node, parent_nodes);
    }
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render_dynamic_element(block, parent_node, parent_nodes) {
    this.child_dynamic_element.render(
      this.child_dynamic_element_block,
      null,
      /** @type {unknown} */
      /** @type {import('estree').Identifier} */
      x`#nodes`
    );
    const is_tag_dynamic = this.node.tag_expr.dynamic_dependencies().length > 0;
    const tag2 = this.node.tag_expr.manipulate(block);
    block.chunks.init.push(b`
			${this.renderer.options.dev && b`@validate_dynamic_element(${tag2});`}
			${this.renderer.options.dev && this.node.children.length > 0 && b`@validate_void_dynamic_element(${tag2});`}
			let ${this.var} = ${tag2} && ${this.child_dynamic_element_block.name}(#ctx);
		`);
    block.chunks.create.push(b`
			if (${this.var}) ${this.var}.c();
		`);
    if (this.renderer.options.hydratable) {
      block.chunks.claim.push(b`
				if (${this.var}) ${this.var}.l(${parent_nodes});
			`);
    }
    block.chunks.mount.push(b`
			if (${this.var}) ${this.var}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});
		`);
    if (is_tag_dynamic) {
      const previous_tag = block.get_unique_name("previous_tag");
      block.add_variable(previous_tag, tag2);
      const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
      const has_transitions = !!(this.node.intro || this.node.outro);
      const not_equal = this.renderer.component.component_options.immutable ? x`@not_equal` : x`@safe_not_equal`;
      const tag_will_be_removed = block.get_unique_name("tag_will_be_removed");
      if (has_transitions) {
        block.add_variable(tag_will_be_removed, x`false`);
      }
      block.chunks.update.push(b`
				if (${tag2}) {
					if (!${previous_tag}) {
						${this.var} = ${this.child_dynamic_element_block.name}(#ctx);
						${previous_tag} = ${tag2};
						${this.var}.c();
						${has_transitions && b`@transition_in(${this.var})`}
						${this.var}.m(${this.get_update_mount_node(anchor)}, ${anchor});
					} else if (${not_equal}(${previous_tag}, ${tag2})) {
						${this.var}.d(1);
						${this.renderer.options.dev && b`@validate_dynamic_element(${tag2});`}
						${this.renderer.options.dev && this.node.children.length > 0 && b`@validate_void_dynamic_element(${tag2});`}
						${this.var} = ${this.child_dynamic_element_block.name}(#ctx);
						${previous_tag} = ${tag2};
						${this.var}.c();
						${has_transitions && b`if (${tag_will_be_removed}) {
							${tag_will_be_removed} = false;
							@transition_in(${this.var})
						}`}
						${this.var}.m(${this.get_update_mount_node(anchor)}, ${anchor});
					} else {
						${has_transitions && b`if (${tag_will_be_removed}) {
							${tag_will_be_removed} = false;
							@transition_in(${this.var})
						}`}
						${this.var}.p(#ctx, #dirty);
					}
				} else if (${previous_tag}) {
					${has_transitions ? b`
								${tag_will_be_removed} = true;
								@group_outros();
								@transition_out(${this.var}, 1, 1, () => {
									${this.var} = null;
									${previous_tag} = ${tag2};
									${tag_will_be_removed} = false;
								});
								@check_outros();
							` : b`
								${this.var}.d(1);
								${this.var} = null;
								${previous_tag} = ${tag2};
							`}
				}
			`);
    } else {
      block.chunks.update.push(b`
				if (${tag2}) {
					${this.var}.p(#ctx, #dirty);
				}
			`);
    }
    if (this.child_dynamic_element_block.has_intros) {
      block.chunks.intro.push(b`@transition_in(${this.var}, #local);`);
    }
    if (this.child_dynamic_element_block.has_outros) {
      block.chunks.outro.push(b`@transition_out(${this.var}, #local);`);
    }
    block.chunks.destroy.push(b`if (${this.var}) ${this.var}.d(detaching)`);
    if (this.node.animation) {
      const measurements = block.get_unique_name("measurements");
      block.add_variable(measurements);
      block.chunks.measure.push(b`${measurements} = ${this.var}.r()`);
      block.chunks.fix.push(b`${this.var}.f();`);
      block.chunks.animate.push(b`
				${this.var}.s(${measurements});
				${this.var}.a()
			`);
    }
  }
  is_dom_node() {
    return super.is_dom_node() && !this.child_dynamic_element;
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render_element(block, parent_node, parent_nodes) {
    const { renderer } = this;
    const hydratable = renderer.options.hydratable;
    if (this.node.name === "noscript")
      return;
    const node = this.var;
    const nodes = parent_nodes && block.get_unique_name(`${this.var.name}_nodes`);
    const children = x`@children(${this.node.name === "template" ? x`${node}.content` : node})`;
    block.add_variable(node);
    const render_statement = this.get_render_statement(block);
    block.chunks.create.push(b`${node} = ${render_statement};`);
    const { can_use_textcontent, can_optimise_to_html_string, can_optimise_hydration } = this.node;
    if (hydratable) {
      if (parent_nodes) {
        block.chunks.claim.push(b`
					${node} = ${this.get_claim_statement(block, parent_nodes, can_optimise_hydration)};
				`);
        if (!can_optimise_hydration && !this.void && this.node.children.length > 0) {
          block.chunks.claim.push(b`
						var ${nodes} = ${children};
					`);
        }
      } else {
        block.chunks.claim.push(b`${node} = ${render_statement};`);
      }
    }
    if (parent_node) {
      const append = b`@append(${parent_node}, ${node});`;
      /** @type {import('estree').ExpressionStatement} */
      append[0].expression.callee.loc = {
        start: this.renderer.locate(this.node.start),
        end: this.renderer.locate(this.node.end)
      };
      block.chunks.mount.push(append);
      if (is_head(parent_node)) {
        block.chunks.destroy.push(b`@detach(${node});`);
      }
    } else {
      const insert = b`@insert(#target, ${node}, #anchor);`;
      /** @type {import('estree').ExpressionStatement} */
      insert[0].expression.callee.loc = {
        start: this.renderer.locate(this.node.start),
        end: this.renderer.locate(this.node.end)
      };
      block.chunks.mount.push(insert);
      block.chunks.destroy.push(b`if (detaching) @detach(${node});`);
    }
    if (can_optimise_to_html_string && (!hydratable || can_optimise_hydration)) {
      if (this.fragment.nodes.length === 1 && this.fragment.nodes[0].node.type === "Text") {
        let text2 = string_literal(
          /** @type {import('../Text.js').default} */
          this.fragment.nodes[0].data
        );
        if (hydratable) {
          const variable = block.get_unique_name("textContent");
          block.add_variable(variable, text2);
          text2 = variable;
        }
        block.chunks.create.push(b`${node}.textContent = ${text2};`);
        if (hydratable) {
          block.chunks.claim.push(
            b`if (@get_svelte_dataset(${node}) !== "${this.node.hash()}") ${node}.textContent = ${text2};`
          );
        }
      } else {
        const state = {
          quasi: {
            type: "TemplateElement",
            value: { raw: "" }
          }
        };
        let literal = {
          type: "TemplateLiteral",
          expressions: [],
          quasis: []
        };
        const can_use_raw_text = !this.node.can_use_innerhtml && can_use_textcontent;
        to_html(
          /** @type {unknown} */
          /** @type {Array<ElementWrapper | import('../Comment.js').default | import('../Text.js').default>} */
          this.fragment.nodes,
          block,
          literal,
          state,
          can_use_raw_text
        );
        literal.quasis.push(
          /** @type {any} */
          state.quasi
        );
        if (hydratable) {
          const variable = block.get_unique_name("textContent");
          block.add_variable(variable, literal);
          literal = variable;
        }
        const property = this.node.can_use_innerhtml ? "innerHTML" : "textContent";
        block.chunks.create.push(b`${node}.${property} = ${literal};`);
        if (hydratable) {
          block.chunks.claim.push(
            b`if (@get_svelte_dataset(${node}) !== "${this.node.hash()}") ${node}.${property} = ${literal};`
          );
        }
      }
    } else {
      this.fragment.nodes.forEach((child) => {
        child.render(block, this.node.name === "template" ? x`${node}.content` : node, nodes, {
          element_data_name: this.element_data_name
        });
      });
    }
    const event_handler_or_binding_uses_context = this.bindings.some((binding) => binding.handler.uses_context) || this.node.handlers.some((handler) => handler.uses_context) || this.node.actions.some((action) => action.uses_context);
    if (event_handler_or_binding_uses_context) {
      block.maintain_context = true;
    }
    if (this.node.is_dynamic_element) {
      this.add_dynamic_element_attributes(block);
    } else {
      this.add_attributes(block);
    }
    this.add_directives_in_order(block);
    this.add_transitions(block);
    this.add_animation(block);
    this.add_classes(block);
    this.add_styles(block);
    this.add_manual_style_scoping(block);
    if (nodes && hydratable && !this.void && !can_optimise_hydration) {
      block.chunks.claim.push(
        b`${this.node.children.length > 0 ? nodes : children}.forEach(@detach);`
      );
    }
    if (renderer.options.dev) {
      const loc = renderer.meta_locate(this.node.start);
      block.chunks.hydrate.push(
        b`@add_location(${this.var}, ${renderer.file_var}, ${loc.line - 1}, ${loc.column}, ${// TODO this.node.start isn't correct if there's a source map. But since we don't know how the
        // original source file looked, there's not much we can do.
        this.node.start});`
      );
    }
    block.renderer.dirty(this.node.tag_expr.dynamic_dependencies());
  }
  /** @param {import('../../Block.js').default} block */
  get_render_statement(block) {
    const { name: name8, namespace, tag_expr } = this.node;
    const reference = tag_expr.manipulate(block);
    if (namespace === namespaces.svg) {
      return x`@svg_element(${reference})`;
    }
    if (namespace) {
      return x`@_document.createElementNS("${namespace}", "${name8}")`;
    }
    const is = (
      /** @type {any} */
      this.attributes.find((attr) => attr.node.name === "is")
    );
    if (is) {
      return x`@element_is("${name8}", ${is.render_chunks(block).reduce((lhs, rhs) => x`${lhs} + ${rhs}`)})`;
    }
    return x`@element(${reference})`;
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} nodes
   * @param {boolean} to_optimise_hydration
   */
  get_claim_statement(block, nodes, to_optimise_hydration) {
    const attributes = this.attributes.filter((attr) => !(attr instanceof SpreadAttributeWrapper) && !attr.property_name).map(
      (attr) => p`${/** @type {import('./StyleAttribute.js').default | import('./Attribute.js').default} */
      attr.name}: true`
    );
    let reference;
    if (this.node.tag_expr.node.type === "Literal") {
      if (this.node.namespace) {
        reference = `"${this.node.tag_expr.node.value}"`;
      } else {
        reference = `"${/** @type {String} */
        (this.node.tag_expr.node.value || "").toUpperCase()}"`;
      }
    } else if (this.node.namespace) {
      reference = x`${this.node.tag_expr.manipulate(block)}`;
    } else {
      reference = x`(${this.node.tag_expr.manipulate(block)} || 'null').toUpperCase()`;
    }
    if (to_optimise_hydration) {
      attributes.push(p`["data-svelte-h"]: true`);
    }
    if (this.node.namespace === namespaces.svg) {
      return x`@claim_svg_element(${nodes}, ${reference}, { ${attributes} })`;
    } else {
      return x`@claim_element(${nodes}, ${reference}, { ${attributes} })`;
    }
  }
  /** @param {import('../../Block.js').default} block */
  add_directives_in_order(block) {
    const binding_groups = events.map((event) => ({
      events: event.event_names,
      bindings: this.bindings.filter((binding) => binding.node.name !== "this").filter((binding) => event.filter(this.node, binding.node.name))
    })).filter((group) => group.bindings.length);
    const this_binding = this.bindings.find((b2) => b2.node.name === "this");
    function getOrder(item) {
      if (item instanceof EventHandlerWrapper) {
        return item.node.start;
      } else if (item instanceof BindingWrapper) {
        return item.node.start;
      } else if (item instanceof Action) {
        return item.start;
      } else {
        return item.bindings[0].node.start;
      }
    }
    [
      ...binding_groups,
      ...this.event_handlers,
      this_binding,
      ...this.node.actions
    ].filter(Boolean).sort((a, b2) => getOrder(a) - getOrder(b2)).forEach((item) => {
      if (item instanceof EventHandlerWrapper) {
        add_event_handler(block, this.var, item);
      } else if (item instanceof BindingWrapper) {
        this.add_this_binding(block, item);
      } else if (item instanceof Action) {
        add_action(block, this.var, item);
      } else {
        this.add_bindings(block, item);
      }
    });
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {BindingGroup} binding_group
   */
  add_bindings(block, binding_group) {
    const { renderer } = this;
    if (binding_group.bindings.length === 0)
      return;
    renderer.component.has_reactive_assignments = true;
    const lock = binding_group.bindings.some((binding) => binding.needs_lock) ? block.get_unique_name(`${this.var.name}_updating`) : null;
    if (lock)
      block.add_variable(lock, x`false`);
    const handler = renderer.component.get_unique_name(
      `${this.var.name}_${binding_group.events.join("_")}_handler`
    );
    renderer.add_to_context(handler.name);
    const needs_lock = binding_group.bindings.some((binding) => binding.needs_lock);
    const dependencies = /* @__PURE__ */ new Set();
    const contextual_dependencies = /* @__PURE__ */ new Set();
    binding_group.bindings.forEach((binding) => {
      add_to_set(dependencies, binding.get_update_dependencies());
      add_to_set(contextual_dependencies, binding.handler.contextual_dependencies);
      binding.render(block, lock);
    });
    let animation_frame;
    if (binding_group.events[0] === "timeupdate") {
      animation_frame = block.get_unique_name(`${this.var.name}_animationframe`);
      block.add_variable(animation_frame);
    }
    const has_local_function = contextual_dependencies.size > 0 || needs_lock || animation_frame;
    let callee = renderer.reference(handler);
    if (has_local_function) {
      const args = Array.from(contextual_dependencies).map((name8) => renderer.reference(name8));
      if (animation_frame) {
        block.chunks.init.push(b`
					function ${handler}() {
						@_cancelAnimationFrame(${animation_frame});
						if (!${this.var}.paused) {
							${animation_frame} = @raf(${handler});
							${needs_lock && b`${lock} = true;`}
						}
						${callee}.call(${this.var}, ${args});
					}
				`);
      } else {
        block.chunks.init.push(b`
					function ${handler}() {
						${needs_lock && b`${lock} = true;`}
						${callee}.call(${this.var}, ${args});
					}
				`);
      }
      callee = handler;
    }
    const params = Array.from(contextual_dependencies).map((name8) => ({
      type: "Identifier",
      name: name8
    }));
    this.renderer.component.partly_hoisted.push(b`
			function ${handler}(${params}) {
				${binding_group.bindings.map((b2) => b2.handler.mutation)}
				${Array.from(dependencies).filter((dep) => dep[0] !== "$").filter((dep) => !contextual_dependencies.has(dep)).map((dep) => b`${this.renderer.invalidate(dep)};`)}
			}
		`);
    binding_group.events.forEach((name8) => {
      if ([
        "elementresize",
        "elementresizecontentbox",
        "elementresizeborderbox",
        "elementresizedevicepixelcontentbox"
      ].indexOf(name8) !== -1) {
        const resize_listener = block.get_unique_name(`${this.var.name}_resize_listener`);
        block.add_variable(resize_listener);
        switch (name8) {
          case "elementresize":
            block.chunks.mount.push(
              b`${resize_listener} = @add_iframe_resize_listener(${this.var}, ${callee}.bind(${this.var}));`
            );
            break;
          case "elementresizecontentbox":
            block.chunks.mount.push(
              b`${resize_listener} = @resize_observer_content_box.observe(${this.var}, ${callee}.bind(${this.var}));`
            );
            break;
          case "elementresizeborderbox":
            block.chunks.mount.push(
              b`${resize_listener} = @resize_observer_border_box.observe(${this.var}, ${callee}.bind(${this.var}));`
            );
            break;
          case "elementresizedevicepixelcontentbox":
            block.chunks.mount.push(
              b`${resize_listener} = @resize_observer_device_pixel_content_box.observe(${this.var}, ${callee}.bind(${this.var}));`
            );
            break;
        }
        block.chunks.destroy.push(b`${resize_listener}();`);
      } else {
        block.event_listeners.push(x`@listen(${this.var}, "${name8}", ${callee})`);
      }
    });
    const some_initial_state_is_undefined = binding_group.bindings.map((binding) => x`${binding.snippet} === void 0`).reduce((lhs, rhs) => x`${lhs} || ${rhs}`);
    const should_initialise = this.node.name === "select" || binding_group.bindings.find(
      (binding) => binding.node.name === "indeterminate" || is_name_contenteditable(binding.node.name) || binding.is_readonly_media_attribute()
    );
    if (should_initialise) {
      const callback = has_local_function ? handler : x`() => ${callee}.call(${this.var})`;
      block.chunks.hydrate.push(
        b`if (${some_initial_state_is_undefined}) @add_render_callback(${callback});`
      );
    }
    if (binding_group.events[0] === "elementresize") {
      block.chunks.hydrate.push(b`@add_render_callback(() => ${callee}.call(${this.var}));`);
    }
    if (lock) {
      block.chunks.update.push(b`${lock} = false;`);
    }
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('./Binding.js').default} this_binding
   */
  add_this_binding(block, this_binding) {
    const { renderer } = this;
    renderer.component.has_reactive_assignments = true;
    const binding_callback = bind_this(renderer.component, block, this_binding, this.var);
    block.chunks.mount.push(binding_callback);
  }
  /** @param {import('../../Block.js').default} block */
  add_attributes(block) {
    this.attributes.forEach((attribute) => {
      if (attribute.node.name === "class") {
        const dependencies = attribute.node.get_dependencies();
        push_array(this.class_dependencies, dependencies);
      } else if (attribute.node.name === "style") {
        add_to_set(this.dynamic_style_dependencies, attribute.node.get_dependencies());
      }
    });
    if (this.node.attributes.some((attr) => attr.is_spread)) {
      this.add_spread_attributes(block);
      return;
    }
    this.attributes.forEach((attribute) => {
      attribute.render(block);
    });
  }
  /** @param {import('../../Block.js').default} block */
  add_spread_attributes(block) {
    const levels = block.get_unique_name(`${this.var.name}_levels`);
    const initial_props = [];
    const updates = [];
    this.attributes.forEach((attr) => {
      const dependencies = attr.node.get_dependencies();
      const condition = dependencies.length > 0 ? block.renderer.dirty(dependencies) : null;
      if (attr instanceof SpreadAttributeWrapper) {
        const snippet = attr.node.expression.manipulate(block);
        initial_props.push(snippet);
        updates.push(condition ? x`${condition} && ${snippet}` : snippet);
      } else {
        const name8 = attr.property_name || attr.name;
        initial_props.push(x`{ ${name8}: ${attr.get_init(block, attr.get_value(block))} }`);
        const snippet = x`{ ${name8}: ${attr.should_cache ? attr.last : attr.get_value(block)} }`;
        updates.push(
          condition ? x`${attr.get_dom_update_conditions(block, condition)} && ${snippet}` : snippet
        );
      }
    });
    block.chunks.init.push(b`
			let ${levels} = [${initial_props}];

			let ${this.element_data_name} = {};
			for (let #i = 0; #i < ${levels}.length; #i += 1) {
				${this.element_data_name} = @assign(${this.element_data_name}, ${levels}[#i]);
			}
		`);
    const fn = this.node.namespace === namespaces.svg ? x`@set_svg_attributes` : this.node.is_dynamic_element ? x`@set_dynamic_element_data(${this.node.tag_expr.manipulate(block)})` : x`@set_attributes`;
    block.chunks.hydrate.push(b`${fn}(${this.var}, ${this.element_data_name});`);
    if (this.has_dynamic_attribute) {
      block.chunks.update.push(b`
				${fn}(${this.var}, ${this.element_data_name} = @get_spread_update(${levels}, [
					${updates}
				]));
			`);
    }
    if (this.node.name === "select") {
      const dependencies = /* @__PURE__ */ new Set();
      for (const attr of this.attributes) {
        for (const dep of attr.node.dependencies) {
          dependencies.add(dep);
        }
      }
      block.chunks.mount.push(b`
				'value' in ${this.element_data_name} && (${this.element_data_name}.multiple ? @select_options : @select_option)(${this.var}, ${this.element_data_name}.value);
			`);
      block.chunks.update.push(b`
				if (${block.renderer.dirty(Array.from(dependencies))} && 'value' in ${this.element_data_name}) (${this.element_data_name}.multiple ? @select_options : @select_option)(${this.var}, ${this.element_data_name}.value);
			`);
    } else if (this.node.name === "input" && this.attributes.find((attr) => attr.node.name === "value")) {
      const type = this.node.get_static_attribute_value("type");
      if (type === null || type === "" || type === "text" || type === "email" || type === "password") {
        block.chunks.mount.push(b`
					if ('value' in ${this.element_data_name}) {
						${this.var}.value = ${this.element_data_name}.value;
					}
				`);
        block.chunks.update.push(b`
					if ('value' in ${this.element_data_name}) {
						${this.var}.value = ${this.element_data_name}.value;
					}
				`);
      }
    }
    if (["button", "input", "keygen", "select", "textarea"].includes(this.node.name)) {
      block.chunks.mount.push(b`
				if (${this.var}.autofocus) ${this.var}.focus();
			`);
    }
  }
  /** @param {import('../../Block.js').default} block */
  add_dynamic_element_attributes(block) {
    if (this.attributes.length === 0)
      return;
    if (this.has_dynamic_attribute) {
      this.add_spread_attributes(block);
      return;
    }
    const static_attributes = [];
    this.attributes.forEach((attr) => {
      if (attr instanceof SpreadAttributeWrapper) {
        const snippet = { type: "SpreadElement", argument: attr.node.expression.manipulate(block) };
        static_attributes.push(snippet);
      } else {
        const name8 = attr.property_name || attr.name;
        static_attributes.push(p`${name8}: ${attr.get_value(block)}`);
      }
    });
    const fn = this.node.namespace === namespaces.svg ? x`@set_svg_attributes` : this.node.is_dynamic_element ? x`@set_dynamic_element_data(${this.node.tag_expr.manipulate(block)})` : x`@set_attributes`;
    block.chunks.hydrate.push(b`${fn}(${this.var}, {${static_attributes}});`);
  }
  /** @param {import('../../Block.js').default} block */
  add_transitions(block) {
    const { intro, outro } = this.node;
    if (!intro && !outro)
      return;
    if (intro === outro) {
      const name8 = block.get_unique_name(`${this.var.name}_transition`);
      const snippet = intro.expression ? intro.expression.manipulate(block) : x`{}`;
      block.add_variable(name8);
      const fn = this.renderer.reference(intro.name);
      const intro_block = b`
				@add_render_callback(() => {
					if (!#current) return;
					if (!${name8}) ${name8} = @create_bidirectional_transition(${this.var}, ${fn}, ${snippet}, true);
					${name8}.run(1);
				});
			`;
      const outro_block = b`
				if (!${name8}) ${name8} = @create_bidirectional_transition(${this.var}, ${fn}, ${snippet}, false);
				${name8}.run(0);
			`;
      if (intro.is_local) {
        block.chunks.intro.push(b`
					if (#local) {
						${intro_block}
					}
				`);
        block.chunks.outro.push(b`
					if (#local) {
						${outro_block}
					}
				`);
      } else {
        block.chunks.intro.push(intro_block);
        block.chunks.outro.push(outro_block);
      }
      block.chunks.destroy.push(b`if (detaching && ${name8}) ${name8}.end();`);
    } else {
      const intro_name = intro && block.get_unique_name(`${this.var.name}_intro`);
      const outro_name = outro && block.get_unique_name(`${this.var.name}_outro`);
      if (intro) {
        block.add_variable(intro_name);
        const snippet = intro.expression ? intro.expression.manipulate(block) : x`{}`;
        const fn = this.renderer.reference(intro.name);
        let intro_block;
        if (outro) {
          intro_block = b`
						@add_render_callback(() => {
							if (!#current) return;
							if (${outro_name}) ${outro_name}.end(1);
							${intro_name} = @create_in_transition(${this.var}, ${fn}, ${snippet});
							${intro_name}.start();
						});
					`;
          block.chunks.outro.push(b`if (${intro_name}) ${intro_name}.invalidate();`);
        } else {
          intro_block = b`
						if (!${intro_name}) {
							@add_render_callback(() => {
								${intro_name} = @create_in_transition(${this.var}, ${fn}, ${snippet});
								${intro_name}.start();
							});
						}
					`;
        }
        if (intro.is_local) {
          intro_block = b`
						if (#local) {
							${intro_block}
						}
					`;
        }
        block.chunks.intro.push(intro_block);
      }
      if (outro) {
        block.add_variable(outro_name);
        const snippet = outro.expression ? outro.expression.manipulate(block) : x`{}`;
        const fn = this.renderer.reference(outro.name);
        if (!intro) {
          block.chunks.intro.push(b`
						if (${outro_name}) ${outro_name}.end(1);
					`);
        }
        let outro_block = b`
					${outro_name} = @create_out_transition(${this.var}, ${fn}, ${snippet});
				`;
        if (outro.is_local) {
          outro_block = b`
						if (#local) {
							${outro_block}
						}
					`;
        }
        block.chunks.outro.push(outro_block);
        block.chunks.destroy.push(b`if (detaching && ${outro_name}) ${outro_name}.end();`);
      }
    }
    if (intro && intro.expression && intro.expression.dependencies.size || outro && outro.expression && outro.expression.dependencies.size) {
      block.maintain_context = true;
    }
  }
  /** @param {import('../../Block.js').default} block */
  add_animation(block) {
    if (!this.node.animation)
      return;
    const { outro } = this.node;
    const rect = block.get_unique_name("rect");
    const stop_animation = block.get_unique_name("stop_animation");
    block.add_variable(rect);
    block.add_variable(stop_animation, x`@noop`);
    block.chunks.measure.push(b`
			${rect} = ${this.var}.getBoundingClientRect();
		`);
    if (block.type === CHILD_DYNAMIC_ELEMENT_BLOCK) {
      block.chunks.measure.push(b`return ${rect}`);
      block.chunks.restore_measurements.push(b`${rect} = #measurement;`);
    }
    block.chunks.fix.push(b`
			@fix_position(${this.var});
			${stop_animation}();
			${outro && b`@add_transform(${this.var}, ${rect});`}
		`);
    let params;
    if (this.node.animation.expression) {
      params = this.node.animation.expression.manipulate(block);
      if (this.node.animation.expression.dynamic_dependencies().length) {
        const params_var = block.get_unique_name("params");
        block.add_variable(params_var);
        block.chunks.measure.push(b`${params_var} = ${params};`);
        params = params_var;
      }
    } else {
      params = x`{}`;
    }
    const name8 = this.renderer.reference(this.node.animation.name);
    block.chunks.animate.push(b`
			${stop_animation}();
			${stop_animation} = @create_animation(${this.var}, ${rect}, ${name8}, ${params});
		`);
  }
  /** @param {import('../../Block.js').default} block */
  add_classes(block) {
    const has_spread = this.node.attributes.some((attr) => attr.is_spread);
    this.node.classes.forEach((class_directive) => {
      const { expression, name: name8 } = class_directive;
      let snippet;
      let dependencies;
      if (expression) {
        snippet = expression.manipulate(block);
        dependencies = expression.dependencies;
      } else {
        snippet = name8;
        dependencies = /* @__PURE__ */ new Set([name8]);
      }
      const updater = b`@toggle_class(${this.var}, "${name8}", ${snippet});`;
      block.chunks.hydrate.push(updater);
      if ((this.node.is_dynamic_element || has_spread) && this.has_dynamic_attribute) {
        block.chunks.update.push(updater);
      } else if (dependencies && dependencies.size > 0 || this.class_dependencies.length) {
        const all_dependencies = this.class_dependencies.concat(...dependencies);
        let condition = block.renderer.dirty(all_dependencies);
        if (block.has_outros) {
          condition = x`!#current || ${condition}`;
        }
        const any_dynamic_dependencies = all_dependencies.some((dep) => {
          const variable = this.renderer.component.var_lookup.get(dep);
          return !variable || is_dynamic(variable);
        });
        if (any_dynamic_dependencies) {
          block.chunks.update.push(b`
						if (${condition}) {
							${updater}
						}
					`);
        }
      }
    });
  }
  /** @param {import('../../Block.js').default} block */
  add_styles(block) {
    const has_spread = this.node.attributes.some((attr) => attr.is_spread);
    let style_changed_var;
    const maybe_create_style_changed_var = () => {
      if (!style_changed_var && this.dynamic_style_dependencies.size) {
        style_changed_var = block.get_unique_name("style_changed");
        const style_attr_dirty = block.renderer.dirty([...this.dynamic_style_dependencies]);
        block.chunks.update.push(b`const ${style_changed_var} = ${style_attr_dirty};`);
      }
    };
    this.node.styles.forEach((style_directive) => {
      const { name: name8, expression, important, should_cache: should_cache2 } = style_directive;
      const snippet = expression.manipulate(block);
      let cached_snippet;
      if (should_cache2) {
        cached_snippet = block.get_unique_name(`style_${name8.replace(regex_minus_signs, "_")}`);
        block.add_variable(cached_snippet, snippet);
      }
      const updater = b`@set_style(${this.var}, "${name8}", ${should_cache2 ? cached_snippet : snippet}, ${important ? 1 : null})`;
      block.chunks.hydrate.push(updater);
      const self_deps = expression.dynamic_dependencies();
      const all_deps = /* @__PURE__ */ new Set([...self_deps, ...this.dynamic_style_dependencies]);
      let condition = block.renderer.dirty([...all_deps]);
      if (has_spread) {
        if (should_cache2 && all_deps.size) {
          block.chunks.update.push(b`
						if (${condition}) {
							${cached_snippet} = ${snippet};
						}`);
        }
        block.chunks.update.push(updater);
      } else {
        if (all_deps.size === 0)
          return;
        if (should_cache2) {
          condition = x`${condition} && ${cached_snippet} !== (${cached_snippet} = ${snippet})`;
        }
        if (this.dynamic_style_dependencies.size > 0) {
          maybe_create_style_changed_var();
          condition = x`${condition} || ${style_changed_var}`;
        }
        block.chunks.update.push(b`
					if (${condition}) {
						${updater}
					}
				`);
      }
    });
  }
  /** @param {import('../../Block.js').default} block */
  add_manual_style_scoping(block) {
    if (this.node.needs_manual_style_scoping) {
      const updater = b`@toggle_class(${this.var}, "${this.node.component.stylesheet.id}", true);`;
      block.chunks.hydrate.push(updater);
      block.chunks.update.push(updater);
    }
  }
};
var regex_backticks = /`/g;
var regex_dollar_signs = /\$/g;
function to_html(wrappers2, block, literal, state, can_use_raw_text) {
  wrappers2.forEach((wrapper) => {
    if (wrapper instanceof CommentWrapper) {
      state.quasi.value.raw += wrapper.text();
    } else if (wrapper instanceof TextWrapper) {
      if (wrapper.use_space()) {
        state.quasi.value.raw += " ";
        return;
      }
      const parent = (
        /** @type {import('../../../nodes/Element.js').default} */
        wrapper.node.parent
      );
      const raw = parent && (parent.name === "script" || parent.name === "style" || can_use_raw_text);
      state.quasi.value.raw += (raw ? wrapper.data : escape_html(wrapper.data)).replace(regex_backslashes, "\\\\").replace(regex_backticks, "\\`").replace(regex_dollar_signs, "\\$");
    } else if (wrapper instanceof MustacheTagWrapper || wrapper instanceof RawMustacheTagWrapper) {
      literal.quasis.push(state.quasi);
      literal.expressions.push(wrapper.node.expression.manipulate(block));
      state.quasi = {
        type: "TemplateElement",
        value: { raw: "" }
      };
    } else if (wrapper.node.name === "noscript") {
    } else {
      const nodeName = wrapper.node.name;
      state.quasi.value.raw += `<${nodeName}`;
      const is_empty_textarea = nodeName === "textarea" && wrapper.fragment.nodes.length === 0;
      wrapper.attributes.forEach((attr) => {
        if (is_empty_textarea && attr.node.name === "value") {
          return;
        }
        if (attr instanceof SpreadAttributeWrapper) {
          literal.quasis.push(state.quasi);
          literal.expressions.push(x`@stringify_spread(${attr.node.expression.manipulate(block)})`);
          state.quasi = {
            type: "TemplateElement",
            value: { raw: "" }
          };
        } else {
          state.quasi.value.raw += ` ${fix_attribute_casing(attr.node.name)}="`;
          to_html_for_attr_value(attr, block, literal, state);
          state.quasi.value.raw += '"';
        }
      });
      if (!wrapper.void) {
        state.quasi.value.raw += ">";
        if (nodeName === "pre") {
          const first = wrapper.fragment.nodes[0];
          if (first && first.node.type === "Text" && regex_starts_with_newline.test(first.node.data)) {
            state.quasi.value.raw += "\n";
          }
        }
        if (is_empty_textarea) {
          const value_attribute = wrapper.attributes.find((attr) => attr.node.name === "value");
          if (value_attribute) {
            const first = value_attribute.node.chunks[0];
            if (first && first.type === "Text" && regex_starts_with_newline.test(first.data)) {
              state.quasi.value.raw += "\n";
            }
            to_html_for_attr_value(value_attribute, block, literal, state);
          }
        }
        to_html(
          /** @type {Array<ElementWrapper | import('../Text.js').default>} */
          wrapper.fragment.nodes,
          block,
          literal,
          state
        );
        state.quasi.value.raw += `</${nodeName}>`;
      } else {
        state.quasi.value.raw += "/>";
      }
    }
  });
}
function to_html_for_attr_value(attr, block, literal, state) {
  attr.node.chunks.forEach((chunk) => {
    if (chunk.type === "Text") {
      state.quasi.value.raw += escape_html(chunk.data);
    } else {
      literal.quasis.push(state.quasi);
      literal.expressions.push(chunk.manipulate(block));
      state.quasi = {
        type: "TemplateElement",
        value: { raw: "" }
      };
    }
  });
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Head.js
var HeadWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/Head.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {import('./Fragment.js').default} */
    __publicField(this, "fragment");
    this.fragment = new FragmentWrapper(
      renderer,
      block,
      node.children,
      this,
      strip_whitespace,
      next_sibling
    );
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} _parent_node
   * @param {import('estree').Identifier} _parent_nodes
   */
  render(block, _parent_node, _parent_nodes) {
    let nodes;
    if (this.renderer.options.hydratable && this.fragment.nodes.length) {
      nodes = block.get_unique_name("head_nodes");
      block.chunks.claim.push(
        b`const ${nodes} = @head_selector('${this.node.id}', @_document.head);`
      );
    }
    this.fragment.render(
      block,
      /** @type {unknown} */
      /** @type {import('estree').Identifier} */
      x`@_document.head`,
      nodes
    );
    if (nodes && this.renderer.options.hydratable) {
      block.chunks.claim.push(b`${nodes}.forEach(@detach);`);
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/IfBlock.js
function is_else_if(node) {
  return node && node.children.length === 1 && node.children[0].type === "IfBlock";
}
var IfBlockBranch = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {IfBlockWrapper} parent
   * @param {import('../../nodes/IfBlock.js').default | import('../../nodes/ElseBlock.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {import('../Block.js').default} */
    __publicField(this, "block");
    /** @type {import('./Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {string[]} */
    __publicField(this, "dependencies");
    /** @type {any} */
    __publicField(this, "condition");
    /** @type {import('estree').Node} */
    __publicField(this, "snippet");
    /** @type {boolean} */
    __publicField(this, "is_dynamic");
    /** */
    __publicField(this, "var", null);
    /** @type {import('estree').Node | undefined} */
    __publicField(this, "get_ctx_name");
    const { expression } = (
      /** @type {import('../../nodes/IfBlock.js').default} */
      node
    );
    const is_else = !expression;
    if (expression) {
      this.dependencies = expression.dynamic_dependencies();
      let should_cache2 = false;
      walk(expression.node, {
        enter(node2) {
          if (node2.type === "CallExpression" || node2.type === "NewExpression") {
            should_cache2 = true;
          }
        }
      });
      if (should_cache2) {
        this.condition = block.get_unique_name("show_if");
        this.snippet = /** @type {import('estree').Node} */
        expression.manipulate(block);
      } else {
        this.condition = expression.manipulate(block);
      }
    }
    add_const_tags_context(renderer, this.node.const_tags);
    this.block = block.child({
      comment: create_debugging_comment(node, parent.renderer.component),
      name: parent.renderer.component.get_unique_name(
        is_else ? "create_else_block" : "create_if_block"
      ),
      type: (
        /** @type {import('../../nodes/IfBlock.js').default} */
        node.expression ? "if" : "else"
      )
    });
    this.fragment = new FragmentWrapper(
      renderer,
      this.block,
      node.children,
      parent,
      strip_whitespace,
      next_sibling
    );
    this.is_dynamic = this.block.dependencies.size > 0;
    if (node.const_tags.length > 0) {
      this.get_ctx_name = parent.renderer.component.get_unique_name(
        is_else ? "get_else_ctx" : "get_if_ctx"
      );
    }
  }
};
var IfBlockWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/IfBlock.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @typedef {'detaching' | null} DetachingOrNull */
    /** @type {IfBlockBranch[]} */
    __publicField(this, "branches");
    /** */
    __publicField(this, "needs_update", false);
    /** @type {import('estree').Identifier} */
    __publicField(this, "var", { type: "Identifier", name: "if_block" });
    this.branches = [];
    const blocks = [];
    let is_dynamic3 = false;
    let has_intros = false;
    let has_outros = false;
    const create_branches = (node2) => {
      const branch = new IfBlockBranch(renderer, block, this, node2, strip_whitespace, next_sibling);
      this.branches.push(branch);
      blocks.push(branch.block);
      block.add_dependencies(node2.expression.dependencies);
      if (branch.block.dependencies.size > 0) {
        is_dynamic3 = true;
        block.add_dependencies(branch.block.dependencies);
      }
      if (branch.dependencies && branch.dependencies.length > 0) {
        this.needs_update = true;
      }
      if (branch.block.has_intros)
        has_intros = true;
      if (branch.block.has_outros)
        has_outros = true;
      if (is_else_if(node2.else)) {
        create_branches(
          /** @type {import('../../nodes/IfBlock.js').default} */
          node2.else.children[0]
        );
      } else if (node2.else) {
        const branch2 = new IfBlockBranch(
          renderer,
          block,
          this,
          node2.else,
          strip_whitespace,
          next_sibling
        );
        this.branches.push(branch2);
        blocks.push(branch2.block);
        if (branch2.block.dependencies.size > 0) {
          is_dynamic3 = true;
          block.add_dependencies(branch2.block.dependencies);
        }
        if (branch2.block.has_intros)
          has_intros = true;
        if (branch2.block.has_outros)
          has_outros = true;
      }
    };
    create_branches(this.node);
    blocks.forEach((block2) => {
      block2.has_update_method = is_dynamic3;
      block2.has_intro_method = has_intros;
      block2.has_outro_method = has_outros;
    });
    push_array(renderer.blocks, blocks);
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    const name8 = this.var;
    const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
    const anchor = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || "null";
    const has_else = !this.branches[this.branches.length - 1].condition;
    const if_exists_condition = has_else ? null : name8;
    const dynamic = this.branches[0].block.has_update_method;
    const has_intros = this.branches[0].block.has_intro_method;
    const has_outros = this.branches[0].block.has_outro_method;
    const has_transitions = has_intros || has_outros;
    this.branches.forEach((branch) => {
      if (branch.get_ctx_name) {
        this.renderer.blocks.push(b`
				function ${branch.get_ctx_name}(#ctx) {
					const child_ctx = #ctx.slice();
					${add_const_tags(block, branch.node.const_tags, "child_ctx")}
					return child_ctx;
				}
				`);
      }
    });
    const vars = { name: name8, anchor, if_exists_condition, has_else, has_transitions };
    const detaching = parent_node && !is_head(parent_node) ? null : "detaching";
    if (this.node.else) {
      this.branches.forEach((branch) => {
        if (branch.snippet)
          block.add_variable(branch.condition);
      });
      if (has_outros) {
        this.render_compound_with_outros(
          block,
          parent_node,
          parent_nodes,
          dynamic,
          vars,
          detaching
        );
        block.chunks.outro.push(b`@transition_out(${name8});`);
      } else {
        this.render_compound(block, parent_node, parent_nodes, dynamic, vars, detaching);
      }
    } else {
      this.render_simple(block, parent_node, parent_nodes, dynamic, vars, detaching);
      if (has_outros) {
        block.chunks.outro.push(b`@transition_out(${name8});`);
      }
    }
    if (if_exists_condition) {
      block.chunks.create.push(b`if (${if_exists_condition}) ${name8}.c();`);
    } else {
      block.chunks.create.push(b`${name8}.c();`);
    }
    if (parent_nodes && this.renderer.options.hydratable) {
      if (if_exists_condition) {
        block.chunks.claim.push(b`if (${if_exists_condition}) ${name8}.l(${parent_nodes});`);
      } else {
        block.chunks.claim.push(b`${name8}.l(${parent_nodes});`);
      }
    }
    if (has_intros || has_outros) {
      block.chunks.intro.push(b`@transition_in(${name8});`);
    }
    if (needs_anchor) {
      block.add_element(
        /** @type {import('estree').Identifier} */
        anchor,
        x`@empty()`,
        parent_nodes && x`@empty()`,
        parent_node
      );
    }
    this.branches.forEach((branch) => {
      branch.fragment.render(
        branch.block,
        null,
        /** @type {unknown} */
        /** @type {import('estree').Identifier} */
        x`#nodes`
      );
    });
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} _parent_nodes
   * @param {boolean} dynamic
   * @param {any} opts
   * @param {DetachingOrNull} detaching
   */
  render_compound(block, parent_node, _parent_nodes, dynamic, { name: name8, anchor, has_else, if_exists_condition, has_transitions }, detaching) {
    const select_block_type = this.renderer.component.get_unique_name("select_block_type");
    const current_block_type = block.get_unique_name("current_block_type");
    const need_select_block_ctx = this.branches.some((branch) => branch.get_ctx_name);
    const select_block_ctx = need_select_block_ctx ? block.get_unique_name("select_block_ctx") : null;
    const if_ctx = select_block_ctx ? x`${select_block_ctx}(#ctx, ${current_block_type})` : x`#ctx`;
    const get_block = has_else ? x`${current_block_type}(${if_ctx})` : x`${current_block_type} && ${current_block_type}(${if_ctx})`;
    if (this.needs_update) {
      block.chunks.init.push(b`
				function ${select_block_type}(#ctx, #dirty) {
					${this.branches.map(({ dependencies, condition, snippet }) => {
        return b`${snippet && dependencies.length > 0 ? b`if (${block.renderer.dirty(dependencies)}) ${condition} = null;` : null}`;
      })}
					${this.branches.map(
        ({ condition, snippet, block: block2 }) => condition ? b`
								${snippet && b`if (${condition} == null) ${condition} = !!${snippet}`}
								if (${condition}) return ${block2.name};` : b`return ${block2.name};`
      )}
				}
			`);
    } else {
      block.chunks.init.push(b`
				function ${select_block_type}(#ctx, #dirty) {
					${this.branches.map(
        ({ condition, snippet, block: block2 }) => condition ? b`if (${snippet || condition}) return ${block2.name};` : b`return ${block2.name};`
      )}
				}
			`);
    }
    if (need_select_block_ctx) {
      if (this.branches.every((branch) => branch.get_ctx_name)) {
        block.chunks.init.push(b`
					function ${select_block_ctx}(#ctx, #type) {
						${this.branches.map(({ condition, get_ctx_name, block: block2 }) => {
          return condition ? b`if (#type === ${block2.name}) return ${get_ctx_name}(#ctx);` : b`return ${get_ctx_name}(#ctx);`;
        }).filter(Boolean)}
					}
				`);
      } else {
        block.chunks.init.push(b`
					function ${select_block_ctx}(#ctx, #type) {
						${this.branches.map(({ get_ctx_name, block: block2 }) => {
          return get_ctx_name ? b`if (#type === ${block2.name}) return ${get_ctx_name}(#ctx);` : null;
        }).filter(Boolean)}
						return #ctx;
					}
				`);
      }
    }
    block.chunks.init.push(b`
			let ${current_block_type} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()});
			let ${name8} = ${get_block};
		`);
    const initial_mount_node = parent_node || "#target";
    const anchor_node = parent_node ? "null" : "#anchor";
    if (if_exists_condition) {
      block.chunks.mount.push(
        b`if (${if_exists_condition}) ${name8}.m(${initial_mount_node}, ${anchor_node});`
      );
    } else {
      block.chunks.mount.push(b`${name8}.m(${initial_mount_node}, ${anchor_node});`);
    }
    if (this.needs_update) {
      const update_mount_node = this.get_update_mount_node(anchor);
      const change_block = b`
				${if_exists_condition ? b`if (${if_exists_condition}) ${name8}.d(1)` : b`${name8}.d(1)`};
				${name8} = ${get_block};
				if (${name8}) {
					${name8}.c();
					${has_transitions && b`@transition_in(${name8}, 1);`}
					${name8}.m(${update_mount_node}, ${anchor});
				}
			`;
      if (dynamic) {
        block.chunks.update.push(b`
					if (${current_block_type} === (${current_block_type} = ${select_block_type}(#ctx, #dirty)) && ${name8}) {
						${name8}.p(${if_ctx}, #dirty);
					} else {
						${change_block}
					}
				`);
      } else {
        block.chunks.update.push(b`
					if (${current_block_type} !== (${current_block_type} = ${select_block_type}(#ctx, #dirty))) {
						${change_block}
					}
				`);
      }
    } else if (dynamic) {
      if (if_exists_condition) {
        block.chunks.update.push(b`if (${if_exists_condition}) ${name8}.p(${if_ctx}, #dirty);`);
      } else {
        block.chunks.update.push(b`${name8}.p(${if_ctx}, #dirty);`);
      }
    }
    if (if_exists_condition) {
      block.chunks.destroy.push(b`
				if (${if_exists_condition}) {
					${name8}.d(${detaching});
				}
			`);
    } else {
      block.chunks.destroy.push(b`
				${name8}.d(${detaching});
			`);
    }
  }
  // if any of the siblings have outros, we need to keep references to the blocks
  // (TODO does this only apply to bidi transitions?)
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} _parent_nodes
   * @param {boolean} dynamic
   * @param {any} opts
   * @param {DetachingOrNull} detaching
   */
  render_compound_with_outros(block, parent_node, _parent_nodes, dynamic, { name: name8, anchor, has_else, has_transitions, if_exists_condition }, detaching) {
    const select_block_type = this.renderer.component.get_unique_name("select_block_type");
    const current_block_type_index = block.get_unique_name("current_block_type_index");
    const previous_block_index = block.get_unique_name("previous_block_index");
    const if_block_creators = block.get_unique_name("if_block_creators");
    const if_blocks = block.get_unique_name("if_blocks");
    const need_select_block_ctx = this.branches.some((branch) => branch.get_ctx_name);
    const select_block_ctx = need_select_block_ctx ? block.get_unique_name("select_block_ctx") : null;
    const if_ctx = select_block_ctx ? x`${select_block_ctx}(#ctx, ${current_block_type_index})` : x`#ctx`;
    const if_current_block_type_index = has_else ? (nodes) => nodes : (nodes) => b`if (~${current_block_type_index}) { ${nodes} }`;
    block.add_variable(current_block_type_index);
    block.add_variable(name8);
    block.chunks.init.push(b`
			const ${if_block_creators} = [
				${this.branches.map((branch) => branch.block.name)}
			];

			const ${if_blocks} = [];

			${this.needs_update ? b`
					function ${select_block_type}(#ctx, #dirty) {
						${this.branches.map(({ dependencies, condition, snippet }) => {
      return b`${snippet && dependencies.length > 0 ? b`if (${block.renderer.dirty(dependencies)}) ${condition} = null;` : null}`;
    })}
						${this.branches.map(
      ({ condition, snippet }, i) => condition ? b`
								${snippet && b`if (${condition} == null) ${condition} = !!${snippet}`}
								if (${condition}) return ${i};` : b`return ${i};`
    )}
								${!has_else && b`return -1;`}
							}
						` : b`
					function ${select_block_type}(#ctx, #dirty) {
						${this.branches.map(
      ({ condition, snippet }, i) => condition ? b`if (${snippet || condition}) return ${i};` : b`return ${i};`
    )}
						${!has_else && b`return -1;`}
					}
				`}
		`);
    if (need_select_block_ctx) {
      if (this.branches.every((branch) => branch.get_ctx_name)) {
        block.chunks.init.push(b`
					function ${select_block_ctx}(#ctx, #index) {
						${this.branches.map(({ condition, get_ctx_name }, i) => {
          return condition ? b`if (#index === ${i}) return ${get_ctx_name}(#ctx);` : b`return ${get_ctx_name}(#ctx);`;
        }).filter(Boolean)}
					}
				`);
      } else {
        block.chunks.init.push(b`
					function ${select_block_ctx}(#ctx, #index) {
						${this.branches.map(({ get_ctx_name }, i) => {
          return get_ctx_name ? b`if (#index === ${i}) return ${get_ctx_name}(#ctx);` : null;
        }).filter(Boolean)}
						return #ctx;
					}
				`);
      }
    }
    if (has_else) {
      block.chunks.init.push(b`
				${current_block_type_index} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()});
				${name8} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](${if_ctx});
			`);
    } else {
      block.chunks.init.push(b`
				if (~(${current_block_type_index} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()}))) {
					${name8} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](${if_ctx});
				}
			`);
    }
    const initial_mount_node = parent_node || "#target";
    const anchor_node = parent_node ? "null" : "#anchor";
    block.chunks.mount.push(
      if_current_block_type_index(
        b`${if_blocks}[${current_block_type_index}].m(${initial_mount_node}, ${anchor_node});`
      )
    );
    if (this.needs_update) {
      const update_mount_node = this.get_update_mount_node(anchor);
      const destroy_old_block = b`
				@group_outros();
				@transition_out(${if_blocks}[${previous_block_index}], 1, 1, () => {
					${if_blocks}[${previous_block_index}] = null;
				});
				@check_outros();
			`;
      const create_new_block = b`
				${name8} = ${if_blocks}[${current_block_type_index}];
				if (!${name8}) {
					${name8} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](${if_ctx});
					${name8}.c();
				} else {
					${dynamic && b`${name8}.p(${if_ctx}, #dirty);`}
				}
				${has_transitions && b`@transition_in(${name8}, 1);`}
				${name8}.m(${update_mount_node}, ${anchor});
			`;
      const change_block = has_else ? b`
					${destroy_old_block}

					${create_new_block}
				` : b`
					if (${name8}) {
						${destroy_old_block}
					}

					if (~${current_block_type_index}) {
						${create_new_block}
					} else {
						${name8} = null;
					}
				`;
      block.chunks.update.push(b`
				let ${previous_block_index} = ${current_block_type_index};
				${current_block_type_index} = ${select_block_type}(#ctx, #dirty);
			`);
      if (dynamic) {
        block.chunks.update.push(b`
					if (${current_block_type_index} === ${previous_block_index}) {
						${if_current_block_type_index(b`${if_blocks}[${current_block_type_index}].p(${if_ctx}, #dirty);`)}
					} else {
						${change_block}
					}
				`);
      } else {
        block.chunks.update.push(b`
					if (${current_block_type_index} !== ${previous_block_index}) {
						${change_block}
					}
				`);
      }
    } else if (dynamic) {
      if (if_exists_condition) {
        block.chunks.update.push(b`if (${if_exists_condition}) ${name8}.p(${if_ctx}, #dirty);`);
      } else {
        block.chunks.update.push(b`${name8}.p(${if_ctx}, #dirty);`);
      }
    }
    block.chunks.destroy.push(
      if_current_block_type_index(b`${if_blocks}[${current_block_type_index}].d(${detaching});`)
    );
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} _parent_nodes
   * @param {boolean} dynamic
   * @param {any} opts
   * @param {DetachingOrNull} detaching
   */
  render_simple(block, parent_node, _parent_nodes, dynamic, { name: name8, anchor, if_exists_condition, has_transitions }, detaching) {
    const branch = this.branches[0];
    const if_ctx = branch.get_ctx_name ? x`${branch.get_ctx_name}(#ctx)` : x`#ctx`;
    if (branch.snippet)
      block.add_variable(branch.condition, branch.snippet);
    block.chunks.init.push(b`
			let ${name8} = ${branch.condition} && ${branch.block.name}(${if_ctx});
		`);
    const initial_mount_node = parent_node || "#target";
    const anchor_node = parent_node ? "null" : "#anchor";
    block.chunks.mount.push(b`if (${name8}) ${name8}.m(${initial_mount_node}, ${anchor_node});`);
    if (branch.dependencies.length > 0) {
      const update_mount_node = this.get_update_mount_node(anchor);
      const enter = b`
				if (${name8}) {
					${dynamic && b`${name8}.p(${if_ctx}, #dirty);`}
					${has_transitions && b`if (${block.renderer.dirty(branch.dependencies)}) {
									@transition_in(${name8}, 1);
								}`}
				} else {
					${name8} = ${branch.block.name}(${if_ctx});
					${name8}.c();
					${has_transitions && b`@transition_in(${name8}, 1);`}
					${name8}.m(${update_mount_node}, ${anchor});
				}
			`;
      if (branch.snippet) {
        block.chunks.update.push(
          b`if (${block.renderer.dirty(branch.dependencies)}) ${branch.condition} = ${branch.snippet}`
        );
      }
      if (branch.block.has_outro_method) {
        block.chunks.update.push(b`
					if (${branch.condition}) {
						${enter}
					} else if (${name8}) {
						@group_outros();
						@transition_out(${name8}, 1, 1, () => {
							${name8} = null;
						});
						@check_outros();
					}
				`);
      } else {
        block.chunks.update.push(b`
					if (${branch.condition}) {
						${enter}
					} else if (${name8}) {
						${name8}.d(1);
						${name8} = null;
					}
				`);
      }
    } else if (dynamic) {
      block.chunks.update.push(b`
				if (${branch.condition}) ${name8}.p(${if_ctx}, #dirty);
			`);
    }
    if (if_exists_condition) {
      block.chunks.destroy.push(b`
				if (${if_exists_condition}) ${name8}.d(${detaching});
			`);
    } else {
      block.chunks.destroy.push(b`
				${name8}.d(${detaching});
			`);
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/KeyBlock.js
var KeyBlockWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/KeyBlock.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {import('./Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {import('../Block.js').default} */
    __publicField(this, "block");
    /** @type {string[]} */
    __publicField(this, "dependencies");
    /** @type {import('estree').Identifier} */
    __publicField(this, "var", { type: "Identifier", name: "key_block" });
    this.dependencies = node.expression.dynamic_dependencies();
    if (this.dependencies.length) {
      block = block.child({
        comment: create_debugging_comment(node, renderer.component),
        name: renderer.component.get_unique_name("create_key_block"),
        type: "key"
      });
      block.add_dependencies(node.expression.dependencies);
      renderer.blocks.push(block);
    }
    this.block = block;
    this.fragment = new FragmentWrapper(
      renderer,
      this.block,
      node.children,
      this,
      strip_whitespace,
      next_sibling
    );
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    if (this.dependencies.length === 0) {
      this.render_static_key(block, parent_node, parent_nodes);
    } else {
      this.render_dynamic_key(block, parent_node, parent_nodes);
    }
  }
  /**
   * @param {import('../Block.js').default} _block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render_static_key(_block, parent_node, parent_nodes) {
    this.fragment.render(this.block, parent_node, parent_nodes);
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render_dynamic_key(block, parent_node, parent_nodes) {
    this.fragment.render(
      this.block,
      null,
      /** @type {unknown} */
      /** @type {import('estree').Identifier} */
      x`#nodes`
    );
    const has_transitions = !!(this.block.has_intro_method || this.block.has_outro_method);
    const dynamic = this.block.has_update_method;
    const previous_key = block.get_unique_name("previous_key");
    const snippet = this.node.expression.manipulate(block);
    block.add_variable(previous_key, snippet);
    const not_equal = this.renderer.component.component_options.immutable ? x`@not_equal` : x`@safe_not_equal`;
    const condition = x`${this.renderer.dirty(
      this.dependencies
    )} && ${not_equal}(${previous_key}, ${previous_key} = ${snippet})`;
    block.chunks.init.push(b`
			let ${this.var} = ${this.block.name}(#ctx);
		`);
    block.chunks.create.push(b`${this.var}.c();`);
    if (this.renderer.options.hydratable) {
      block.chunks.claim.push(b`${this.var}.l(${parent_nodes});`);
    }
    block.chunks.mount.push(
      b`${this.var}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});`
    );
    const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
    const body = b`
			${has_transitions ? b`
						@group_outros();
						@transition_out(${this.var}, 1, 1, @noop);
						@check_outros();
					` : b`${this.var}.d(1);`}
			${this.var} = ${this.block.name}(#ctx);
			${this.var}.c();
			${has_transitions && b`@transition_in(${this.var}, 1)`}
			${this.var}.m(${this.get_update_mount_node(anchor)}, ${anchor});
		`;
    if (dynamic) {
      block.chunks.update.push(b`
				if (${condition}) {
					${body}
				} else {
					${this.var}.p(#ctx, #dirty);
				}
			`);
    } else {
      block.chunks.update.push(b`
				if (${condition}) {
					${body}
				}
			`);
    }
    if (has_transitions) {
      block.chunks.intro.push(b`@transition_in(${this.var})`);
      block.chunks.outro.push(b`@transition_out(${this.var})`);
    }
    block.chunks.destroy.push(b`${this.var}.d(detaching)`);
  }
};

// node_modules/svelte/src/compiler/compile/utils/string_to_member_expression.js
function string_to_member_expression(name8) {
  const parts = name8.split(".");
  let node = {
    type: "Identifier",
    name: parts[0]
  };
  for (let i = 1; i < parts.length; i++) {
    node = /** @type {import('estree').MemberExpression} */
    {
      type: "MemberExpression",
      object: node,
      property: { type: "Identifier", name: parts[i] }
    };
  }
  return node;
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/get_slot_definition.js
function get_slot_definition(block, scope, lets) {
  if (lets.length === 0)
    return { block, scope };
  const context_input = {
    type: "ObjectPattern",
    properties: lets.map((l) => ({
      type: "Property",
      kind: "init",
      key: l.name,
      value: l.value || l.name
    }))
  };
  const properties2 = [];
  const value_map = /* @__PURE__ */ new Map();
  lets.forEach((l) => {
    let value;
    if (l.names.length > 1) {
      const unique_name = block.get_unique_name(l.names.join("_")).name;
      value_map.set(l.value, unique_name);
      value = { type: "Identifier", name: unique_name };
    } else {
      value = l.value || l.name;
    }
    properties2.push({
      type: "Property",
      kind: "init",
      key: l.name,
      value
    });
  });
  const changes_input = {
    type: "ObjectPattern",
    properties: properties2
  };
  const names = /* @__PURE__ */ new Set();
  const names_lookup = /* @__PURE__ */ new Map();
  lets.forEach((l) => {
    l.names.forEach((name8) => {
      names.add(name8);
      if (value_map.has(l.value)) {
        names_lookup.set(name8, value_map.get(l.value));
      }
    });
  });
  const context = {
    type: "ObjectExpression",
    properties: Array.from(names).map(
      (name8) => p`${block.renderer.context_lookup.get(name8).index}: ${name8}`
    )
  };
  const { context_lookup } = block.renderer;
  const changes = {
    type: "ParenthesizedExpression",
    get expression() {
      if (block.renderer.context_overflow) {
        const grouped = [];
        Array.from(names).forEach((name8) => {
          const i = (
            /** @type {number} */
            context_lookup.get(name8).index.value
          );
          const g = Math.floor(i / 31);
          const lookup_name = names_lookup.has(name8) ? names_lookup.get(name8) : name8;
          if (!grouped[g])
            grouped[g] = [];
          grouped[g].push({ name: lookup_name, n: i % 31 });
        });
        const elements = [];
        for (let g = 0; g < grouped.length; g += 1) {
          elements[g] = grouped[g] ? grouped[g].map(({ name: name8, n }) => x`${name8} ? ${1 << n} : 0`).reduce((lhs, rhs) => x`${lhs} | ${rhs}`) : x`0`;
        }
        return {
          type: "ArrayExpression",
          elements
        };
      }
      return (
        /** @type {import('estree').BinaryExpression} */
        Array.from(names).map((name8) => {
          const lookup_name = names_lookup.has(name8) ? names_lookup.get(name8) : name8;
          const i = (
            /** @type {number} */
            context_lookup.get(name8).index.value
          );
          return x`${lookup_name} ? ${1 << i} : 0`;
        }).reduce((lhs, rhs) => x`${lhs} | ${rhs}`)
      );
    }
  };
  return {
    block,
    scope,
    get_context: x`${context_input} => ${context}`,
    get_changes: x`${changes_input} => ${changes}`
  };
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/SlotTemplate.js
var SlotTemplateWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/SlotTemplate.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {import('./Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {import('../Block.js').default} */
    __publicField(this, "block");
    const { scope, lets, const_tags, slot_template_name } = this.node;
    lets.forEach((l) => {
      extract_names(l.value || l.name).forEach((name8) => {
        renderer.add_to_context(name8, true);
      });
    });
    add_const_tags_context(renderer, const_tags);
    this.block = block.child({
      comment: create_debugging_comment(this.node, this.renderer.component),
      name: this.renderer.component.get_unique_name(`create_${sanitize(slot_template_name)}_slot`),
      type: "slot"
    });
    this.renderer.blocks.push(this.block);
    this.parent.set_slot(
      slot_template_name,
      get_slot_definition(this.block, scope, lets)
    );
    this.fragment = new FragmentWrapper(
      renderer,
      this.block,
      node.type === "SlotTemplate" ? node.children : [node],
      this,
      strip_whitespace,
      next_sibling
    );
    this.block.parent.add_dependencies(this.block.dependencies);
  }
  render() {
    this.fragment.render(
      this.block,
      null,
      /** @type {import('estree').Identifier} */
      x`#nodes`
    );
    if (this.node.const_tags.length > 0) {
      this.render_get_context();
    }
  }
  render_get_context() {
    const get_context2 = this.block.renderer.component.get_unique_name("get_context");
    this.block.renderer.blocks.push(b`
			function ${get_context2}(#ctx) {
				${add_const_tags(this.block, this.node.const_tags, "#ctx")}
			}
		`);
    this.block.chunks.declarations.push(b`${get_context2}(#ctx)`);
    if (this.block.has_update_method) {
      this.block.chunks.update.unshift(b`${get_context2}(#ctx)`);
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/InlineComponent/index.js
var regex_invalid_variable_identifier_characters4 = /[^a-zA-Z_$]/g;
var InlineComponentWrapper = class extends Wrapper {
  /**
   * @param {import('../../Renderer.js').default} renderer
   * @param {import('../../Block.js').default} block
   * @param {import('../shared/Wrapper.js').default} parent
   * @param {import('../../../nodes/InlineComponent.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('../shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /**
     * @typedef {{
     * 	block: import('../../Block.js').default;
     * 	scope: import('../../../nodes/shared/TemplateScope.js').default;
     * 	get_context?: import('estree').Node;
     * 	get_changes?: import('estree').Node;
     * }} SlotDefinition
     */
    /** @type {Map<string, SlotDefinition>} */
    __publicField(this, "slots", /* @__PURE__ */ new Map());
    /** @type {import('../Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {Array<Wrapper | import('../Fragment.js').default>} */
    __publicField(this, "children", []);
    if (this.node.expression) {
      block.add_dependencies(this.node.expression.dependencies);
    }
    this.node.attributes.forEach((attr) => {
      block.add_dependencies(attr.dependencies);
    });
    this.node.bindings.forEach((binding) => {
      if (binding.is_contextual) {
        mark_each_block_bindings(this, binding);
      }
      block.add_dependencies(binding.expression.dependencies);
    });
    this.node.handlers.forEach((handler) => {
      if (handler.expression) {
        block.add_dependencies(handler.expression.dependencies);
      }
    });
    this.node.css_custom_properties.forEach((attr) => {
      block.add_dependencies(attr.dependencies);
    });
    this.var = {
      type: (
        /** @type {const} */
        "Identifier"
      ),
      name: (this.node.name === "svelte:self" ? renderer.component.name.name : this.node.name === "svelte:component" ? "switch_instance" : sanitize(this.node.name)).toLowerCase()
    };
    if (this.node.children.length) {
      this.children = this.node.children.map(
        (child) => new SlotTemplateWrapper(
          renderer,
          block,
          this,
          /** @type {import('../../../nodes/SlotTemplate.js').default} */
          child,
          strip_whitespace,
          next_sibling
        )
      );
    }
    block.add_outro();
  }
  /**
   * @param {string} name
   * @param {SlotDefinition} slot_definition
   */
  set_slot(name8, slot_definition) {
    if (this.slots.has(name8)) {
      if (name8 === "default") {
        throw new Error('Found elements without slot attribute when using slot="default"');
      }
      throw new Error(`Duplicate slot name "${name8}" in <${this.node.name}>`);
    }
    this.slots.set(name8, slot_definition);
  }
  warn_if_reactive() {
    let { name: name8 } = this.node;
    const top = name8.split(".")[0];
    const variable = this.renderer.component.var_lookup.get(top);
    if (!variable) {
      return;
    }
    const ignores = extract_ignores_above_node(this.node);
    this.renderer.component.push_ignores(ignores);
    if (variable.reassigned || variable.export_name || // or a prop
    variable.mutated) {
      this.renderer.component.warn(this.node, compiler_warnings_default.reactive_component(name8));
    }
    this.renderer.component.pop_ignores();
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    this.warn_if_reactive();
    const { renderer } = this;
    const { component } = renderer;
    const name8 = this.var;
    block.add_variable(name8);
    const component_opts = (
      /** @type {import('estree').ObjectExpression} */
      x`{}`
    );
    const statements = [];
    const updates = [];
    this.children.forEach((child) => {
      this.renderer.add_to_context("$$scope", true);
      child.render(
        block,
        null,
        /** @type {import('estree').Identifier} */
        x`#nodes`
      );
    });
    let props;
    const name_changes = block.get_unique_name(`${name8.name}_changes`);
    const uses_spread = !!this.node.attributes.find((a) => a.is_spread);
    for (const slot of this.slots.keys()) {
      if (!this.slots.get(slot).block.has_content()) {
        this.renderer.remove_block(this.slots.get(slot).block);
        this.slots.delete(slot);
      }
    }
    const has_css_custom_properties = this.node.css_custom_properties.length > 0;
    const is_svg_namespace = this.node.namespace === namespaces.svg;
    const css_custom_properties_wrapper_element = is_svg_namespace ? "g" : "div";
    const css_custom_properties_wrapper = has_css_custom_properties ? block.get_unique_name(css_custom_properties_wrapper_element) : null;
    if (has_css_custom_properties) {
      block.add_variable(css_custom_properties_wrapper);
    }
    const initial_props = this.slots.size > 0 ? [
      p`$$slots: {
					${Array.from(this.slots).map(([name9, slot]) => {
        return p`${name9}: [${slot.block.name}, ${slot.get_context || null}, ${slot.get_changes || null}]`;
      })}
				}`,
      p`$$scope: {
					ctx: #ctx
				}`
    ] : [];
    const attribute_object = uses_spread ? x`{ ${initial_props} }` : x`{
				${this.node.attributes.map((attr) => p`${attr.name}: ${attr.get_value(block)}`)},
				${initial_props}
			}`;
    if (this.node.attributes.length || this.node.bindings.length || initial_props.length) {
      if (!uses_spread && this.node.bindings.length === 0) {
        component_opts.properties.push(p`props: ${attribute_object}`);
      } else {
        props = block.get_unique_name(`${name8.name}_props`);
        component_opts.properties.push(p`props: ${props}`);
      }
    }
    if (component.compile_options.dev) {
      component_opts.properties.push(p`$$inline: true`);
    }
    const fragment_dependencies = new Set(this.slots.size ? ["$$scope"] : []);
    this.slots.forEach((slot) => {
      slot.block.dependencies.forEach((name9) => {
        const is_let = slot.scope.is_let(name9);
        const variable = renderer.component.var_lookup.get(name9);
        if (is_let || is_dynamic(variable))
          fragment_dependencies.add(name9);
      });
    });
    const dynamic_attributes = this.node.attributes.filter((a) => a.get_dependencies().length > 0);
    if (!uses_spread && (dynamic_attributes.length > 0 || this.node.bindings.length > 0 || fragment_dependencies.size > 0)) {
      updates.push(b`const ${name_changes} = {};`);
    }
    if (this.node.attributes.length) {
      if (uses_spread) {
        const levels = block.get_unique_name(`${this.var.name}_spread_levels`);
        const initial_props2 = [];
        const changes = [];
        const all_dependencies = /* @__PURE__ */ new Set();
        this.node.attributes.forEach((attr) => {
          add_to_set(all_dependencies, attr.dependencies);
        });
        this.node.attributes.forEach((attr, i) => {
          const { name: name9, dependencies } = attr;
          const condition = dependencies.size > 0 && dependencies.size !== all_dependencies.size ? renderer.dirty(Array.from(dependencies)) : null;
          const unchanged = dependencies.size === 0;
          let change_object;
          if (attr.is_spread) {
            const value = attr.expression.manipulate(block);
            initial_props2.push(value);
            let value_object = value;
            if (attr.expression.node.type !== "ObjectExpression") {
              value_object = x`@get_spread_object(${value})`;
            }
            change_object = value_object;
          } else {
            const obj = x`{ ${name9}: ${attr.get_value(block)} }`;
            initial_props2.push(obj);
            change_object = obj;
          }
          changes.push(
            unchanged ? x`${levels}[${i}]` : condition ? x`${condition} && ${change_object}` : change_object
          );
        });
        block.chunks.init.push(b`
					const ${levels} = [
						${initial_props2}
					];
				`);
        statements.push(b`
					for (let #i = 0; #i < ${levels}.length; #i += 1) {
						${props} = @assign(${props}, ${levels}[#i]);
					}
				`);
        if (all_dependencies.size) {
          const condition = renderer.dirty(Array.from(all_dependencies));
          if (this.node.name === "svelte:component") {
            statements[statements.length - 1] = b`
							if (#dirty !== undefined && ${condition}) {
								${props} = @get_spread_update(${levels}, [
									${changes}
								]);
							} else {
								for (let #i = 0; #i < ${levels}.length; #i += 1) {
									${props} = @assign(${props}, ${levels}[#i]);
								}
							}
						`;
          }
          updates.push(b`
						const ${name_changes} = ${condition} ? @get_spread_update(${levels}, [
							${changes}
						]) : {}
					`);
        } else {
          updates.push(b`
						const ${name_changes} = {};
					`);
        }
      } else {
        dynamic_attributes.forEach((attribute) => {
          const dependencies = attribute.get_dependencies();
          if (dependencies.length > 0) {
            const condition = renderer.dirty(dependencies);
            updates.push(b`
							if (${condition}) ${name_changes}.${attribute.name} = ${attribute.get_value(block)};
						`);
          }
        });
      }
    }
    if (fragment_dependencies.size > 0) {
      updates.push(b`
				if (${renderer.dirty(Array.from(fragment_dependencies))}) {
					${name_changes}.$$scope = { dirty: #dirty, ctx: #ctx };
				}`);
    }
    const munged_bindings = this.node.bindings.map((binding) => {
      component.has_reactive_assignments = true;
      if (binding.name === "this") {
        return bind_this(component, block, new BindingWrapper(block, binding, this), this.var);
      }
      const id = component.get_unique_name(`${this.var.name}_${binding.name}_binding`);
      renderer.add_to_context(id.name);
      const callee = renderer.reference(id);
      const updating = block.get_unique_name(`updating_${binding.name}`);
      block.add_variable(updating);
      const snippet = binding.expression.manipulate(block);
      statements.push(b`
				if (${snippet} !== void 0) {
					${props}.${binding.name} = ${snippet};
				}`);
      updates.push(b`
				if (!${updating} && ${renderer.dirty(Array.from(binding.expression.dependencies))}) {
					${updating} = true;
					${name_changes}.${binding.name} = ${snippet};
					@add_flush_callback(() => ${updating} = false);
				}
			`);
      const contextual_dependencies = Array.from(binding.expression.contextual_dependencies);
      const dependencies = Array.from(binding.expression.dependencies);
      let lhs = binding.raw_expression;
      if (binding.is_contextual && binding.expression.node.type === "Identifier") {
        const { name: name9 } = binding.expression.node;
        const { object, property, snippet: snippet2 } = block.bindings.get(name9);
        lhs = snippet2;
        contextual_dependencies.push(object.name, property.name);
      }
      const params = [
        /** @type {import('estree').Identifier} */
        x`#value`
      ];
      const args = [x`#value`];
      if (contextual_dependencies.length > 0) {
        contextual_dependencies.forEach((name9) => {
          params.push({
            type: "Identifier",
            name: name9
          });
          renderer.add_to_context(name9, true);
          args.push(renderer.reference(name9));
        });
        block.maintain_context = true;
      }
      block.chunks.init.push(b`
				function ${id}(#value) {
					${callee}(${args});
				}
			`);
      let invalidate_binding = b`
				${lhs} = #value;
				${renderer.invalidate(dependencies[0])};
			`;
      if (binding.expression.node.type === "MemberExpression") {
        invalidate_binding = b`
					if ($$self.$$.not_equal(${lhs}, #value)) {
						${invalidate_binding}
					}
				`;
      }
      const body = b`
				function ${id}(${params}) {
					${invalidate_binding}
				}
			`;
      component.partly_hoisted.push(body);
      return b`@binding_callbacks.push(() => @bind(${this.var}, '${binding.name}', ${id}));`;
    });
    const munged_handlers = this.node.handlers.map((handler) => {
      const event_handler = new EventHandlerWrapper(handler, this);
      let snippet = event_handler.get_snippet(block);
      if (handler.modifiers.has("once"))
        snippet = x`@once(${snippet})`;
      return b`${name8}.$on("${handler.name}", ${snippet});`;
    });
    const mount_target = has_css_custom_properties ? css_custom_properties_wrapper : parent_node || "#target";
    const mount_anchor = has_css_custom_properties ? "null" : parent_node ? "null" : "#anchor";
    const to_claim = parent_nodes && this.renderer.options.hydratable;
    let claim_nodes = parent_nodes;
    if (this.node.name === "svelte:component") {
      const switch_value = block.get_unique_name("switch_value");
      const switch_props = block.get_unique_name("switch_props");
      const snippet = this.node.expression.manipulate(block);
      const dependencies = this.node.expression.dynamic_dependencies();
      if (has_css_custom_properties) {
        this.set_css_custom_properties(
          block,
          css_custom_properties_wrapper,
          css_custom_properties_wrapper_element,
          is_svg_namespace
        );
      }
      block.chunks.init.push(b`
				var ${switch_value} = ${snippet};

				function ${switch_props}(#ctx, #dirty) {
					${(this.node.attributes.length > 0 || this.node.bindings.length > 0) && b`
					${props && b`let ${props} = ${attribute_object};`}`}
					${statements}
					return ${component_opts};
				}

				if (${switch_value}) {
					${name8} = @construct_svelte_component(${switch_value}, ${switch_props}(#ctx));

					${munged_bindings}
					${munged_handlers}
				}
			`);
      block.chunks.create.push(b`if (${name8}) @create_component(${name8}.$$.fragment);`);
      if (css_custom_properties_wrapper)
        this.create_css_custom_properties_wrapper_mount_chunk(
          block,
          parent_node,
          css_custom_properties_wrapper
        );
      block.chunks.mount.push(
        b`if (${name8}) @mount_component(${name8}, ${mount_target}, ${mount_anchor});`
      );
      if (to_claim) {
        if (css_custom_properties_wrapper)
          claim_nodes = this.create_css_custom_properties_wrapper_claim_chunk(
            block,
            claim_nodes,
            css_custom_properties_wrapper,
            css_custom_properties_wrapper_element,
            is_svg_namespace
          );
        block.chunks.claim.push(
          b`if (${name8}) @claim_component(${name8}.$$.fragment, ${claim_nodes});`
        );
      }
      const tmp_anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
      const anchor = has_css_custom_properties ? "null" : tmp_anchor;
      const update_mount_node = has_css_custom_properties ? css_custom_properties_wrapper : this.get_update_mount_node(tmp_anchor);
      const update_insert = css_custom_properties_wrapper && (tmp_anchor.name !== "null" ? b`@insert(${tmp_anchor}.parentNode, ${css_custom_properties_wrapper}, ${tmp_anchor});` : b`@insert(${parent_node}, ${css_custom_properties_wrapper}, ${tmp_anchor});`);
      let update_condition = x`${switch_value} !== (${switch_value} = ${snippet})`;
      if (dependencies.length > 0) {
        update_condition = x`${block.renderer.dirty(dependencies)} && ${update_condition}`;
      }
      block.chunks.update.push(b`
				if (${update_condition}) {
					if (${name8}) {
						@group_outros();
						const old_component = ${name8};
						@transition_out(old_component.$$.fragment, 1, 0, () => {
							@destroy_component(old_component, 1);
							${has_css_custom_properties ? b`@detach(${update_mount_node})` : null}
						});
						@check_outros();
					}

					if (${switch_value}) {
						${update_insert}
						${name8} = @construct_svelte_component(${switch_value}, ${switch_props}(#ctx, #dirty));

						${munged_bindings}
						${munged_handlers}

						@create_component(${name8}.$$.fragment);
						@transition_in(${name8}.$$.fragment, 1);
						@mount_component(${name8}, ${update_mount_node}, ${anchor});
					} else {
						${name8} = null;
					}
				} else if (${switch_value}) {
					${updates}
					${updates.length > 0 && b`${name8}.$set(${name_changes});`}
				}
			`);
      block.chunks.intro.push(b`
				if (${name8}) @transition_in(${name8}.$$.fragment, #local);
			`);
      block.chunks.outro.push(b`if (${name8}) @transition_out(${name8}.$$.fragment, #local);`);
      block.chunks.destroy.push(
        b`if (${name8}) @destroy_component(${name8}, ${parent_node ? null : "detaching"});`
      );
    } else {
      const expression = this.node.name === "svelte:self" ? component.name : this.renderer.reference(string_to_member_expression(this.node.name));
      block.chunks.init.push(b`
				${(this.node.attributes.length > 0 || this.node.bindings.length > 0) && b`
				${props && b`let ${props} = ${attribute_object};`}`}
				${statements}
				${name8} = new ${expression}(${component_opts});

				${munged_bindings}
				${munged_handlers}
			`);
      if (has_css_custom_properties) {
        this.set_css_custom_properties(
          block,
          css_custom_properties_wrapper,
          css_custom_properties_wrapper_element,
          is_svg_namespace
        );
      }
      block.chunks.create.push(b`@create_component(${name8}.$$.fragment);`);
      if (css_custom_properties_wrapper)
        this.create_css_custom_properties_wrapper_mount_chunk(
          block,
          parent_node,
          css_custom_properties_wrapper
        );
      block.chunks.mount.push(b`@mount_component(${name8}, ${mount_target}, ${mount_anchor});`);
      if (to_claim) {
        if (css_custom_properties_wrapper)
          claim_nodes = this.create_css_custom_properties_wrapper_claim_chunk(
            block,
            claim_nodes,
            css_custom_properties_wrapper,
            css_custom_properties_wrapper_element,
            is_svg_namespace
          );
        block.chunks.claim.push(b`@claim_component(${name8}.$$.fragment, ${claim_nodes});`);
      }
      block.chunks.intro.push(b`
				@transition_in(${name8}.$$.fragment, #local);
			`);
      if (updates.length) {
        block.chunks.update.push(b`
					${updates}
					${name8}.$set(${name_changes});
				`);
      }
      block.chunks.destroy.push(b`
				@destroy_component(${name8}, ${parent_node ? null : "detaching"});
			`);
      block.chunks.outro.push(b`@transition_out(${name8}.$$.fragment, #local);`);
    }
  }
  /**
   * @private
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier | null} css_custom_properties_wrapper
   */
  create_css_custom_properties_wrapper_mount_chunk(block, parent_node, css_custom_properties_wrapper) {
    if (parent_node) {
      block.chunks.mount.push(b`@append(${parent_node}, ${css_custom_properties_wrapper})`);
      if (is_head(parent_node)) {
        block.chunks.destroy.push(b`@detach(${css_custom_properties_wrapper});`);
      }
    } else {
      block.chunks.mount.push(b`@insert(#target, ${css_custom_properties_wrapper}, #anchor);`);
      block.chunks.destroy.push(
        b`if (detaching && ${this.var}) @detach(${css_custom_properties_wrapper});`
      );
    }
  }
  /**
   * @private
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} parent_nodes
   * @param {import('estree').Identifier | null} css_custom_properties_wrapper
   * @param {string} css_custom_properties_wrapper_element
   * @param {boolean} is_svg_namespace
   */
  create_css_custom_properties_wrapper_claim_chunk(block, parent_nodes, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace) {
    const nodes = block.get_unique_name(`${css_custom_properties_wrapper.name}_nodes`);
    const claim_element = is_svg_namespace ? x`@claim_svg_element` : x`@claim_element`;
    block.chunks.claim.push(b`
			${css_custom_properties_wrapper} = ${claim_element}(${parent_nodes}, "${css_custom_properties_wrapper_element.toUpperCase()}", { style: true })
			var ${nodes} = @children(${css_custom_properties_wrapper});
		`);
    return nodes;
  }
  /**
   * @private
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} css_custom_properties_wrapper
   * @param {string} css_custom_properties_wrapper_element
   * @param {boolean} is_svg_namespace
   */
  set_css_custom_properties(block, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace) {
    const element = is_svg_namespace ? x`@svg_element` : x`@element`;
    block.chunks.create.push(
      b`${css_custom_properties_wrapper} = ${element}("${css_custom_properties_wrapper_element}");`
    );
    if (!is_svg_namespace)
      block.chunks.hydrate.push(
        b`@set_style(${css_custom_properties_wrapper}, "display", "contents");`
      );
    this.node.css_custom_properties.forEach((attr) => {
      const dependencies = attr.get_dependencies();
      const should_cache2 = attr.should_cache();
      const last = should_cache2 && block.get_unique_name(
        `${attr.name.replace(regex_invalid_variable_identifier_characters4, "_")}_last`
      );
      if (should_cache2)
        block.add_variable(last);
      const value = attr.get_value(block);
      const init = should_cache2 ? x`${last} = ${value}` : value;
      block.chunks.hydrate.push(
        b`@set_style(${css_custom_properties_wrapper}, "${attr.name}", ${init});`
      );
      if (dependencies.length > 0) {
        let condition = block.renderer.dirty(dependencies);
        if (should_cache2)
          condition = x`${condition} && (${last} !== (${last} = ${value}))`;
        block.chunks.update.push(b`
					if (${condition}) {
						@set_style(${css_custom_properties_wrapper}, "${attr.name}", ${should_cache2 ? last : value});
					}
				`);
      }
    });
  }
};

// node_modules/svelte/src/compiler/compile/utils/get_slot_data.js
function get_slot_data(values, block = null) {
  return {
    type: "ObjectExpression",
    properties: Array.from(values.values()).filter((attribute) => attribute.name !== "name").map((attribute) => {
      if (attribute.is_spread) {
        const argument = get_spread_value(block, attribute);
        return {
          type: "SpreadElement",
          argument
        };
      }
      const value = get_value(block, attribute);
      return p`${attribute.name}: ${value}`;
    })
  };
}
function get_value(block, attribute) {
  if (attribute.is_true)
    return x`true`;
  if (attribute.chunks.length === 0)
    return x`""`;
  let value = attribute.chunks.map(
    (chunk) => chunk.type === "Text" ? string_literal(chunk.data) : block ? chunk.manipulate(block) : chunk.node
  ).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
  if (attribute.chunks.length > 1 && attribute.chunks[0].type !== "Text") {
    value = x`"" + ${value}`;
  }
  return value;
}
function get_spread_value(block, attribute) {
  return block ? attribute.expression.manipulate(block) : attribute.expression.node;
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Slot.js
var SlotWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/Slot.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {import('./Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {import('../Block.js').default | null} */
    __publicField(this, "fallback", null);
    /** @type {import('../Block.js').default} */
    __publicField(this, "slot_block");
    /** @type {import('estree').Identifier} */
    __publicField(this, "var", { type: "Identifier", name: "slot" });
    /** @type {Set<string>} */
    __publicField(this, "dependencies", /* @__PURE__ */ new Set(["$$scope"]));
    if (this.node.children.length) {
      this.fallback = block.child({
        comment: create_debugging_comment(this.node.children[0], this.renderer.component),
        name: this.renderer.component.get_unique_name("fallback_block"),
        type: "fallback"
      });
      renderer.blocks.push(this.fallback);
    }
    this.fragment = new FragmentWrapper(
      renderer,
      this.fallback,
      node.children,
      this,
      strip_whitespace,
      next_sibling
    );
    this.node.values.forEach((attribute) => {
      add_to_set(this.dependencies, attribute.dependencies);
    });
    block.add_dependencies(this.dependencies);
    block.add_intro();
    block.add_outro();
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    const { renderer } = this;
    const { slot_name } = this.node;
    if (this.slot_block) {
      block = this.slot_block;
    }
    let get_slot_changes_fn;
    let get_slot_spread_changes_fn;
    let get_slot_context_fn;
    if (this.node.values.size > 0) {
      get_slot_changes_fn = renderer.component.get_unique_name(
        `get_${sanitize(slot_name)}_slot_changes`
      );
      get_slot_context_fn = renderer.component.get_unique_name(
        `get_${sanitize(slot_name)}_slot_context`
      );
      const changes = (
        /** @type {import('estree').ObjectExpression} */
        x`{}`
      );
      const spread_dynamic_dependencies = /* @__PURE__ */ new Set();
      this.node.values.forEach((attribute) => {
        if (attribute.type === "Spread") {
          add_to_set(
            spread_dynamic_dependencies,
            Array.from(attribute.dependencies).filter((name8) => this.is_dependency_dynamic(name8))
          );
        } else {
          const dynamic_dependencies2 = Array.from(attribute.dependencies).filter(
            (name8) => this.is_dependency_dynamic(name8)
          );
          if (dynamic_dependencies2.length > 0) {
            changes.properties.push(p`${attribute.name}: ${renderer.dirty(dynamic_dependencies2)}`);
          }
        }
      });
      renderer.blocks.push(b`
				const ${get_slot_changes_fn} = #dirty => ${changes};
				const ${get_slot_context_fn} = #ctx => ${get_slot_data(this.node.values, block)};
			`);
      if (spread_dynamic_dependencies.size) {
        get_slot_spread_changes_fn = renderer.component.get_unique_name(
          `get_${sanitize(slot_name)}_slot_spread_changes`
        );
        renderer.blocks.push(b`
					const ${get_slot_spread_changes_fn} = #dirty => ${renderer.dirty(
          Array.from(spread_dynamic_dependencies)
        )};
				`);
      }
    } else {
      get_slot_changes_fn = "null";
      get_slot_context_fn = "null";
    }
    let has_fallback = !!this.fallback;
    if (this.fallback) {
      this.fragment.render(
        this.fallback,
        null,
        /** @type {import('estree').Identifier} */
        x`#nodes`
      );
      has_fallback = this.fallback.has_content();
      if (!has_fallback) {
        renderer.remove_block(this.fallback);
      }
    }
    const slot = block.get_unique_name(`${sanitize(slot_name)}_slot`);
    const slot_definition = block.get_unique_name(`${sanitize(slot_name)}_slot_template`);
    const slot_or_fallback = has_fallback ? block.get_unique_name(`${sanitize(slot_name)}_slot_or_fallback`) : slot;
    block.chunks.init.push(b`
			const ${slot_definition} = ${renderer.reference("#slots")}.${slot_name};
			const ${slot} = @create_slot(${slot_definition}, #ctx, ${renderer.reference(
      "$$scope"
    )}, ${get_slot_context_fn});
			${has_fallback ? b`const ${slot_or_fallback} = ${slot} || ${this.fallback.name}(#ctx);` : null}
		`);
    block.chunks.create.push(b`if (${slot_or_fallback}) ${slot_or_fallback}.c();`);
    if (renderer.options.hydratable) {
      block.chunks.claim.push(b`if (${slot_or_fallback}) ${slot_or_fallback}.l(${parent_nodes});`);
    }
    block.chunks.mount.push(b`
			if (${slot_or_fallback}) {
				${slot_or_fallback}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});
			}
		`);
    block.chunks.intro.push(b`@transition_in(${slot_or_fallback}, #local);`);
    block.chunks.outro.push(b`@transition_out(${slot_or_fallback}, #local);`);
    const dynamic_dependencies = Array.from(this.dependencies).filter(
      (name8) => this.is_dependency_dynamic(name8)
    );
    const fallback_dynamic_dependencies = has_fallback ? Array.from(this.fallback.dependencies).filter((name8) => this.is_dependency_dynamic(name8)) : [];
    let condition = renderer.dirty(dynamic_dependencies);
    if (block.has_outros) {
      condition = x`!#current || ${condition}`;
    }
    const all_dirty_conditions = [
      get_slot_spread_changes_fn ? x`${get_slot_spread_changes_fn}(#dirty)` : null,
      block.has_outros ? x`!#current` : null
    ].filter(Boolean);
    const all_dirty_condition = all_dirty_conditions.length ? all_dirty_conditions.reduce((condition1, condition2) => x`${condition1} || ${condition2}`) : null;
    let slot_update;
    if (all_dirty_condition) {
      const dirty = x`${all_dirty_condition} ? @get_all_dirty_from_scope(${renderer.reference(
        "$$scope"
      )}) : @get_slot_changes(${slot_definition}, ${renderer.reference(
        "$$scope"
      )}, #dirty, ${get_slot_changes_fn})`;
      slot_update = b`
				if (${slot}.p && ${condition}) {
					@update_slot_base(${slot}, ${slot_definition}, #ctx, ${renderer.reference(
        "$$scope"
      )}, ${dirty}, ${get_slot_context_fn});
				}
			`;
    } else {
      slot_update = b`
				if (${slot}.p && ${condition}) {
					@update_slot(${slot}, ${slot_definition}, #ctx, ${renderer.reference(
        "$$scope"
      )}, #dirty, ${get_slot_changes_fn}, ${get_slot_context_fn});
				}
			`;
    }
    let fallback_condition = renderer.dirty(fallback_dynamic_dependencies);
    let fallback_dirty = x`#dirty`;
    if (block.has_outros) {
      fallback_condition = x`!#current || ${fallback_condition}`;
      fallback_dirty = x`!#current ? ${renderer.get_initial_dirty()} : ${fallback_dirty}`;
    }
    const fallback_update = has_fallback && fallback_dynamic_dependencies.length > 0 && b`
			if (${slot_or_fallback} && ${slot_or_fallback}.p && ${fallback_condition}) {
				${slot_or_fallback}.p(#ctx, ${fallback_dirty});
			}
		`;
    if (fallback_update) {
      block.chunks.update.push(b`
				if (${slot}) {
					${slot_update}
				} else {
					${fallback_update}
				}
			`);
    } else {
      block.chunks.update.push(b`
				if (${slot}) {
					${slot_update}
				}
			`);
    }
    block.chunks.destroy.push(b`if (${slot_or_fallback}) ${slot_or_fallback}.d(detaching);`);
  }
  /** @param {string} name */
  is_dependency_dynamic(name8) {
    if (name8 === "$$scope")
      return true;
    if (this.node.scope.is_let(name8))
      return true;
    if (is_reserved_keyword(name8))
      return true;
    const variable = this.renderer.component.var_lookup.get(name8);
    return is_dynamic(variable);
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Title.js
var TitleWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/Title.js').default} node
   * @param {boolean} _strip_whitespace
   * @param {import('./shared/Wrapper.js').default} _next_sibling
   */
  constructor(renderer, block, parent, node, _strip_whitespace, _next_sibling) {
    super(renderer, block, parent, node);
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} _parent_node
   * @param {import('estree').Identifier} _parent_nodes
   */
  render(block, _parent_node, _parent_nodes) {
    const is_dynamic3 = !!this.node.children.find((node) => node.type !== "Text");
    if (is_dynamic3) {
      let value;
      const all_dependencies = /* @__PURE__ */ new Set();
      if (this.node.children.length === 1) {
        const { expression } = this.node.children[0];
        value = expression.manipulate(block);
        add_to_set(all_dependencies, expression.dependencies);
      } else {
        value = this.node.children.map((chunk) => {
          if (chunk.type === "Text")
            return string_literal(chunk.data);
          chunk.expression.dependencies.forEach((d) => {
            all_dependencies.add(d);
          });
          return (
            /** @type {import('../../nodes/MustacheTag.js').default} */
            chunk.expression.manipulate(block)
          );
        }).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
        if (this.node.children[0].type !== "Text") {
          value = x`"" + ${value}`;
        }
      }
      const last = this.node.should_cache && block.get_unique_name("title_value");
      if (this.node.should_cache)
        block.add_variable(last);
      const init = this.node.should_cache ? x`${last} = ${value}` : value;
      block.chunks.init.push(b`@_document.title = ${init};`);
      const updater = b`@_document.title = ${this.node.should_cache ? last : value};`;
      if (all_dependencies.size) {
        const dependencies = Array.from(all_dependencies);
        let condition = block.renderer.dirty(dependencies);
        if (block.has_outros) {
          condition = x`!#current || ${condition}`;
        }
        if (this.node.should_cache) {
          condition = x`${condition} && (${last} !== (${last} = ${value}))`;
        }
        block.chunks.update.push(b`
					if (${condition}) {
						${updater}
					}`);
      }
    } else {
      const value = this.node.children.length > 0 ? string_literal(
        /** @type {import('../../nodes/Text.js').default} */
        this.node.children[0].data
      ) : x`""`;
      block.chunks.hydrate.push(b`@_document.title = ${value};`);
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Window.js
var associated_events2 = {
  innerWidth: "resize",
  innerHeight: "resize",
  outerWidth: "resize",
  outerHeight: "resize",
  devicePixelRatio: "resize",
  scrollX: "scroll",
  scrollY: "scroll"
};
var properties = {
  scrollX: "pageXOffset",
  scrollY: "pageYOffset"
};
var readonly2 = /* @__PURE__ */ new Set([
  "innerWidth",
  "innerHeight",
  "outerWidth",
  "outerHeight",
  "devicePixelRatio",
  "online"
]);
var WindowWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/Window.js').default} node
   */
  constructor(renderer, block, parent, node) {
    super(renderer, block, parent, node);
    /** @type {import('./Element/EventHandler.js').default[]} */
    __publicField(this, "handlers");
    this.handlers = this.node.handlers.map((handler) => new EventHandlerWrapper(handler, this));
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} _parent_node
   * @param {import('estree').Identifier} _parent_nodes
   */
  render(block, _parent_node, _parent_nodes) {
    const { renderer } = this;
    const { component } = renderer;
    const events2 = {};
    const bindings = {};
    add_actions(block, "@_window", this.node.actions);
    add_event_handlers(block, "@_window", this.handlers);
    this.node.bindings.forEach((binding) => {
      const binding_name = (
        /** @type {import('estree').Identifier} */
        binding.expression.node.name
      );
      if (readonly2.has(binding.name)) {
        renderer.readonly.add(binding_name);
      }
      bindings[binding.name] = binding_name;
      if (binding.name === "online")
        return;
      const associated_event = associated_events2[binding.name];
      const property = properties[binding.name] || binding.name;
      if (!events2[associated_event])
        events2[associated_event] = [];
      events2[associated_event].push({
        name: binding_name,
        value: property
      });
    });
    const scrolling = block.get_unique_name("scrolling");
    const clear_scrolling = block.get_unique_name("clear_scrolling");
    const scrolling_timeout = block.get_unique_name("scrolling_timeout");
    Object.keys(events2).forEach((event) => {
      const id = block.get_unique_name(`onwindow${event}`);
      const props = events2[event];
      renderer.add_to_context(id.name);
      const fn = renderer.reference(id.name);
      if (event === "scroll") {
        block.add_variable(scrolling, x`false`);
        block.add_variable(clear_scrolling, x`() => { ${scrolling} = false }`);
        block.add_variable(scrolling_timeout);
        const condition = bindings.scrollX && bindings.scrollY ? x`"${bindings.scrollX}" in this._state || "${bindings.scrollY}" in this._state` : x`"${bindings.scrollX || bindings.scrollY}" in this._state`;
        const scroll_x = bindings.scrollX && x`this._state.${bindings.scrollX}`;
        const scroll_y = bindings.scrollY && x`this._state.${bindings.scrollY}`;
        renderer.meta_bindings.push(b`
					if (${condition}) {
						@_scrollTo(${scroll_x || "@_window.pageXOffset"}, ${scroll_y || "@_window.pageYOffset"});
					}
					${scroll_x && `${scroll_x} = @_window.pageXOffset;`}
					${scroll_y && `${scroll_y} = @_window.pageYOffset;`}
				`);
        block.event_listeners.push(x`
					@listen(@_window, "${event}", () => {
						${scrolling} = true;
						@_clearTimeout(${scrolling_timeout});
						${scrolling_timeout} = @_setTimeout(${clear_scrolling}, 100);
						${fn}();
					})
				`);
      } else {
        props.forEach((prop) => {
          renderer.meta_bindings.push(b`this._state.${prop.name} = @_window.${prop.value};`);
        });
        block.event_listeners.push(x`
					@listen(@_window, "${event}", ${fn})
				`);
      }
      component.partly_hoisted.push(b`
				function ${id}() {
					${props.map((prop) => renderer.invalidate(prop.name, x`${prop.name} = @_window.${prop.value}`))}
				}
			`);
      block.chunks.init.push(b`
				@add_render_callback(${fn});
			`);
      component.has_reactive_assignments = true;
    });
    if (bindings.scrollX || bindings.scrollY) {
      const condition = renderer.dirty([bindings.scrollX, bindings.scrollY].filter(Boolean));
      const scroll_x = bindings.scrollX ? renderer.reference(bindings.scrollX) : x`@_window.pageXOffset`;
      const scroll_y = bindings.scrollY ? renderer.reference(bindings.scrollY) : x`@_window.pageYOffset`;
      block.chunks.update.push(b`
				if (${condition} && !${scrolling}) {
					${scrolling} = true;
					@_clearTimeout(${scrolling_timeout});
					@_scrollTo(${scroll_x}, ${scroll_y});
					${scrolling_timeout} = @_setTimeout(${clear_scrolling}, 100);
				}
			`);
    }
    if (bindings.online) {
      const id = block.get_unique_name("onlinestatuschanged");
      const name8 = bindings.online;
      renderer.add_to_context(id.name);
      const reference = renderer.reference(id.name);
      component.partly_hoisted.push(b`
				function ${id}() {
					${renderer.invalidate(name8, x`${name8} = @_navigator.onLine`)}
				}
			`);
      block.chunks.init.push(b`
				@add_render_callback(${reference});
			`);
      block.event_listeners.push(
        x`@listen(@_window, "online", ${reference})`,
        x`@listen(@_window, "offline", ${reference})`
      );
      component.has_reactive_assignments = true;
    }
  }
};

// node_modules/svelte/src/compiler/utils/link.js
function link(next, prev) {
  prev.next = next;
  if (next)
    next.prev = prev;
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Fragment.js
var wrappers = {
  AwaitBlock: AwaitBlockWrapper,
  Body: BodyWrapper,
  Comment: CommentWrapper,
  DebugTag: DebugTagWrapper,
  Document: DocumentWrapper,
  EachBlock: EachBlockWrapper,
  Element: ElementWrapper,
  Head: HeadWrapper,
  IfBlock: IfBlockWrapper,
  InlineComponent: InlineComponentWrapper,
  KeyBlock: KeyBlockWrapper,
  MustacheTag: MustacheTagWrapper,
  Options: null,
  RawMustacheTag: RawMustacheTagWrapper,
  Slot: SlotWrapper,
  SlotTemplate: SlotTemplateWrapper,
  Text: TextWrapper,
  Title: TitleWrapper,
  Window: WindowWrapper
};
function trimmable_at(child, next_sibling) {
  return next_sibling.node.find_nearest(/EachBlock/) === child.find_nearest(/EachBlock/) || next_sibling.node.prev.type === "EachBlock";
}
var FragmentWrapper = class {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('../../nodes/interfaces.js').INode[]} nodes
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, nodes, parent, strip_whitespace, next_sibling) {
    /** @type {import('./shared/Wrapper.js').default[]} */
    __publicField(this, "nodes");
    this.nodes = [];
    let last_child;
    let window_wrapper;
    let i = nodes.length;
    while (i--) {
      const child = nodes[i];
      if (!child.type) {
        throw new Error("missing type");
      }
      if (!(child.type in wrappers)) {
        throw new Error(`TODO implement ${child.type}`);
      }
      if (child.type === "Window") {
        window_wrapper = new WindowWrapper(renderer, block, parent, child);
        continue;
      }
      if (child.type === "Text") {
        let { data } = child;
        if (this.nodes.length === 0) {
          const should_trim = next_sibling ? next_sibling.node.type === "Text" && regex_starts_with_whitespace.test(next_sibling.node.data) && trimmable_at(child, next_sibling) : !child.has_ancestor("EachBlock");
          if (should_trim && !child.keep_space()) {
            data = trim_end(data);
            if (!data)
              continue;
          }
        }
        if (last_child && last_child.node.type === "Text") {
          last_child.data = data + /** @type {import('./Text.js').default} */
          last_child.data;
          continue;
        }
        const wrapper = new TextWrapper(renderer, block, parent, child, data);
        if (wrapper.skip)
          continue;
        this.nodes.unshift(wrapper);
        link(last_child, last_child = wrapper);
      } else {
        const Wrapper2 = wrappers[child.type];
        if (!Wrapper2 || child.type === "Comment" && !renderer.options.preserveComments)
          continue;
        const wrapper = new Wrapper2(
          renderer,
          block,
          parent,
          child,
          strip_whitespace,
          last_child || next_sibling
        );
        this.nodes.unshift(wrapper);
        link(last_child, last_child = wrapper);
      }
    }
    if (strip_whitespace) {
      const first = (
        /** @type {import('./Text.js').default} */
        this.nodes[0]
      );
      if (first && first.node.type === "Text" && !first.node.keep_space()) {
        first.data = trim_start(first.data);
        if (!first.data) {
          first.var = null;
          this.nodes.shift();
          if (this.nodes[0]) {
            this.nodes[0].prev = null;
          }
        }
      }
    }
    if (window_wrapper) {
      this.nodes.unshift(window_wrapper);
      link(last_child, window_wrapper);
    }
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    for (let i = 0; i < this.nodes.length; i += 1) {
      this.nodes[i].render(block, parent_node, parent_nodes);
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/Renderer.js
var Renderer = class {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('../../interfaces.js').CompileOptions} options
   */
  constructor(component, options) {
    /**
     * @typedef {Object} ContextMember
     * @property {string} name
     * @property {import('estree').Literal} index
     * @property {boolean} is_contextual
     * @property {boolean} is_non_contextual
     * @property {import('../../interfaces.js').Var} variable
     * @property {number} priority
     */
    /**
     * @typedef {Array<{
     * 	n: number;
     * 	names: string[];
     * }>} BitMasks
     */
    /** @type {import('../Component.js').default} */
    __publicField(this, "component");
    // TODO Maybe Renderer shouldn't know about Component?
    /** @type {import('../../interfaces.js').CompileOptions} */
    __publicField(this, "options");
    /** @type {ContextMember[]} */
    __publicField(this, "context", []);
    /** @type {ContextMember[]} */
    __publicField(this, "initial_context", []);
    /** @type {Map<string, ContextMember>} */
    __publicField(this, "context_lookup", /* @__PURE__ */ new Map());
    /** @type {boolean} */
    __publicField(this, "context_overflow");
    /** @type {Array<import('./Block.js').default | import('estree').Node | import('estree').Node[]>} */
    __publicField(this, "blocks", []);
    /** @type {Set<string>} */
    __publicField(this, "readonly", /* @__PURE__ */ new Set());
    /** @type {Array<import('estree').Node | import('estree').Node[]>} */
    __publicField(this, "meta_bindings", []);
    // initial values for e.g. window.innerWidth, if there's a <svelte:window> meta tag
    /** @type {Map<string, BindingGroup>} */
    __publicField(this, "binding_groups", /* @__PURE__ */ new Map());
    /** @type {import('./Block.js').default} */
    __publicField(this, "block");
    /** @type {import('./wrappers/Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {import('estree').Identifier} */
    __publicField(this, "file_var");
    /**
     * Use this for stack traces. It is 1-based and acts on pre-processed sources.
     * Use `meta_locate` for metadata on DOM elements.
     * @type {(c: number) => { line: number; column: number }}
     */
    __publicField(this, "locate");
    /**
     * Use this for metadata on DOM elements. It is 1-based and acts on sources that have not been pre-processed.
     * Use `locate` for source mappings.
     * @type {(c: number) => { line: number; column: number }}
     */
    __publicField(this, "meta_locate");
    this.component = component;
    this.options = options;
    this.locate = component.locate;
    this.meta_locate = component.meta_locate;
    this.file_var = options.dev && this.component.get_unique_name("file");
    component.vars.filter((v) => !v.hoistable || v.export_name && !v.module).forEach((v) => this.add_to_context(v.name));
    component.vars.filter((v) => v.subscribable).forEach((v) => this.add_to_context(`$${v.name}`));
    reserved_keywords.forEach((keyword) => {
      if (component.var_lookup.has(keyword)) {
        this.add_to_context(keyword);
      }
    });
    if (component.slots.size > 0) {
      this.add_to_context("$$scope");
      this.add_to_context("#slots");
    }
    this.block = new Block({
      renderer: this,
      name: null,
      type: "component",
      key: null,
      bindings: /* @__PURE__ */ new Map(),
      dependencies: /* @__PURE__ */ new Set()
    });
    this.block.has_update_method = true;
    this.fragment = new FragmentWrapper(
      this,
      this.block,
      component.fragment.children,
      null,
      true,
      null
    );
    this.blocks.forEach((block) => {
      if (block instanceof Block) {
        block.assign_variable_names();
      }
    });
    this.block.assign_variable_names();
    this.fragment.render(
      this.block,
      null,
      /** @type {import('estree').Identifier} */
      x`#nodes`
    );
    this.context_overflow = this.context.length > 31;
    this.context.forEach((member) => {
      const { variable } = member;
      if (variable) {
        member.priority += 2;
        if (variable.mutated || variable.reassigned)
          member.priority += 4;
        if (variable.is_reactive_dependency && (variable.mutated || variable.reassigned))
          member.priority += 16;
        if (variable.export_name)
          member.priority += 32;
        if (variable.referenced)
          member.priority += 64;
      } else if (member.is_non_contextual) {
        member.priority += 8;
      }
      if (!member.is_contextual) {
        member.priority += 1;
      }
    });
    this.context.sort(
      (a, b2) => b2.priority - a.priority || /** @type {number} */
      a.index.value - /** @type {number} */
      b2.index.value
    );
    this.context.forEach((member, i2) => member.index.value = i2);
    let i = this.context.length;
    while (i--) {
      const member = this.context[i];
      if (member.variable) {
        if (member.variable.referenced || member.variable.export_name || member.variable.is_reactive_dependency && (member.variable.mutated || member.variable.reassigned))
          break;
      } else if (member.is_non_contextual) {
        break;
      }
    }
    this.initial_context = this.context.slice(0, i + 1);
  }
  /**
   * @param {string} name
   * @param {any} contextual
   */
  add_to_context(name8, contextual = false) {
    if (!this.context_lookup.has(name8)) {
      const member2 = {
        name: name8,
        index: { type: "Literal", value: this.context.length },
        is_contextual: false,
        is_non_contextual: false,
        variable: null,
        priority: 0
      };
      this.context_lookup.set(name8, member2);
      this.context.push(member2);
    }
    const member = this.context_lookup.get(name8);
    if (contextual) {
      member.is_contextual = true;
    } else {
      member.is_non_contextual = true;
      member.variable = this.component.var_lookup.get(name8);
    }
    return member;
  }
  /**
   * @param {string} name
   * @param {unknown} [value]
   * @param {boolean} main_execution_context
   */
  invalidate(name8, value, main_execution_context = false) {
    return renderer_invalidate(this, name8, value, main_execution_context);
  }
  /**
   * @param {string[]} names
   * @param {any} is_reactive_declaration
   * @returns {import('estree').Expression}
   */
  dirty(names, is_reactive_declaration = false) {
    const renderer = this;
    const dirty = (
      /** @type {| import('estree').Identifier
          | import('estree').MemberExpression} */
      is_reactive_declaration ? x`$$self.$$.dirty` : x`#dirty`
    );
    const get_bitmask = () => {
      const bitmask = [];
      names.forEach((name8) => {
        const member = renderer.context_lookup.get(name8);
        if (!member)
          return;
        if (member.index.value === -1) {
          throw new Error("unset index");
        }
        const value = (
          /** @type {number} */
          member.index.value
        );
        const i = value / 31 | 0;
        const n = 1 << value % 31;
        if (!bitmask[i])
          bitmask[i] = { n: 0, names: [] };
        bitmask[i].n |= n;
        bitmask[i].names.push(name8);
      });
      return bitmask;
    };
    return (
      /** @type {any} */
      {
        // Using a ParenthesizedExpression allows us to create
        // the expression lazily. TODO would be better if
        // context was determined before rendering, so that
        // this indirection was unnecessary
        type: "ParenthesizedExpression",
        get expression() {
          const bitmask = get_bitmask();
          if (!bitmask.length) {
            return (
              /** @type {import('estree').BinaryExpression} */
              x`${dirty} & /*${names.join(", ")}*/ 0`
            );
          }
          if (renderer.context_overflow) {
            return bitmask.map((b2, i) => ({ b: b2, i })).filter(({ b: b2 }) => b2).map(({ b: b2, i }) => x`${dirty}[${i}] & /*${b2.names.join(", ")}*/ ${b2.n}`).reduce((lhs, rhs) => x`${lhs} | ${rhs}`);
          }
          return (
            /** @type {import('estree').BinaryExpression} */
            x`${dirty} & /*${names.join(", ")}*/ ${bitmask[0].n}`
          );
        }
      }
    );
  }
  // NOTE: this method may be called before this.context_overflow / this.context is fully defined
  // therefore, they can only be evaluated later in a getter function
  /** @returns {import('estree').UnaryExpression | import('estree').ArrayExpression} */
  get_initial_dirty() {
    const _this = this;
    const val = (
      /** @type {import('estree').UnaryExpression} */
      x`-1`
    );
    return {
      get type() {
        return _this.context_overflow ? "ArrayExpression" : "UnaryExpression";
      },
      // as [-1]
      get elements() {
        const elements = [];
        for (let i = 0; i < _this.context.length; i += 31) {
          elements.push(val);
        }
        return elements;
      },
      // as -1
      operator: val.operator,
      prefix: val.prefix,
      argument: val.argument
    };
  }
  /**
   * @param {string | import('estree').Identifier | import('estree').MemberExpression} node
   * @param {string | void} ctx
   */
  reference(node, ctx = "#ctx") {
    if (typeof node === "string") {
      node = { type: "Identifier", name: node };
    }
    const { name: name8, nodes } = flatten_reference(node);
    const member = this.context_lookup.get(name8);
    if (this.component.var_lookup.get(name8)) {
      this.component.add_reference(node, name8);
    }
    if (member !== void 0) {
      const replacement = (
        /** @type {import('estree').MemberExpression} */
        x`/*${member.name}*/ ${ctx}[${member.index}]`
      );
      if (nodes[0].loc)
        replacement.object.loc = nodes[0].loc;
      nodes[0] = replacement;
      return nodes.reduce((lhs, rhs) => x`${lhs}.${rhs}`);
    }
    return node;
  }
  /** @param {import('./Block.js').default | import('estree').Node | import('estree').Node[]} block */
  remove_block(block) {
    this.blocks.splice(this.blocks.indexOf(block), 1);
  }
};

// node_modules/svelte/src/compiler/utils/mapped_code.js
var import_remapping = __toESM(require_remapping_umd(), 1);
function last_line_length(s) {
  return s.length - s.lastIndexOf("\n") - 1;
}
function sourcemap_add_offset(map, offset, source_index) {
  if (map.mappings.length == 0)
    return;
  for (let line = 0; line < map.mappings.length; line++) {
    const segment_list = map.mappings[line];
    for (let segment = 0; segment < segment_list.length; segment++) {
      const seg = segment_list[segment];
      if (seg[1] === source_index) {
        if (seg[2] === 0) {
          seg[3] += offset.column;
        }
        seg[2] += offset.line;
      }
    }
  }
}
function merge_tables(this_table, other_table) {
  const new_table = this_table.slice();
  const idx_map = [];
  other_table = other_table || [];
  let val_changed = false;
  for (const [other_idx, other_val] of other_table.entries()) {
    const this_idx = this_table.indexOf(other_val);
    if (this_idx >= 0) {
      idx_map[other_idx] = this_idx;
    } else {
      const new_idx = new_table.length;
      new_table[new_idx] = other_val;
      idx_map[other_idx] = new_idx;
      val_changed = true;
    }
  }
  let idx_changed = val_changed;
  if (val_changed) {
    if (idx_map.find((val, idx) => val != idx) === void 0) {
      idx_changed = false;
    }
  }
  return [new_table, idx_map, val_changed, idx_changed];
}
var regex_line_token = /([^\d\w\s]|\s+)/g;
var MappedCode = class _MappedCode {
  constructor(string = "", map = null) {
    /**
     * @type {string}
     */
    __publicField(this, "string");
    /**
     * @type {import('@ampproject/remapping').DecodedSourceMap}
     */
    __publicField(this, "map");
    this.string = string;
    if (map) {
      this.map = map;
    } else {
      this.map = {
        version: 3,
        mappings: [],
        sources: [],
        names: []
      };
    }
  }
  /**
   * concat in-place (mutable), return this (chainable)
   * will also mutate the `other` object
   * @param {MappedCode} other
   * @returns {MappedCode}
   */
  concat(other) {
    if (other.string == "")
      return this;
    if (this.string == "") {
      this.string = other.string;
      this.map = other.map;
      return this;
    }
    const column_offset = last_line_length(this.string);
    this.string += other.string;
    const m1 = this.map;
    const m2 = other.map;
    if (m2.mappings.length == 0)
      return this;
    const [sources, new_source_idx, sources_changed, sources_idx_changed] = merge_tables(
      m1.sources,
      m2.sources
    );
    const [names, new_name_idx, names_changed, names_idx_changed] = merge_tables(
      m1.names,
      m2.names
    );
    if (sources_changed)
      m1.sources = sources;
    if (names_changed)
      m1.names = names;
    if (sources_idx_changed && names_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[1] >= 0)
            seg[1] = new_source_idx[seg[1]];
          if (seg[4] >= 0)
            seg[4] = new_name_idx[seg[4]];
        }
      }
    } else if (sources_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[1] >= 0)
            seg[1] = new_source_idx[seg[1]];
        }
      }
    } else if (names_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[4] >= 0)
            seg[4] = new_name_idx[seg[4]];
        }
      }
    }
    if (m2.mappings.length > 0 && column_offset > 0) {
      const first_line = m2.mappings[0];
      for (let i = 0; i < first_line.length; i++) {
        first_line[i][0] += column_offset;
      }
    }
    push_array(m1.mappings[m1.mappings.length - 1], m2.mappings.shift());
    push_array(m1.mappings, m2.mappings);
    return this;
  }
  /**
   * @static
   * @param {string} string
   * @param {import('@ampproject/remapping').DecodedSourceMap} [map]
   * @returns {MappedCode}
   */
  static from_processed(string, map) {
    const line_count = string.split("\n").length;
    if (map) {
      const missing_lines = line_count - map.mappings.length;
      for (let i = 0; i < missing_lines; i++) {
        map.mappings.push([]);
      }
      return new _MappedCode(string, map);
    }
    if (string == "")
      return new _MappedCode();
    map = { version: 3, names: [], sources: [], mappings: [] };
    for (let i = 0; i < line_count; i++)
      map.mappings.push([]);
    return new _MappedCode(string, map);
  }
  /**
   * @static
   * @param {import('../preprocess/private.js').Source} opts
   * @returns {MappedCode}
   */
  static from_source({ source, file_basename, get_location }) {
    let offset = get_location(0);
    if (!offset)
      offset = { line: 0, column: 0 };
    const map = { version: 3, names: [], sources: [file_basename], mappings: [] };
    if (source == "")
      return new _MappedCode(source, map);
    const line_list = source.split("\n");
    for (let line = 0; line < line_list.length; line++) {
      map.mappings.push([]);
      const token_list = line_list[line].split(regex_line_token);
      for (let token = 0, column = 0; token < token_list.length; token++) {
        if (token_list[token] == "")
          continue;
        map.mappings[line].push([column, 0, offset.line + line, column]);
        column += token_list[token].length;
      }
    }
    const segment_list = map.mappings[0];
    for (let segment = 0; segment < segment_list.length; segment++) {
      segment_list[segment][3] += offset.column;
    }
    return new _MappedCode(source, map);
  }
};
function combine_sourcemaps(filename, sourcemap_list) {
  if (sourcemap_list.length == 0)
    return null;
  let map_idx = 1;
  const map = sourcemap_list.slice(0, -1).find((m) => m.sources.length !== 1) === void 0 ? (0, import_remapping.default)(
    // use array interface
    // only the oldest sourcemap can have multiple sources
    sourcemap_list,
    () => null,
    true
    // skip optional field `sourcesContent`
  ) : (0, import_remapping.default)(
    // use loader interface
    sourcemap_list[0],
    // last map
    (sourcefile) => {
      if (sourcefile === filename && sourcemap_list[map_idx]) {
        return sourcemap_list[map_idx++];
      } else {
        return null;
      }
    },
    true
  );
  if (!map.file)
    delete map.file;
  if (!map.sources.length)
    map.sources = [filename];
  return map;
}
function apply_preprocessor_sourcemap(filename, svelte_map, preprocessor_map_input) {
  if (!svelte_map || !preprocessor_map_input)
    return svelte_map;
  const preprocessor_map = typeof preprocessor_map_input === "string" ? JSON.parse(preprocessor_map_input) : preprocessor_map_input;
  const result_map = combine_sourcemaps(filename, [svelte_map, preprocessor_map]);
  Object.defineProperties(result_map, {
    toString: {
      enumerable: false,
      value: function toString() {
        return JSON.stringify(this);
      }
    },
    toUrl: {
      enumerable: false,
      value: function toUrl() {
        let b64 = "";
        if (typeof window !== "undefined" && window.btoa) {
          b64 = window.btoa(unescape(encodeURIComponent(this.toString())));
        } else if (typeof Buffer !== "undefined") {
          b64 = Buffer.from(this.toString(), "utf8").toString("base64");
        } else {
          throw new Error(
            "Unsupported environment: `window.btoa` or `Buffer` should be present to use toUrl."
          );
        }
        return "data:application/json;charset=utf-8;base64," + b64;
      }
    }
  });
  return (
    /** @type {import('magic-string').SourceMap} */
    result_map
  );
}
var regex_data_uri = /data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(\S*)/;
function parse_attached_sourcemap(processed, tag_name) {
  const r_in = "[#@]\\s*sourceMappingURL\\s*=\\s*(\\S*)";
  const regex = tag_name == "script" ? new RegExp("(?://" + r_in + ")|(?:/\\*" + r_in + "\\s*\\*/)$") : new RegExp("/\\*" + r_in + "\\s*\\*/$");
  function log_warning(message) {
    const code_start = processed.code.length < 100 ? processed.code : processed.code.slice(0, 100) + " [...]";
    console.warn(`warning: ${message}. processed.code = ${JSON.stringify(code_start)}`);
  }
  processed.code = processed.code.replace(regex, (_, match1, match2) => {
    const map_url = tag_name == "script" ? match1 || match2 : match1;
    const map_data = (map_url.match(regex_data_uri) || [])[1];
    if (map_data) {
      if (processed.map) {
        log_warning(
          "Not implemented. Found sourcemap in both processed.code and processed.map. Please update your preprocessor to return only one sourcemap."
        );
        return "";
      }
      processed.map = atob(map_data);
      return "";
    }
    if (!processed.map) {
      log_warning(
        `Found sourcemap path ${JSON.stringify(
          map_url
        )} in processed.code, but no sourcemap data. Please update your preprocessor to return sourcemap data directly.`
      );
    }
    return "";
  });
}

// node_modules/svelte/src/compiler/compile/utils/check_enable_sourcemap.js
function check_enable_sourcemap(enable_sourcemap, namespace) {
  return typeof enable_sourcemap === "boolean" ? enable_sourcemap : enable_sourcemap[namespace];
}

// node_modules/svelte/src/compiler/compile/render_dom/index.js
function dom(component, options) {
  var _a, _b, _c;
  const { name: name8 } = component;
  const renderer = new Renderer(component, options);
  const { block } = renderer;
  block.has_outro_method = true;
  const body = [];
  if (renderer.file_var) {
    const file = component.file ? x`"${component.file}"` : x`undefined`;
    body.push(b`const ${renderer.file_var} = ${file};`);
  }
  const css = component.stylesheet.render(options.filename);
  const css_sourcemap_enabled = check_enable_sourcemap(options.enableSourcemap, "css");
  if (css_sourcemap_enabled) {
    css.map = apply_preprocessor_sourcemap(
      options.filename,
      css.map,
      /** @type {string | import('@ampproject/remapping').RawSourceMap | import('@ampproject/remapping').DecodedSourceMap} */
      options.sourcemap
    );
  } else {
    css.map = null;
  }
  const styles = css_sourcemap_enabled && component.stylesheet.has_styles && options.dev ? `${css.code}
/*# sourceMappingURL=${css.map.toUrl()} */` : css.code;
  const add_css = component.get_unique_name("add_css");
  const should_add_css = !!styles && (options.customElement || options.css === "injected");
  if (should_add_css) {
    body.push(b`
			function ${add_css}(target) {
				@append_styles(target, "${component.stylesheet.id}", "${styles}");
			}
		`);
  }
  const blocks = renderer.blocks.slice().reverse();
  push_array(
    body,
    blocks.map((block2) => {
      if (
        /** @type {import('./Block.js').default} */
        block2.render
      )
        return (
          /** @type {import('./Block.js').default} */
          block2.render()
        );
      return block2;
    })
  );
  if (options.dev && !options.hydratable) {
    block.chunks.claim.push(
      b`throw new @_Error("options.hydrate only works if the component was compiled with the \`hydratable: true\` option");`
    );
  }
  const uses_slots = component.var_lookup.has("$$slots");
  let compute_slots;
  if (uses_slots) {
    compute_slots = b`
			const $$slots = @compute_slots(#slots);
		`;
  }
  const uses_props = component.var_lookup.has("$$props");
  const uses_rest = component.var_lookup.has("$$restProps");
  const $$props = uses_props || uses_rest ? "$$new_props" : "$$props";
  const props = component.vars.filter((variable) => !variable.module && variable.export_name);
  const writable_props = props.filter((variable) => variable.writable);
  const omit_props_names = component.get_unique_name("omit_props_names");
  const compute_rest = x`@compute_rest_props($$props, ${omit_props_names.name})`;
  const rest = uses_rest ? b`
		const ${omit_props_names.name} = [${props.map((prop) => `"${prop.export_name}"`).join(",")}];
		let $$restProps = ${compute_rest};
	` : null;
  const set = uses_props || uses_rest || writable_props.length > 0 || component.slots.size > 0 ? x`
			${$$props} => {
				${uses_props && renderer.invalidate(
    "$$props",
    x`$$props = @assign(@assign({}, $$props), @exclude_internal_props($$new_props))`
  )}
				${uses_rest && !uses_props && x`$$props = @assign(@assign({}, $$props), @exclude_internal_props($$new_props))`}
				${uses_rest && renderer.invalidate("$$restProps", x`$$restProps = ${compute_rest}`)}
				${writable_props.map(
    (prop) => b`if ('${prop.export_name}' in ${$$props}) ${renderer.invalidate(
      prop.name,
      x`${prop.name} = ${$$props}.${prop.export_name}`
    )};`
  )}
				${component.slots.size > 0 && b`if ('$$scope' in ${$$props}) ${renderer.invalidate(
    "$$scope",
    x`$$scope = ${$$props}.$$scope`
  )};`}
			}
		` : null;
  const accessors = [];
  const not_equal = component.component_options.immutable ? x`@not_equal` : x`@safe_not_equal`;
  let missing_props_check;
  let inject_state;
  let capture_state;
  let props_inject;
  props.forEach((prop) => {
    const variable = component.var_lookup.get(prop.name);
    if (!variable.writable || component.component_options.accessors) {
      accessors.push({
        type: "MethodDefinition",
        kind: "get",
        key: { type: "Identifier", name: prop.export_name },
        value: x`function() {
					return ${prop.hoistable ? prop.name : x`this.$$.ctx[${renderer.context_lookup.get(prop.name).index}]`}
				}`
      });
    } else if (component.compile_options.dev) {
      accessors.push({
        type: "MethodDefinition",
        kind: "get",
        key: { type: "Identifier", name: prop.export_name },
        value: x`function() {
					throw new @_Error("<${component.tag}>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
				}`
      });
    }
    if (component.component_options.accessors) {
      if (variable.writable && !renderer.readonly.has(prop.name)) {
        accessors.push({
          type: "MethodDefinition",
          kind: "set",
          key: { type: "Identifier", name: prop.export_name },
          value: x`function(${prop.name}) {
						this.$$set({ ${prop.export_name}: ${prop.name} });
						@flush();
					}`
        });
      } else if (component.compile_options.dev) {
        accessors.push({
          type: "MethodDefinition",
          kind: "set",
          key: { type: "Identifier", name: prop.export_name },
          value: x`function(value) {
						throw new @_Error("<${component.tag}>: Cannot set read-only property '${prop.export_name}'");
					}`
        });
      }
    } else if (component.compile_options.dev) {
      accessors.push({
        type: "MethodDefinition",
        kind: "set",
        key: { type: "Identifier", name: prop.export_name },
        value: x`function(value) {
					throw new @_Error("<${component.tag}>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
				}`
      });
    }
  });
  component.instance_exports_from.forEach((exports_from) => {
    const import_declaration = {
      ...exports_from,
      type: "ImportDeclaration",
      specifiers: [],
      source: exports_from.source
    };
    component.imports.push(
      /** @type {import('estree').ImportDeclaration} */
      import_declaration
    );
    exports_from.specifiers.forEach((specifier) => {
      if (component.component_options.accessors) {
        const name9 = component.get_unique_name(specifier.exported.name);
        import_declaration.specifiers.push({
          ...specifier,
          type: "ImportSpecifier",
          imported: specifier.local,
          local: name9
        });
        accessors.push({
          type: "MethodDefinition",
          kind: "get",
          key: { type: "Identifier", name: specifier.exported.name },
          value: x`function() {
						return ${name9}
					}`
        });
      } else if (component.compile_options.dev) {
        accessors.push({
          type: "MethodDefinition",
          kind: "get",
          key: { type: "Identifier", name: specifier.exported.name },
          value: x`function() {
						throw new @_Error("<${component.tag}>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
					}`
        });
      }
    });
  });
  if (component.compile_options.dev) {
    const expected = props.filter((prop) => prop.writable && !prop.initialised);
    if (expected.length) {
      missing_props_check = b`
				$$self.$$.on_mount.push(function () {
					${expected.map(
        (prop) => b`
					if (${prop.name} === undefined && !(('${prop.export_name}' in $$props) || $$self.$$.bound[$$self.$$.props['${prop.export_name}']])) {
						@_console.warn("<${component.tag}> was created without expected prop '${prop.export_name}'");
					}`
      )}
				});
			`;
    }
    const capturable_vars = component.vars.filter(
      (v) => !v.internal && !v.global && !v.name.startsWith("$$")
    );
    if (capturable_vars.length > 0) {
      capture_state = x`() => ({ ${capturable_vars.map((prop) => p`${prop.name}`)} })`;
    }
    const injectable_vars = capturable_vars.filter(
      (v) => !v.module && v.writable && v.name[0] !== "$"
    );
    if (uses_props || injectable_vars.length > 0) {
      inject_state = x`
				${$$props} => {
					${uses_props && renderer.invalidate("$$props", x`$$props = @assign(@assign({}, $$props), $$new_props)`)}
					${injectable_vars.map(
        (v) => b`if ('${v.name}' in $$props) ${renderer.invalidate(
          v.name,
          x`${v.name} = ${$$props}.${v.name}`
        )};`
      )}
				}
			`;
      props_inject = b`
				if ($$props && "$$inject" in $$props) {
					$$self.$inject_state($$props.$$inject);
				}
			`;
    }
  }
  if (component.ast.instance) {
    let scope = component.instance_scope;
    const map = component.instance_scope_map;
    let execution_context = null;
    walk(component.ast.instance.content, {
      enter(node) {
        if (map.has(node)) {
          scope = /** @type {import('periscopic').Scope} */
          map.get(node);
          if (!execution_context && !scope.block) {
            execution_context = node;
          }
        } else if (!execution_context && node.type === "LabeledStatement" && node.label.name === "$") {
          execution_context = node;
        }
      },
      leave(node) {
        if (map.has(node)) {
          scope = scope.parent;
        }
        if (execution_context === node) {
          execution_context = null;
        }
        if (node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
          const assignee = node.type === "AssignmentExpression" ? node.left : node.argument;
          const names = new Set(extract_names(
            /** @type {import('estree').Node} */
            assignee
          ));
          this.replace(invalidate(renderer, scope, node, names, execution_context === null));
        }
      }
    });
    component.rewrite_props(({ name: name9, reassigned, export_name }) => {
      const value = `$${name9}`;
      const i = renderer.context_lookup.get(`$${name9}`).index;
      const insert = reassigned || export_name ? b`${`$$subscribe_${name9}`}()` : b`@component_subscribe($$self, ${name9}, #value => $$invalidate(${i}, ${value} = #value))`;
      if (component.compile_options.dev) {
        return b`@validate_store(${name9}, '${name9}'); ${insert}`;
      }
      return insert;
    });
  }
  const args = [x`$$self`];
  const has_invalidate = props.length > 0 || component.has_reactive_assignments || component.slots.size > 0 || capture_state || inject_state;
  if (has_invalidate) {
    args.push(x`$$props`, x`$$invalidate`);
  } else if (component.compile_options.dev) {
    args.push(x`$$props`);
  }
  const has_create_fragment = component.compile_options.dev || block.has_content();
  if (has_create_fragment) {
    body.push(b`
			function create_fragment(#ctx) {
				${block.get_contents()}
			}
		`);
  }
  body.push(b`
		${component.extract_javascript(component.ast.module)}

		${component.fully_hoisted}
	`);
  const filtered_props = props.filter((prop) => {
    const variable = component.var_lookup.get(prop.name);
    if (variable.hoistable)
      return false;
    return prop.name[0] !== "$";
  });
  const reactive_stores = component.vars.filter(
    (variable) => variable.name[0] === "$" && variable.name[1] !== "$"
  );
  const instance_javascript = component.extract_javascript(component.ast.instance);
  const has_definition = component.compile_options.dev || instance_javascript && instance_javascript.length > 0 || filtered_props.length > 0 || uses_props || component.partly_hoisted.length > 0 || renderer.initial_context.length > 0 || component.reactive_declarations.length > 0 || capture_state || inject_state;
  const definition = has_definition ? component.alias("instance") : { type: "Literal", value: null };
  const reactive_store_subscriptions = reactive_stores.filter((store) => {
    const variable = component.var_lookup.get(store.name.slice(1));
    return !variable || variable.hoistable;
  }).map(
    ({ name: name9 }) => b`
			${component.compile_options.dev && b`@validate_store(${name9.slice(1)}, '${name9.slice(1)}');`}
			@component_subscribe($$self, ${name9.slice(1)}, $$value => $$invalidate(${renderer.context_lookup.get(name9).index}, ${name9} = $$value));
		`
  );
  const resubscribable_reactive_store_unsubscribers = reactive_stores.filter((store) => {
    const variable = component.var_lookup.get(store.name.slice(1));
    return variable && (variable.reassigned || variable.export_name);
  }).map(({ name: name9 }) => b`$$self.$$.on_destroy.push(() => ${`$$unsubscribe_${name9.slice(1)}`}());`);
  if (has_definition) {
    const reactive_declarations = [];
    const fixed_reactive_declarations = [];
    component.reactive_declarations.forEach((d) => {
      const dependencies = Array.from(d.dependencies);
      const uses_rest_or_props = !!dependencies.find((n) => n === "$$props" || n === "$$restProps");
      const writable = dependencies.filter((n) => {
        const variable = component.var_lookup.get(n);
        return variable && (variable.export_name || variable.mutated || variable.reassigned);
      });
      const condition = !uses_rest_or_props && writable.length > 0 && renderer.dirty(writable, true);
      let statement = d.node;
      if (condition)
        statement = /** @type {import('estree').Statement} */
        b`if (${condition}) { ${statement} }`[0];
      if (condition || uses_rest_or_props) {
        reactive_declarations.push(statement);
      } else {
        fixed_reactive_declarations.push(statement);
      }
    });
    const injected = Array.from(component.injected_reactive_declaration_vars).filter((name9) => {
      const variable = component.var_lookup.get(name9);
      return variable.injected && variable.name[0] !== "$";
    });
    const reactive_store_declarations = reactive_stores.map((variable) => {
      const $name = variable.name;
      const name9 = $name.slice(1);
      const store = component.var_lookup.get(name9);
      if (store && (store.reassigned || store.export_name)) {
        const unsubscribe = `$$unsubscribe_${name9}`;
        const subscribe = `$$subscribe_${name9}`;
        const i = renderer.context_lookup.get($name).index;
        return b`let ${$name}, ${unsubscribe} = @noop, ${subscribe} = () => (${unsubscribe}(), ${unsubscribe} = @subscribe(${name9}, $$value => $$invalidate(${i}, ${$name} = $$value)), ${name9})`;
      }
      return b`let ${$name};`;
    });
    let unknown_props_check;
    if (component.compile_options.dev && !(uses_props || uses_rest)) {
      unknown_props_check = b`
				const writable_props = [${writable_props.map((prop) => x`'${prop.export_name}'`)}];
				@_Object.keys($$props).forEach(key => {
					if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') @_console.warn(\`<${component.tag}> was created with unknown prop '\${key}'\`);
				});
			`;
    }
    const return_value = {
      type: "ArrayExpression",
      elements: renderer.initial_context.map(
        (member) => (
          /** @type {import('estree').Expression} */
          {
            type: "Identifier",
            name: member.name
          }
        )
      )
    };
    body.push(b`
			function ${definition}(${args}) {
				${injected.map((name9) => b`let ${name9};`)}

				${rest}

				${reactive_store_declarations}

				${reactive_store_subscriptions}

				${resubscribable_reactive_store_unsubscribers}

				${component.slots.size || component.compile_options.dev || uses_slots ? b`let { $$slots: #slots = {}, $$scope } = $$props;` : null}
				${component.compile_options.dev && b`@validate_slots('${component.tag}', #slots, [${[...component.slots.keys()].map((key) => `'${key}'`).join(",")}]);`}
				${compute_slots}

				${instance_javascript}

				${missing_props_check}
				${unknown_props_check}

				${renderer.binding_groups.size > 0 && b`const $$binding_groups = [${[...renderer.binding_groups.keys()].map((_) => x`[]`)}];`}

				${component.partly_hoisted}

				${set && b`$$self.$$set = ${set};`}

				${capture_state && b`$$self.$capture_state = ${capture_state};`}

				${inject_state && b`$$self.$inject_state = ${inject_state};`}

				${/* before reactive declarations */
    props_inject}

				${reactive_declarations.length > 0 && b`
				$$self.$$.update = () => {
					${reactive_declarations}
				};
				`}

				${fixed_reactive_declarations}

				${uses_props && b`$$props = @exclude_internal_props($$props);`}

				return ${return_value};
			}
		`);
  }
  const prop_indexes = (
    /** @type {import('estree').ObjectExpression} */
    x`{
		${props.filter((v) => v.export_name && !v.module).map((v) => p`${v.export_name}: ${renderer.context_lookup.get(v.name).index}`)}
	}`
  );
  let dirty;
  if (renderer.context_overflow) {
    dirty = x`[]`;
    for (let i = 0; i < renderer.context.length; i += 31) {
      dirty.elements.push(x`-1`);
    }
  }
  const superclass = {
    type: "Identifier",
    name: options.dev ? "@SvelteComponentDev" : "@SvelteComponent"
  };
  const optional_parameters = [];
  if (should_add_css) {
    optional_parameters.push(add_css);
  } else if (dirty) {
    optional_parameters.push(x`null`);
  }
  if (dirty) {
    optional_parameters.push(dirty);
  }
  const declaration = (
    /** @type {import('estree').ClassDeclaration} */
    b`
		class ${name8} extends ${superclass} {
			constructor(options) {
				super(${options.dev && "options"});
				@init(this, options, ${definition}, ${has_create_fragment ? "create_fragment" : "null"}, ${not_equal}, ${prop_indexes}, ${optional_parameters});
				${options.dev && b`@dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "${name8.name}", options, id: create_fragment.name });`}
			}
		}
	`[0]
  );
  push_array(declaration.body.body, accessors);
  body.push(
    /** @type {any} */
    declaration
  );
  if (options.customElement) {
    const props_str = writable_props.reduce((def, prop) => {
      var _a2, _b2;
      def[prop.export_name] = ((_b2 = (_a2 = component.component_options.customElement) == null ? void 0 : _a2.props) == null ? void 0 : _b2[prop.export_name]) || {};
      if (prop.is_boolean && !def[prop.export_name].type) {
        def[prop.export_name].type = "Boolean";
      }
      return def;
    }, {});
    const slots_str = [...component.slots.keys()].map((key) => `"${key}"`).join(",");
    const accessors_str = accessors.filter(
      (accessor) => accessor.kind === "get" && !writable_props.some((prop) => prop.export_name === accessor.key.name)
    ).map((accessor) => `"${accessor.key.name}"`).join(",");
    const use_shadow_dom = ((_a = component.component_options.customElement) == null ? void 0 : _a.shadow) !== "none" ? "true" : "false";
    const create_ce = x`@create_custom_element(${name8}, ${JSON.stringify(
      props_str
    )}, [${slots_str}], [${accessors_str}], ${use_shadow_dom}, ${(_b = component.component_options.customElement) == null ? void 0 : _b.extend})`;
    if ((_c = component.component_options.customElement) == null ? void 0 : _c.tag) {
      body.push(
        b`@_customElements.define("${component.component_options.customElement.tag}", ${create_ce});`
      );
    } else {
      body.push(b`${create_ce}`);
    }
  }
  if (options.discloseVersion === true) {
    component.imports.unshift({
      type: "ImportDeclaration",
      specifiers: [],
      source: {
        type: "Literal",
        value: `${options.sveltePath ?? "svelte"}/internal/disclose-version`
      }
    });
  }
  return { js: flatten(body), css };
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/shared/get_const_tags.js
function get_const_tags2(const_tags) {
  if (const_tags.length === 0)
    return null;
  return {
    type: "VariableDeclaration",
    kind: "let",
    declarations: const_tags.map((const_tag) => {
      const assignment = const_tag.node.expression;
      return {
        type: "VariableDeclarator",
        id: assignment.left,
        init: assignment.right
      };
    })
  };
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/AwaitBlock.js
function AwaitBlock_default(node, renderer, options) {
  renderer.push();
  renderer.render(node.pending.children, options);
  const pending = renderer.pop();
  renderer.push();
  renderer.render(node.then.children, options);
  const then = renderer.pop();
  renderer.add_expression(x`
		function(__value) {
			if (@is_promise(__value)) {
				__value.then(null, @noop);
				return ${pending};
			}
			return (function(${node.then_node ? node.then_node : ""}) { ${get_const_tags2(
    node.then.const_tags
  )}; return ${then}; }(__value));
		}(${node.expression.node})
	`);
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/Comment.js
function Comment_default(node, renderer, options) {
  if (options.preserveComments) {
    renderer.add_string(`<!--${node.data}-->`);
  }
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/DebugTag.js
function DebugTag_default(node, renderer, options) {
  if (!options.dev)
    return;
  const filename = options.filename || null;
  const { line, column } = options.locate(node.start + 1);
  const obj = x`{
		${node.expressions.map((e) => p`${/** @type {import('estree').Identifier} */
  e.node.name}`)}
	}`;
  renderer.add_expression(
    x`@debug(${filename ? x`"${filename}"` : x`null`}, ${line - 1}, ${column}, ${obj})`
  );
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/EachBlock.js
function EachBlock_default(node, renderer, options) {
  const args = [node.context_node];
  if (node.index)
    args.push({ type: "Identifier", name: node.index });
  renderer.push();
  renderer.render(node.children, options);
  const result = renderer.pop();
  const consequent = x`@each(${node.expression.node}, (${args}) => { ${get_const_tags2(
    node.const_tags
  )}; return ${result} })`;
  if (node.else) {
    renderer.push();
    renderer.render(node.else.children, options);
    let alternate = renderer.pop();
    if (node.else.const_tags.length > 0)
      alternate = x`(() => { ${get_const_tags2(node.else.const_tags)}; return ${alternate} })()`;
    renderer.add_expression(x`${node.expression.node}.length ? ${consequent} : ${alternate}`);
  } else {
    renderer.add_expression(consequent);
  }
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/shared/get_attribute_value.js
function get_class_attribute_value(attribute) {
  if (attribute.chunks.length === 2 && /** @type {import('../../../nodes/Text.js').default} */
  attribute.chunks[1].synthetic) {
    const value = (
      /** @type {import('../../../nodes/shared/Expression.js').default} */
      attribute.chunks[0].node
    );
    return x`@escape(@null_to_empty(${value}), true) + "${/** @type {import('../../../nodes/Text.js').default} */
    attribute.chunks[1].data}"`;
  }
  return get_attribute_value(attribute);
}
function get_attribute_value(attribute) {
  if (attribute.chunks.length === 0)
    return x`""`;
  const is_textarea_value = attribute.parent.name.toLowerCase() === "textarea" && attribute.name.toLowerCase() === "value";
  return attribute.chunks.map((chunk) => {
    return chunk.type === "Text" ? (
      /** @type {import('estree').Expression} */
      string_literal(chunk.data.replace(regex_double_quotes, "&quot;"))
    ) : x`@escape(${chunk.node}, ${is_textarea_value ? "false" : "true"})`;
  }).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
}
function get_attribute_expression(attribute) {
  if (attribute.chunks.length === 1 && attribute.chunks[0].type === "Expression") {
    return (
      /** @type {import('estree').Expression} */
      /** @type {import('../../../nodes/shared/Expression.js').default} */
      attribute.chunks[0].node
    );
  }
  return get_attribute_value(attribute);
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/utils/remove_whitespace_children.js
function remove_whitespace_children(children, next) {
  const nodes = [];
  let last_child;
  let i = children.length;
  while (i--) {
    const child = children[i];
    if (child.type === "Text") {
      if (child.should_skip()) {
        continue;
      }
      let { data } = child;
      if (nodes.length === 0) {
        const should_trim = next ? next.type === "Text" && regex_starts_with_whitespace.test(next.data) && trimmable_at2(child, next) : !child.has_ancestor("EachBlock");
        if (should_trim && !child.keep_space()) {
          data = trim_end(data);
          if (!data)
            continue;
        }
      }
      if (last_child && last_child.type === "Text") {
        last_child.data = data + last_child.data;
        continue;
      }
      child.data = data;
      nodes.unshift(child);
      link(last_child, last_child = child);
    } else {
      nodes.unshift(child);
      link(last_child, last_child = child);
    }
  }
  const first = nodes[0];
  if (first && first.type === "Text" && !first.keep_space()) {
    first.data = trim_start(first.data);
    if (!first.data) {
      first.var = null;
      nodes.shift();
      if (nodes[0]) {
        nodes[0].prev = null;
      }
    }
  }
  return nodes;
}
function trimmable_at2(child, next_sibling) {
  return next_sibling.find_nearest(/EachBlock/) === child.find_nearest(/EachBlock/) || next_sibling.prev.type === "EachBlock";
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/Element.js
function Element_default(node, renderer, options) {
  const children = remove_whitespace_children(node.children, node.next);
  let node_contents;
  const contenteditable = is_contenteditable(node);
  if (node.is_dynamic_element) {
    renderer.push();
  }
  renderer.add_string("<");
  add_tag_name();
  const class_expression_list = node.classes.map((class_directive) => {
    const { expression, name: name8 } = class_directive;
    const snippet = expression ? expression.node : x`#ctx.${name8}`;
    return x`${snippet} ? "${name8}" : ""`;
  });
  if (node.needs_manual_style_scoping) {
    class_expression_list.push(x`"${node.component.stylesheet.id}"`);
  }
  const class_expression = class_expression_list.length > 0 && class_expression_list.reduce((lhs, rhs) => x`${lhs} + ' ' + ${rhs}`);
  const style_expression_list = node.styles.map((style_directive) => {
    let {
      name: name8,
      important,
      expression: { node: expression }
    } = style_directive;
    if (important) {
      expression = x`${expression} + ' !important'`;
    }
    return p`"${name8}": ${expression}`;
  });
  const style_expression = style_expression_list.length > 0 && x`{ ${style_expression_list} }`;
  if (node.attributes.some((attr) => attr.is_spread)) {
    const args = [];
    node.attributes.forEach((attribute) => {
      if (attribute.is_spread) {
        args.push(x`@escape_object(${attribute.expression.node})`);
      } else {
        const attr_name = node.namespace === namespaces.foreign ? attribute.name : fix_attribute_casing(attribute.name);
        const name8 = attribute.name.toLowerCase();
        if (name8 === "value" && node.name.toLowerCase() === "textarea") {
          node_contents = get_attribute_value(attribute);
        } else if (attribute.is_true) {
          args.push(x`{ ${attr_name}: true }`);
        } else if (boolean_attributes.has(name8) && attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
          args.push(
            x`{ ${attr_name}: ${/** @type {import('../../nodes/shared/Expression.js').default} */
            attribute.chunks[0].node} || null }`
          );
        } else if (attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
          const snippet = (
            /** @type {import('../../nodes/shared/Expression.js').default} */
            attribute.chunks[0].node
          );
          args.push(x`{ ${attr_name}: @escape_attribute_value(${snippet}) }`);
        } else {
          args.push(x`{ ${attr_name}: ${get_attribute_value(attribute)} }`);
        }
      }
    });
    renderer.add_expression(
      x`@spread([${args}], { classes: ${class_expression}, styles: ${style_expression} })`
    );
  } else {
    let add_class_attribute = !!class_expression;
    let add_style_attribute = !!style_expression;
    node.attributes.forEach((attribute) => {
      const name8 = attribute.name.toLowerCase();
      const attr_name = node.namespace === namespaces.foreign ? attribute.name : fix_attribute_casing(attribute.name);
      if (name8 === "value" && node.name.toLowerCase() === "textarea") {
        node_contents = get_attribute_value(attribute);
      } else if (attribute.is_true) {
        renderer.add_string(` ${attr_name}`);
      } else if (boolean_attributes.has(name8) && attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
        renderer.add_string(" ");
        renderer.add_expression(
          x`${/** @type {import('../../nodes/shared/Expression.js').default} */
          attribute.chunks[0].node} ? "${attr_name}" : ""`
        );
      } else if (name8 === "class" && class_expression) {
        add_class_attribute = false;
        renderer.add_string(` ${attr_name}="`);
        renderer.add_expression(
          x`[${get_class_attribute_value(attribute)}, ${class_expression}].join(' ').trim()`
        );
        renderer.add_string('"');
      } else if (name8 === "style" && style_expression) {
        add_style_attribute = false;
        renderer.add_expression(
          x`@add_styles(@merge_ssr_styles(${get_attribute_value(attribute)}, ${style_expression}))`
        );
      } else if (attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
        const snippet = (
          /** @type {import('../../nodes/shared/Expression.js').default} */
          attribute.chunks[0].node
        );
        renderer.add_expression(
          x`@add_attribute("${attr_name}", ${snippet}, ${boolean_attributes.has(name8) ? 1 : 0})`
        );
      } else {
        renderer.add_string(` ${attr_name}="`);
        renderer.add_expression(
          (name8 === "class" ? get_class_attribute_value : get_attribute_value)(attribute)
        );
        renderer.add_string('"');
      }
    });
    if (add_class_attribute) {
      renderer.add_expression(x`@add_classes((${class_expression}).trim())`);
    }
    if (add_style_attribute) {
      renderer.add_expression(x`@add_styles(${style_expression})`);
    }
  }
  node.bindings.forEach((binding) => {
    const { name: name8, expression } = binding;
    if (binding.is_readonly) {
      return;
    }
    if (name8 === "group") {
      const value_attribute = node.attributes.find(({ name: name9 }) => name9 === "value");
      if (value_attribute) {
        const value = get_attribute_expression(value_attribute);
        const type = node.get_static_attribute_value("type");
        const bound = expression.node;
        const condition = type === "checkbox" ? x`~${bound}.indexOf(${value})` : x`${value} === ${bound}`;
        renderer.add_expression(x`${condition} ? @add_attribute("checked", true, 1) : ""`);
      }
    } else if (contenteditable && is_name_contenteditable(name8)) {
      node_contents = expression.node;
    } else if (binding.name === "value" && node.name === "textarea") {
      const snippet = expression.node;
      node_contents = x`@escape(${snippet} || "")`;
    } else if (binding.name === "value" && node.name === "select") {
    } else {
      const snippet = expression.node;
      renderer.add_expression(
        x`@add_attribute("${name8}", ${snippet}, ${boolean_attributes.has(name8) ? 1 : 0})`
      );
    }
  });
  if (options.hydratable) {
    if (node.can_optimise_hydration && !options.has_added_svelte_hash) {
      renderer.add_string(` data-svelte-h="${node.hash()}"`);
      options = { ...options, has_added_svelte_hash: true };
    }
  }
  renderer.add_string(">");
  if (node_contents !== void 0) {
    if (contenteditable) {
      renderer.push();
      renderer.render(children, options);
      const result = renderer.pop();
      renderer.add_expression(
        x`($$value => $$value === void 0 ? ${result} : $$value)(${node_contents})`
      );
    } else {
      if (node.name === "textarea") {
        const value_attribute = node.attributes.find(({ name: name8 }) => name8 === "value");
        if (value_attribute) {
          const first = value_attribute.chunks[0];
          if (first && first.type === "Text" && regex_starts_with_newline.test(first.data)) {
            renderer.add_string("\n");
          }
        }
      }
      renderer.add_expression(node_contents);
    }
    add_close_tag();
  } else {
    if (node.name === "pre") {
      const first = children[0];
      if (first && first.type === "Text" && regex_starts_with_newline.test(first.data)) {
        renderer.add_string("\n");
      }
    }
    if (node.is_dynamic_element)
      renderer.push();
    renderer.render(children, options);
    if (node.is_dynamic_element) {
      const children2 = renderer.pop();
      renderer.add_expression(x`@is_void(#tag) ? '' : ${children2}`);
    }
    add_close_tag();
  }
  if (node.is_dynamic_element) {
    let content = renderer.pop();
    if (options.dev && node.children.length > 0)
      content = x`(() => { @validate_void_dynamic_element(#tag); return ${content}; })()`;
    renderer.add_expression(x`((#tag) => {
			${options.dev && x`@validate_dynamic_element(#tag)`}
			return #tag ? ${content} : '';
		})(${node.tag_expr.node})`);
  }
  function add_close_tag() {
    if (node.tag_expr.node.type === "Literal") {
      if (!is_void(
        /** @type {string} */
        node.tag_expr.node.value
      )) {
        renderer.add_string("</");
        add_tag_name();
        renderer.add_string(">");
      }
      return;
    }
    renderer.add_expression(x`@is_void(#tag) ? '' : \`</\${#tag}>\``);
  }
  function add_tag_name() {
    if (node.tag_expr.node.type === "Literal") {
      renderer.add_string(
        /** @type {string} */
        node.tag_expr.node.value
      );
    } else {
      renderer.add_expression(
        /** @type {import('estree').Expression} */
        node.tag_expr.node
      );
    }
  }
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/Head.js
function Head_default(node, renderer, options) {
  const head_options = {
    ...options,
    head_id: node.id
  };
  renderer.push();
  renderer.render(node.children, head_options);
  const result = renderer.pop();
  let expression = result;
  if (options.hydratable) {
    const start_comment = `HEAD_${node.id}_START`;
    const end_comment = `HEAD_${node.id}_END`;
    expression = x`'<!-- ${start_comment} -->' + ${expression} + '<!-- ${end_comment} -->'`;
  }
  renderer.add_expression(x`$$result.head += ${expression}, ""`);
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/HtmlTag.js
function HtmlTag_default(node, renderer, options) {
  if (options.hydratable)
    renderer.add_string("<!-- HTML_TAG_START -->");
  renderer.add_expression(
    /** @type {import('estree').Expression} */
    node.expression.node
  );
  if (options.hydratable)
    renderer.add_string("<!-- HTML_TAG_END -->");
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/IfBlock.js
function IfBlock_default(node, renderer, options) {
  const condition = node.expression.node;
  renderer.push();
  renderer.render(node.children, options);
  let consequent = renderer.pop();
  if (node.const_tags.length > 0)
    consequent = x`(() => { ${get_const_tags2(node.const_tags)}; return ${consequent} })()`;
  renderer.push();
  if (node.else)
    renderer.render(node.else.children, options);
  let alternate = renderer.pop();
  if (node.else && node.else.const_tags.length > 0)
    alternate = x`(() => { ${get_const_tags2(node.else.const_tags)}; return ${alternate} })()`;
  renderer.add_expression(x`${condition} ? ${consequent} : ${alternate}`);
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/InlineComponent.js
function get_prop_value(attribute) {
  if (attribute.is_true)
    return x`true`;
  if (attribute.chunks.length === 0)
    return x`''`;
  return attribute.chunks.map((chunk) => {
    if (chunk.type === "Text")
      return string_literal(chunk.data);
    return chunk.node;
  }).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
}
function InlineComponent_default(node, renderer, options) {
  const binding_props = [];
  const binding_fns = [];
  node.bindings.forEach((binding) => {
    renderer.has_bindings = true;
    const snippet = binding.expression.node;
    binding_props.push(p`${binding.name}: ${snippet}`);
    binding_fns.push(p`${binding.name}: $$value => { ${snippet} = $$value; $$settled = false }`);
  });
  const uses_spread = node.attributes.find((attr) => attr.is_spread);
  let props;
  if (uses_spread) {
    props = x`@_Object.assign({}, ${node.attributes.map((attribute) => {
      if (attribute.is_spread) {
        return attribute.expression.node;
      } else {
        return x`{ ${attribute.name}: ${get_prop_value(attribute)} }`;
      }
    }).concat(binding_props.map((p2) => x`{ ${p2} }`))})`;
  } else {
    props = x`{
			${node.attributes.map((attribute) => p`${attribute.name}: ${get_prop_value(attribute)}`)},
			${binding_props}
		}`;
  }
  const bindings = x`{
		${binding_fns}
	}`;
  const expression = node.name === "svelte:self" ? renderer.name : node.name === "svelte:component" ? x`(${node.expression.node}) || @missing_component` : node.name.split(".").reduce(
    /** @type {any} */
    (lhs, rhs) => x`${lhs}.${rhs}`
  );
  const slot_fns = [];
  const children = node.children;
  if (children.length) {
    const slot_scopes = /* @__PURE__ */ new Map();
    renderer.render(
      children,
      Object.assign({}, options, {
        slot_scopes
      })
    );
    slot_scopes.forEach(({ input, output, statements }, name8) => {
      slot_fns.push(p`${name8}: (${input}) => { ${statements}; return ${output}; }`);
    });
  }
  const slots = x`{
		${slot_fns}
	}`;
  if (node.css_custom_properties.length > 0) {
    if (node.namespace === namespaces.svg) {
      renderer.add_string('<g style="');
    } else {
      renderer.add_string('<div style="display: contents; ');
    }
    node.css_custom_properties.forEach((attr, index) => {
      renderer.add_string(`${attr.name}:`);
      renderer.add_expression(get_attribute_value(attr));
      renderer.add_string(";");
      if (index < node.css_custom_properties.length - 1)
        renderer.add_string(" ");
    });
    renderer.add_string('">');
  }
  renderer.add_expression(
    x`@validate_component(${expression}, "${node.name}").$$render($$result, ${props}, ${bindings}, ${slots})`
  );
  if (node.css_custom_properties.length > 0) {
    if (node.namespace === namespaces.svg) {
      renderer.add_string("</g>");
    } else {
      renderer.add_string("</div>");
    }
  }
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/KeyBlock.js
function KeyBlock_default(node, renderer, options) {
  renderer.render(node.children, options);
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/shared/get_slot_scope.js
function get_slot_scope(lets) {
  if (lets.length === 0)
    return null;
  return {
    type: "ObjectPattern",
    properties: lets.map((l) => {
      return {
        type: "Property",
        kind: "init",
        method: false,
        shorthand: false,
        computed: false,
        key: l.name,
        value: l.value || l.name
      };
    })
  };
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/Slot.js
function Slot_default(node, renderer, options) {
  const slot_data = get_slot_data(node.values);
  const slot = node.get_static_attribute_value("slot");
  const nearest_inline_component = node.find_nearest(/InlineComponent/);
  if (slot && nearest_inline_component) {
    renderer.push();
  }
  renderer.push();
  renderer.render(node.children, options);
  const result = renderer.pop();
  renderer.add_expression(x`
		#slots.${node.slot_name}
			? #slots.${node.slot_name}(${slot_data})
			: ${result}
	`);
  if (slot && nearest_inline_component) {
    options.slot_scopes.set(slot, {
      input: get_slot_scope(node.lets),
      output: renderer.pop()
    });
  }
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/SlotTemplate.js
function SlotTemplate_default(node, renderer, options) {
  const parent_inline_component = (
    /** @type {import('../../nodes/InlineComponent.js').default} */
    node.parent
  );
  const children = remove_whitespace_children(
    node instanceof SlotTemplate ? node.children : [node],
    node.next
  );
  renderer.push();
  renderer.render(children, options);
  const slot_fragment_content = renderer.pop();
  if (!is_empty_template_literal(slot_fragment_content)) {
    if (options.slot_scopes.has(node.slot_template_name)) {
      if (node.slot_template_name === "default") {
        throw new Error('Found elements without slot attribute when using slot="default"');
      }
      throw new Error(
        `Duplicate slot name "${node.slot_template_name}" in <${parent_inline_component.name}>`
      );
    }
    options.slot_scopes.set(node.slot_template_name, {
      input: get_slot_scope(node.lets),
      output: slot_fragment_content,
      statements: get_const_tags2(node.const_tags)
    });
  }
}
function is_empty_template_literal(template_literal) {
  return template_literal.expressions.length === 0 && template_literal.quasis.length === 1 && template_literal.quasis[0].value.raw === "";
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/Tag.js
function Tag_default(node, renderer, _options) {
  const snippet = node.expression.node;
  renderer.add_expression(
    node.parent && node.parent.type === "Element" && node.parent.name === "style" ? snippet : x`@escape(${snippet})`
  );
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/Text.js
function Text_default(node, renderer, _options) {
  let text2 = node.data;
  if (node.use_space()) {
    text2 = " ";
  } else if (
    // prettier formats one of the type casts incorrectly, moving it outside the parens, therefore disable
    // prettier-ignore
    !node.parent || node.parent.type !== "Element" || /** @type {import('../../nodes/Element.js').default} */
    node.parent.name !== "script" && /** @type {import('../../nodes/Element.js').default} */
    node.parent.name !== "style"
  ) {
    text2 = escape_html(text2);
  }
  renderer.add_string(text2);
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/Title.js
function Title_default(node, renderer, options) {
  renderer.push();
  renderer.add_string("<title>");
  renderer.render(node.children, options);
  renderer.add_string("</title>");
  const result = renderer.pop();
  renderer.add_expression(x`$$result.title = ${result}, ""`);
}

// node_modules/svelte/src/compiler/compile/utils/collapse_template_literal.js
function collapse_template_literal(literal) {
  if (!literal.quasis.length)
    return;
  const collapsed_quasis = [];
  const collapsed_expressions = [];
  let cur_quasi = literal.quasis[0];
  for (let i = 0; i < literal.quasis.length; i++) {
    const expr = literal.expressions[i];
    const next_quasi = literal.quasis[i + 1];
    if (next_quasi && expr && expr.type === "Literal" && typeof expr.value === "string") {
      cur_quasi.value.raw += escape_template(expr.value) + next_quasi.value.raw;
    } else {
      if (expr) {
        collapsed_expressions.push(expr);
      }
      collapsed_quasis.push(cur_quasi);
      cur_quasi = next_quasi;
    }
  }
  literal.quasis = collapsed_quasis;
  literal.expressions = collapsed_expressions;
}

// node_modules/svelte/src/compiler/compile/render_ssr/Renderer.js
function noop() {
}
var handlers = {
  AwaitBlock: AwaitBlock_default,
  Body: noop,
  Comment: Comment_default,
  DebugTag: DebugTag_default,
  Document: noop,
  EachBlock: EachBlock_default,
  Element: Element_default,
  Head: Head_default,
  IfBlock: IfBlock_default,
  InlineComponent: InlineComponent_default,
  KeyBlock: KeyBlock_default,
  MustacheTag: Tag_default,
  Options: noop,
  RawMustacheTag: HtmlTag_default,
  Slot: Slot_default,
  SlotTemplate: SlotTemplate_default,
  Text: Text_default,
  Title: Title_default,
  Window: noop
};
var Renderer2 = class {
  constructor({ name: name8 }) {
    __publicField(this, "has_bindings", false);
    /** @type {import('estree').Identifier} */
    __publicField(this, "name");
    /** @type {Array<{ current: { value: string }; literal: import('estree').TemplateLiteral }>} */
    __publicField(this, "stack", []);
    /** @type {{ value: string }} */
    __publicField(this, "current");
    // TODO can it just be `current: string`?
    /** @type {import('estree').TemplateLiteral} */
    __publicField(this, "literal");
    /** @type {import('../../interfaces.js').AppendTarget[]} */
    __publicField(this, "targets", []);
    this.name = name8;
    this.push();
  }
  /** @param {string} str */
  add_string(str) {
    this.current.value += escape_template(str);
  }
  /** @param {import('estree').Expression} node */
  add_expression(node) {
    this.literal.quasis.push({
      type: "TemplateElement",
      value: { raw: this.current.value, cooked: null },
      tail: false
    });
    this.literal.expressions.push(node);
    this.current.value = "";
  }
  push() {
    const current = this.current = { value: "" };
    const literal = this.literal = {
      type: "TemplateLiteral",
      expressions: [],
      quasis: []
    };
    this.stack.push({ current, literal });
  }
  pop() {
    this.literal.quasis.push({
      type: "TemplateElement",
      value: { raw: this.current.value, cooked: null },
      tail: true
    });
    const popped = this.stack.pop();
    const last = this.stack[this.stack.length - 1];
    if (last) {
      this.literal = last.literal;
      this.current = last.current;
    }
    collapse_template_literal(popped.literal);
    return popped.literal;
  }
  /**
   * @param {import('../nodes/interfaces.js').INode[]} nodes
   * @param {import('./private.js').RenderOptions} options
   */
  render(nodes, options) {
    nodes.forEach((node) => {
      const handler = handlers[node.type];
      if (!handler) {
        throw new Error(`No handler for '${node.type}' nodes`);
      }
      handler(node, this, options);
    });
  }
};

// node_modules/svelte/src/compiler/compile/render_ssr/index.js
function ssr(component, options) {
  const renderer = new Renderer2({
    name: component.name
  });
  const { name: name8 } = component;
  renderer.render(
    trim(component.fragment.children),
    Object.assign(
      {
        locate: component.locate
      },
      options
    )
  );
  const literal = renderer.pop();
  const css = options.customElement ? { code: null, map: null } : component.stylesheet.render(options.filename);
  const uses_rest = component.var_lookup.has("$$restProps");
  const props = component.vars.filter((variable) => !variable.module && variable.export_name);
  const rest = uses_rest ? b`let $$restProps = @compute_rest_props($$props, [${props.map((prop) => `"${prop.export_name}"`).join(",")}]);` : null;
  const uses_slots = component.var_lookup.has("$$slots");
  const slots = uses_slots ? b`let $$slots = @compute_slots(#slots);` : null;
  const reactive_stores = component.vars.filter(
    (variable) => variable.name[0] === "$" && variable.name[1] !== "$"
  );
  const reactive_store_subscriptions = reactive_stores.filter((store) => {
    const variable = component.var_lookup.get(store.name.slice(1));
    return !variable || variable.hoistable;
  }).map(({ name: name9 }) => {
    const store_name = name9.slice(1);
    return b`
				${component.compile_options.dev && b`@validate_store(${store_name}, '${store_name}');`}
				${`$$unsubscribe_${store_name}`} = @subscribe(${store_name}, #value => ${name9} = #value)
			`;
  });
  const reactive_store_unsubscriptions = reactive_stores.map(
    ({ name: name9 }) => b`${`$$unsubscribe_${name9.slice(1)}`}()`
  );
  const reactive_store_declarations = reactive_stores.map(({ name: name9 }) => {
    const store_name = name9.slice(1);
    const store = component.var_lookup.get(store_name);
    if (store && store.reassigned) {
      const unsubscribe = `$$unsubscribe_${store_name}`;
      const subscribe = `$$subscribe_${store_name}`;
      return b`let ${name9}, ${unsubscribe} = @noop, ${subscribe} = () => (${unsubscribe}(), ${unsubscribe} = @subscribe(${store_name}, $$value => ${name9} = $$value), ${store_name})`;
    }
    return b`let ${name9}, ${`$$unsubscribe_${store_name}`};`;
  });
  if (component.ast.instance) {
    let scope = component.instance_scope;
    const map = component.instance_scope_map;
    walk(component.ast.instance.content, {
      enter(node) {
        if (map.has(node)) {
          scope = map.get(node);
        }
      },
      leave(node) {
        if (map.has(node)) {
          scope = scope.parent;
        }
        if (node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
          const assignee = node.type === "AssignmentExpression" ? node.left : node.argument;
          const names = new Set(extract_names(
            /** @type {import('estree').Node} */
            assignee
          ));
          const to_invalidate = /* @__PURE__ */ new Set();
          for (const name9 of names) {
            const variable = component.var_lookup.get(name9);
            if (variable && !variable.hoistable && !variable.global && !variable.module && (variable.subscribable || variable.name[0] === "$")) {
              to_invalidate.add(variable.name);
            }
          }
          if (to_invalidate.size) {
            this.replace(
              invalidate(
                /** @type {any} */
                { component },
                scope,
                node,
                to_invalidate,
                true
              )
            );
          }
        }
      }
    });
  }
  component.rewrite_props(({ name: name9, reassigned }) => {
    const value = `$${name9}`;
    let insert = reassigned ? b`${`$$subscribe_${name9}`}()` : b`${`$$unsubscribe_${name9}`} = @subscribe(${name9}, #value => $${value} = #value)`;
    if (component.compile_options.dev) {
      insert = b`@validate_store(${name9}, '${name9}'); ${insert}`;
    }
    return insert;
  });
  const instance_javascript = component.extract_javascript(component.ast.instance);
  const parent_bindings = instance_javascript ? component.vars.filter((variable) => !variable.module && variable.export_name).map((prop) => {
    return b`if ($$props.${prop.export_name} === void 0 && $$bindings.${prop.export_name} && ${prop.name} !== void 0) $$bindings.${prop.export_name}(${prop.name});`;
  }) : [];
  const injected = Array.from(component.injected_reactive_declaration_vars).filter((name9) => {
    const variable = component.var_lookup.get(name9);
    return variable.injected;
  });
  const reactive_declarations = component.reactive_declarations.map((d) => {
    const body = (
      /** @type {import('estree').LabeledStatement} */
      d.node.body
    );
    let statement = b`${body}`;
    if (!d.declaration) {
      statement = b`$: { ${statement} }`;
    }
    return statement;
  });
  const main = renderer.has_bindings ? b`
			let $$settled;
			let $$rendered;
			let #previous_head = $$result.head;

			do {
				$$settled = true;
				// $$result.head is mutated by the literal expression
				// need to reset it if we're looping back to prevent duplication
				$$result.head = #previous_head;

				${reactive_declarations}

				$$rendered = ${literal};
			} while (!$$settled);

			${reactive_store_unsubscriptions}

			return $$rendered;
		` : b`
			${reactive_declarations}

			${reactive_store_unsubscriptions}

			return ${literal};`;
  const blocks = [
    ...injected.map((name9) => b`let ${name9};`),
    rest,
    slots,
    ...reactive_store_declarations,
    ...reactive_store_subscriptions,
    instance_javascript,
    ...parent_bindings,
    css.code && b`$$result.css.add(#css);`,
    main
  ].filter(Boolean);
  const css_sourcemap_enabled = check_enable_sourcemap(options.enableSourcemap, "css");
  const js = b`
		${css.code ? b`
		const #css = {
			code: "${css.code}",
			map: ${css_sourcemap_enabled && css.map ? string_literal(css.map.toString()) : "null"}
		};` : null}

		${component.extract_javascript(component.ast.module)}

		${component.fully_hoisted}

		const ${name8} = @create_ssr_component(($$result, $$props, $$bindings, #slots) => {
			${blocks}
		});
	`;
  return { js, css };
}
function trim(nodes) {
  let start = 0;
  for (; start < nodes.length; start += 1) {
    const node = (
      /** @type {import('../nodes/Text.js').default} */
      nodes[start]
    );
    if (node.type !== "Text")
      break;
    node.data = node.data.replace(/^\s+/, "");
    if (node.data)
      break;
  }
  let end = nodes.length;
  for (; end > start; end -= 1) {
    const node = (
      /** @type {import('../nodes/Text.js').default} */
      nodes[end - 1]
    );
    if (node.type !== "Text")
      break;
    node.data = node.data.trimRight();
    if (node.data)
      break;
  }
  return nodes.slice(start, end);
}

// node_modules/svelte/src/compiler/compile/Component.js
var import_trace_mapping = __toESM(require_trace_mapping_umd(), 1);

// node_modules/svelte/src/compiler/utils/globals.js
var globals_default = /* @__PURE__ */ new Set([
  "AbortController",
  "AbortSignal",
  "AbstractRange",
  "ActiveXObject",
  "AggregateError",
  "AnalyserNode",
  "Animation",
  "AnimationEffect",
  "AnimationEvent",
  "AnimationPlaybackEvent",
  "AnimationTimeline",
  "Array",
  "ArrayBuffer",
  "Atomics",
  "Attr",
  "Audio",
  "AudioBuffer",
  "AudioBufferSourceNode",
  "AudioContext",
  "AudioDestinationNode",
  "AudioListener",
  "AudioNode",
  "AudioParam",
  "AudioParamMap",
  "AudioProcessingEvent",
  "AudioScheduledSourceNode",
  "AudioWorklet",
  "AudioWorkletNode",
  "AuthenticatorAssertionResponse",
  "AuthenticatorAttestationResponse",
  "AuthenticatorResponse",
  "BarProp",
  "BaseAudioContext",
  "BeforeUnloadEvent",
  "BigInt",
  "BigInt64Array",
  "BigUint64Array",
  "BiquadFilterNode",
  "Blob",
  "BlobEvent",
  "Boolean",
  "BroadcastChannel",
  "ByteLengthQueuingStrategy",
  "CDATASection",
  "CSS",
  "CSSAnimation",
  "CSSConditionRule",
  "CSSCounterStyleRule",
  "CSSFontFaceRule",
  "CSSGroupingRule",
  "CSSImportRule",
  "CSSKeyframeRule",
  "CSSKeyframesRule",
  "CSSMediaRule",
  "CSSNamespaceRule",
  "CSSPageRule",
  "CSSRule",
  "CSSRuleList",
  "CSSStyleDeclaration",
  "CSSStyleRule",
  "CSSStyleSheet",
  "CSSSupportsRule",
  "CSSTransition",
  "Cache",
  "CacheStorage",
  "CanvasCaptureMediaStreamTrack",
  "CanvasGradient",
  "CanvasPattern",
  "CanvasRenderingContext2D",
  "ChannelMergerNode",
  "ChannelSplitterNode",
  "CharacterData",
  "ClientRect",
  "Clipboard",
  "ClipboardEvent",
  "ClipboardItem",
  "CloseEvent",
  "Comment",
  "CompositionEvent",
  "ConstantSourceNode",
  "ConvolverNode",
  "CountQueuingStrategy",
  "Credential",
  "CredentialsContainer",
  "Crypto",
  "CryptoKey",
  "CustomElementRegistry",
  "CustomEvent",
  "DOMException",
  "DOMImplementation",
  "DOMMatrix",
  "DOMMatrixReadOnly",
  "DOMParser",
  "DOMPoint",
  "DOMPointReadOnly",
  "DOMQuad",
  "DOMRect",
  "DOMRectList",
  "DOMRectReadOnly",
  "DOMStringList",
  "DOMStringMap",
  "DOMTokenList",
  "DataTransfer",
  "DataTransferItem",
  "DataTransferItemList",
  "DataView",
  "Date",
  "DelayNode",
  "DeviceMotionEvent",
  "DeviceOrientationEvent",
  "Document",
  "DocumentFragment",
  "DocumentTimeline",
  "DocumentType",
  "DragEvent",
  "DynamicsCompressorNode",
  "Element",
  "ElementInternals",
  "Enumerator",
  "Error",
  "ErrorEvent",
  "EvalError",
  "Event",
  "EventCounts",
  "EventSource",
  "EventTarget",
  "External",
  "File",
  "FileList",
  "FileReader",
  "FileSystem",
  "FileSystemDirectoryEntry",
  "FileSystemDirectoryHandle",
  "FileSystemDirectoryReader",
  "FileSystemEntry",
  "FileSystemFileEntry",
  "FileSystemFileHandle",
  "FileSystemHandle",
  "FinalizationRegistry",
  "Float32Array",
  "Float64Array",
  "FocusEvent",
  "FontFace",
  "FontFaceSet",
  "FontFaceSetLoadEvent",
  "FormData",
  "FormDataEvent",
  "Function",
  "GainNode",
  "Gamepad",
  "GamepadButton",
  "GamepadEvent",
  "GamepadHapticActuator",
  "Geolocation",
  "GeolocationCoordinates",
  "GeolocationPosition",
  "GeolocationPositionError",
  "HTMLAllCollection",
  "HTMLAnchorElement",
  "HTMLAreaElement",
  "HTMLAudioElement",
  "HTMLBRElement",
  "HTMLBaseElement",
  "HTMLBodyElement",
  "HTMLButtonElement",
  "HTMLCanvasElement",
  "HTMLCollection",
  "HTMLDListElement",
  "HTMLDataElement",
  "HTMLDataListElement",
  "HTMLDetailsElement",
  "HTMLDialogElement",
  "HTMLDirectoryElement",
  "HTMLDivElement",
  "HTMLDocument",
  "HTMLElement",
  "HTMLEmbedElement",
  "HTMLFieldSetElement",
  "HTMLFontElement",
  "HTMLFormControlsCollection",
  "HTMLFormElement",
  "HTMLFrameElement",
  "HTMLFrameSetElement",
  "HTMLHRElement",
  "HTMLHeadElement",
  "HTMLHeadingElement",
  "HTMLHtmlElement",
  "HTMLIFrameElement",
  "HTMLImageElement",
  "HTMLInputElement",
  "HTMLLIElement",
  "HTMLLabelElement",
  "HTMLLegendElement",
  "HTMLLinkElement",
  "HTMLMapElement",
  "HTMLMarqueeElement",
  "HTMLMediaElement",
  "HTMLMenuElement",
  "HTMLMetaElement",
  "HTMLMeterElement",
  "HTMLModElement",
  "HTMLOListElement",
  "HTMLObjectElement",
  "HTMLOptGroupElement",
  "HTMLOptionElement",
  "HTMLOptionsCollection",
  "HTMLOutputElement",
  "HTMLParagraphElement",
  "HTMLParamElement",
  "HTMLPictureElement",
  "HTMLPreElement",
  "HTMLProgressElement",
  "HTMLQuoteElement",
  "HTMLScriptElement",
  "HTMLSelectElement",
  "HTMLSlotElement",
  "HTMLSourceElement",
  "HTMLSpanElement",
  "HTMLStyleElement",
  "HTMLTableCaptionElement",
  "HTMLTableCellElement",
  "HTMLTableColElement",
  "HTMLTableElement",
  "HTMLTableRowElement",
  "HTMLTableSectionElement",
  "HTMLTemplateElement",
  "HTMLTextAreaElement",
  "HTMLTimeElement",
  "HTMLTitleElement",
  "HTMLTrackElement",
  "HTMLUListElement",
  "HTMLUnknownElement",
  "HTMLVideoElement",
  "HashChangeEvent",
  "Headers",
  "History",
  "IDBCursor",
  "IDBCursorWithValue",
  "IDBDatabase",
  "IDBFactory",
  "IDBIndex",
  "IDBKeyRange",
  "IDBObjectStore",
  "IDBOpenDBRequest",
  "IDBRequest",
  "IDBTransaction",
  "IDBVersionChangeEvent",
  "IIRFilterNode",
  "IdleDeadline",
  "Image",
  "ImageBitmap",
  "ImageBitmapRenderingContext",
  "ImageData",
  "Infinity",
  "InputDeviceInfo",
  "InputEvent",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "InternalError",
  "IntersectionObserver",
  "IntersectionObserverEntry",
  "Intl",
  "JSON",
  "KeyboardEvent",
  "KeyframeEffect",
  "Location",
  "Lock",
  "LockManager",
  "Map",
  "Math",
  "MathMLElement",
  "MediaCapabilities",
  "MediaDeviceInfo",
  "MediaDevices",
  "MediaElementAudioSourceNode",
  "MediaEncryptedEvent",
  "MediaError",
  "MediaKeyMessageEvent",
  "MediaKeySession",
  "MediaKeyStatusMap",
  "MediaKeySystemAccess",
  "MediaKeys",
  "MediaList",
  "MediaMetadata",
  "MediaQueryList",
  "MediaQueryListEvent",
  "MediaRecorder",
  "MediaRecorderErrorEvent",
  "MediaSession",
  "MediaSource",
  "MediaStream",
  "MediaStreamAudioDestinationNode",
  "MediaStreamAudioSourceNode",
  "MediaStreamTrack",
  "MediaStreamTrackEvent",
  "MessageChannel",
  "MessageEvent",
  "MessagePort",
  "MimeType",
  "MimeTypeArray",
  "MouseEvent",
  "MutationEvent",
  "MutationObserver",
  "MutationRecord",
  "NaN",
  "NamedNodeMap",
  "NavigationPreloadManager",
  "Navigator",
  "NetworkInformation",
  "Node",
  "NodeFilter",
  "NodeIterator",
  "NodeList",
  "Notification",
  "Number",
  "Object",
  "OfflineAudioCompletionEvent",
  "OfflineAudioContext",
  "Option",
  "OscillatorNode",
  "OverconstrainedError",
  "PageTransitionEvent",
  "PannerNode",
  "Path2D",
  "PaymentAddress",
  "PaymentMethodChangeEvent",
  "PaymentRequest",
  "PaymentRequestUpdateEvent",
  "PaymentResponse",
  "Performance",
  "PerformanceEntry",
  "PerformanceEventTiming",
  "PerformanceMark",
  "PerformanceMeasure",
  "PerformanceNavigation",
  "PerformanceNavigationTiming",
  "PerformanceObserver",
  "PerformanceObserverEntryList",
  "PerformancePaintTiming",
  "PerformanceResourceTiming",
  "PerformanceServerTiming",
  "PerformanceTiming",
  "PeriodicWave",
  "PermissionStatus",
  "Permissions",
  "PictureInPictureWindow",
  "Plugin",
  "PluginArray",
  "PointerEvent",
  "PopStateEvent",
  "ProcessingInstruction",
  "ProgressEvent",
  "Promise",
  "PromiseRejectionEvent",
  "Proxy",
  "PublicKeyCredential",
  "PushManager",
  "PushSubscription",
  "PushSubscriptionOptions",
  "RTCCertificate",
  "RTCDTMFSender",
  "RTCDTMFToneChangeEvent",
  "RTCDataChannel",
  "RTCDataChannelEvent",
  "RTCDtlsTransport",
  "RTCEncodedAudioFrame",
  "RTCEncodedVideoFrame",
  "RTCError",
  "RTCErrorEvent",
  "RTCIceCandidate",
  "RTCIceTransport",
  "RTCPeerConnection",
  "RTCPeerConnectionIceErrorEvent",
  "RTCPeerConnectionIceEvent",
  "RTCRtpReceiver",
  "RTCRtpSender",
  "RTCRtpTransceiver",
  "RTCSctpTransport",
  "RTCSessionDescription",
  "RTCStatsReport",
  "RTCTrackEvent",
  "RadioNodeList",
  "Range",
  "RangeError",
  "ReadableByteStreamController",
  "ReadableStream",
  "ReadableStreamBYOBReader",
  "ReadableStreamBYOBRequest",
  "ReadableStreamDefaultController",
  "ReadableStreamDefaultReader",
  "ReferenceError",
  "Reflect",
  "RegExp",
  "RemotePlayback",
  "Request",
  "ResizeObserver",
  "ResizeObserverEntry",
  "ResizeObserverSize",
  "Response",
  "SVGAElement",
  "SVGAngle",
  "SVGAnimateElement",
  "SVGAnimateMotionElement",
  "SVGAnimateTransformElement",
  "SVGAnimatedAngle",
  "SVGAnimatedBoolean",
  "SVGAnimatedEnumeration",
  "SVGAnimatedInteger",
  "SVGAnimatedLength",
  "SVGAnimatedLengthList",
  "SVGAnimatedNumber",
  "SVGAnimatedNumberList",
  "SVGAnimatedPreserveAspectRatio",
  "SVGAnimatedRect",
  "SVGAnimatedString",
  "SVGAnimatedTransformList",
  "SVGAnimationElement",
  "SVGCircleElement",
  "SVGClipPathElement",
  "SVGComponentTransferFunctionElement",
  "SVGCursorElement",
  "SVGDefsElement",
  "SVGDescElement",
  "SVGElement",
  "SVGEllipseElement",
  "SVGFEBlendElement",
  "SVGFEColorMatrixElement",
  "SVGFEComponentTransferElement",
  "SVGFECompositeElement",
  "SVGFEConvolveMatrixElement",
  "SVGFEDiffuseLightingElement",
  "SVGFEDisplacementMapElement",
  "SVGFEDistantLightElement",
  "SVGFEDropShadowElement",
  "SVGFEFloodElement",
  "SVGFEFuncAElement",
  "SVGFEFuncBElement",
  "SVGFEFuncGElement",
  "SVGFEFuncRElement",
  "SVGFEGaussianBlurElement",
  "SVGFEImageElement",
  "SVGFEMergeElement",
  "SVGFEMergeNodeElement",
  "SVGFEMorphologyElement",
  "SVGFEOffsetElement",
  "SVGFEPointLightElement",
  "SVGFESpecularLightingElement",
  "SVGFESpotLightElement",
  "SVGFETileElement",
  "SVGFETurbulenceElement",
  "SVGFilterElement",
  "SVGForeignObjectElement",
  "SVGGElement",
  "SVGGeometryElement",
  "SVGGradientElement",
  "SVGGraphicsElement",
  "SVGImageElement",
  "SVGLength",
  "SVGLengthList",
  "SVGLineElement",
  "SVGLinearGradientElement",
  "SVGMPathElement",
  "SVGMarkerElement",
  "SVGMaskElement",
  "SVGMatrix",
  "SVGMetadataElement",
  "SVGNumber",
  "SVGNumberList",
  "SVGPathElement",
  "SVGPatternElement",
  "SVGPoint",
  "SVGPointList",
  "SVGPolygonElement",
  "SVGPolylineElement",
  "SVGPreserveAspectRatio",
  "SVGRadialGradientElement",
  "SVGRect",
  "SVGRectElement",
  "SVGSVGElement",
  "SVGScriptElement",
  "SVGSetElement",
  "SVGStopElement",
  "SVGStringList",
  "SVGStyleElement",
  "SVGSwitchElement",
  "SVGSymbolElement",
  "SVGTSpanElement",
  "SVGTextContentElement",
  "SVGTextElement",
  "SVGTextPathElement",
  "SVGTextPositioningElement",
  "SVGTitleElement",
  "SVGTransform",
  "SVGTransformList",
  "SVGUnitTypes",
  "SVGUseElement",
  "SVGViewElement",
  "SafeArray",
  "Screen",
  "ScreenOrientation",
  "ScriptProcessorNode",
  "SecurityPolicyViolationEvent",
  "Selection",
  "ServiceWorker",
  "ServiceWorkerContainer",
  "ServiceWorkerRegistration",
  "Set",
  "ShadowRoot",
  "SharedArrayBuffer",
  "SharedWorker",
  "SourceBuffer",
  "SourceBufferList",
  "SpeechRecognitionAlternative",
  "SpeechRecognitionErrorEvent",
  "SpeechRecognitionResult",
  "SpeechRecognitionResultList",
  "SpeechSynthesis",
  "SpeechSynthesisErrorEvent",
  "SpeechSynthesisEvent",
  "SpeechSynthesisUtterance",
  "SpeechSynthesisVoice",
  "StaticRange",
  "StereoPannerNode",
  "Storage",
  "StorageEvent",
  "StorageManager",
  "String",
  "StyleMedia",
  "StyleSheet",
  "StyleSheetList",
  "SubmitEvent",
  "SubtleCrypto",
  "Symbol",
  "SyntaxError",
  "Text",
  "TextDecoder",
  "TextDecoderStream",
  "TextEncoder",
  "TextEncoderStream",
  "TextMetrics",
  "TextTrack",
  "TextTrackCue",
  "TextTrackCueList",
  "TextTrackList",
  "TimeRanges",
  "Touch",
  "TouchEvent",
  "TouchList",
  "TrackEvent",
  "TransformStream",
  "TransformStreamDefaultController",
  "TransitionEvent",
  "TreeWalker",
  "TypeError",
  "UIEvent",
  "URIError",
  "URL",
  "URLSearchParams",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "VBArray",
  "VTTCue",
  "VTTRegion",
  "ValidityState",
  "VarDate",
  "VideoColorSpace",
  "VideoPlaybackQuality",
  "VisualViewport",
  "WSH",
  "WScript",
  "WaveShaperNode",
  "WeakMap",
  "WeakRef",
  "WeakSet",
  "WebAssembly",
  "WebGL2RenderingContext",
  "WebGLActiveInfo",
  "WebGLBuffer",
  "WebGLContextEvent",
  "WebGLFramebuffer",
  "WebGLProgram",
  "WebGLQuery",
  "WebGLRenderbuffer",
  "WebGLRenderingContext",
  "WebGLSampler",
  "WebGLShader",
  "WebGLShaderPrecisionFormat",
  "WebGLSync",
  "WebGLTexture",
  "WebGLTransformFeedback",
  "WebGLUniformLocation",
  "WebGLVertexArrayObject",
  "WebKitCSSMatrix",
  "WebSocket",
  "WheelEvent",
  "Window",
  "Worker",
  "Worklet",
  "WritableStream",
  "WritableStreamDefaultController",
  "WritableStreamDefaultWriter",
  "XMLDocument",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload",
  "XMLSerializer",
  "XPathEvaluator",
  "XPathExpression",
  "XPathResult",
  "XSLTProcessor",
  "addEventListener",
  "alert",
  "atob",
  "blur",
  "btoa",
  "caches",
  "cancelAnimationFrame",
  "cancelIdleCallback",
  "captureEvents",
  "clearInterval",
  "clearTimeout",
  "clientInformation",
  "close",
  "closed",
  "confirm",
  "console",
  "createImageBitmap",
  "crossOriginIsolated",
  "crypto",
  "customElements",
  "decodeURI",
  "decodeURIComponent",
  "devicePixelRatio",
  "dispatchEvent",
  "document",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "eval",
  "event",
  "external",
  "fetch",
  "focus",
  "frameElement",
  "frames",
  "getComputedStyle",
  "getSelection",
  "global",
  "globalThis",
  "history",
  "importScripts",
  "indexedDB",
  "innerHeight",
  "innerWidth",
  "isFinite",
  "isNaN",
  "isSecureContext",
  "length",
  "localStorage",
  "location",
  "locationbar",
  "matchMedia",
  "menubar",
  "moveBy",
  "moveTo",
  "name",
  "navigator",
  "onabort",
  "onafterprint",
  "onanimationcancel",
  "onanimationend",
  "onanimationiteration",
  "onanimationstart",
  "onauxclick",
  "onbeforeprint",
  "onbeforeunload",
  "onblur",
  "oncanplay",
  "oncanplaythrough",
  "onchange",
  "onclick",
  "onclose",
  "oncontextmenu",
  "oncuechange",
  "ondblclick",
  "ondevicemotion",
  "ondeviceorientation",
  "ondrag",
  "ondragend",
  "ondragenter",
  "ondragleave",
  "ondragover",
  "ondragstart",
  "ondrop",
  "ondurationchange",
  "onemptied",
  "onended",
  "onerror",
  "onfocus",
  "onformdata",
  "ongamepadconnected",
  "ongamepaddisconnected",
  "ongotpointercapture",
  "onhashchange",
  "oninput",
  "oninvalid",
  "onkeydown",
  "onkeypress",
  "onkeyup",
  "onlanguagechange",
  "onload",
  "onloadeddata",
  "onloadedmetadata",
  "onloadstart",
  "onlostpointercapture",
  "onmessage",
  "onmessageerror",
  "onmousedown",
  "onmouseenter",
  "onmouseleave",
  "onmousemove",
  "onmouseout",
  "onmouseover",
  "onmouseup",
  "onoffline",
  "ononline",
  "onorientationchange",
  "onpagehide",
  "onpageshow",
  "onpause",
  "onplay",
  "onplaying",
  "onpointercancel",
  "onpointerdown",
  "onpointerenter",
  "onpointerleave",
  "onpointermove",
  "onpointerout",
  "onpointerover",
  "onpointerup",
  "onpopstate",
  "onprogress",
  "onratechange",
  "onrejectionhandled",
  "onreset",
  "onresize",
  "onscroll",
  "onsecuritypolicyviolation",
  "onseeked",
  "onseeking",
  "onselect",
  "onselectionchange",
  "onselectstart",
  "onslotchange",
  "onstalled",
  "onstorage",
  "onsubmit",
  "onsuspend",
  "ontimeupdate",
  "ontoggle",
  "ontouchcancel",
  "ontouchend",
  "ontouchmove",
  "ontouchstart",
  "ontransitioncancel",
  "ontransitionend",
  "ontransitionrun",
  "ontransitionstart",
  "onunhandledrejection",
  "onunload",
  "onvolumechange",
  "onwaiting",
  "onwebkitanimationend",
  "onwebkitanimationiteration",
  "onwebkitanimationstart",
  "onwebkittransitionend",
  "onwheel",
  "open",
  "opener",
  "orientation",
  "origin",
  "outerHeight",
  "outerWidth",
  "pageXOffset",
  "pageYOffset",
  "parent",
  "parseFloat",
  "parseInt",
  "performance",
  "personalbar",
  "postMessage",
  "print",
  "process",
  "prompt",
  "queueMicrotask",
  "releaseEvents",
  "removeEventListener",
  "reportError",
  "requestAnimationFrame",
  "requestIdleCallback",
  "resizeBy",
  "resizeTo",
  "screen",
  "screenLeft",
  "screenTop",
  "screenX",
  "screenY",
  "scroll",
  "scrollBy",
  "scrollTo",
  "scrollX",
  "scrollY",
  "scrollbars",
  "self",
  "sessionStorage",
  "setInterval",
  "setTimeout",
  "speechSynthesis",
  "status",
  "statusbar",
  "stop",
  "structuredClone",
  "toString",
  "toolbar",
  "top",
  "undefined",
  "unescape",
  "visualViewport",
  "webkitURL",
  "window"
]);

// node_modules/svelte/src/compiler/compile/create_module.js
function create_module(program, name8, banner, svelte_path = "svelte", helpers, globals, imports, module_exports, exports_from) {
  const internal_path = `${svelte_path}/internal`;
  helpers.sort((a, b2) => a.name < b2.name ? -1 : 1);
  globals.sort((a, b2) => a.name < b2.name ? -1 : 1);
  return esm(
    program,
    name8,
    banner,
    svelte_path,
    internal_path,
    helpers,
    globals,
    imports,
    module_exports,
    exports_from
  );
}
function edit_source(source, svelte_path) {
  return source === "svelte" || source.startsWith("svelte/") ? source.replace("svelte", svelte_path) : source;
}
function get_internal_globals(globals, helpers) {
  return globals.length > 0 && {
    type: "VariableDeclaration",
    kind: "const",
    declarations: [
      {
        type: "VariableDeclarator",
        id: {
          type: "ObjectPattern",
          properties: globals.map((g) => ({
            type: "Property",
            method: false,
            shorthand: false,
            computed: false,
            key: { type: "Identifier", name: g.name },
            value: g.alias,
            kind: "init"
          }))
        },
        init: helpers.find(({ name: name8 }) => name8 === "globals").alias
      }
    ]
  };
}
function esm(program, name8, banner, svelte_path, internal_path, helpers, globals, imports, module_exports, exports_from) {
  const import_declaration = {
    type: "ImportDeclaration",
    specifiers: helpers.map((h) => ({
      type: "ImportSpecifier",
      local: h.alias,
      imported: { type: "Identifier", name: h.name }
    })),
    source: { type: "Literal", value: internal_path }
  };
  const internal_globals = get_internal_globals(globals, helpers);
  function rewrite_import(node) {
    const value = edit_source(node.source.value, svelte_path);
    if (node.source.value !== value) {
      node.source.value = value;
      node.source.raw = null;
    }
  }
  imports.forEach(rewrite_import);
  exports_from.forEach(rewrite_import);
  const exports = module_exports.length > 0 && {
    type: "ExportNamedDeclaration",
    specifiers: module_exports.map((x2) => ({
      type: "Specifier",
      local: { type: "Identifier", name: x2.name },
      exported: { type: "Identifier", name: x2.as }
    }))
  };
  program.body = b`
		/* ${banner} */

		${import_declaration}
		${internal_globals}
		${imports}
		${exports_from}

		${program.body}

		export default ${name8};
		${exports}
	`;
}

// node_modules/svelte/src/compiler/compile/css/gather_possible_values.js
var UNKNOWN = {};
function gather_possible_values(node, set) {
  if (node.type === "Literal") {
    set.add(node.value);
  } else if (node.type === "ConditionalExpression") {
    gather_possible_values(node.consequent, set);
    gather_possible_values(node.alternate, set);
  } else {
    set.add(UNKNOWN);
  }
}

// node_modules/svelte/src/compiler/compile/css/Selector.js
var BlockAppliesToNode = (
  /** @type {const} */
  {
    NotPossible: 0,
    Possible: 1,
    UnknownSelectorType: 2
  }
);
var NodeExist = (
  /** @type {const} */
  {
    Probably: 0,
    Definitely: 1
  }
);
var whitelist_attribute_selector = /* @__PURE__ */ new Map([
  ["details", /* @__PURE__ */ new Set(["open"])],
  ["dialog", /* @__PURE__ */ new Set(["open"])]
]);
var regex_is_single_css_selector = /[^\\],(?!([^([]+[^\\]|[^([\\])[)\]])/;
var Selector = class {
  /**
   * @param {import('./private.js').CssNode} node
   * @param {import('./Stylesheet.js').default} stylesheet
   */
  constructor(node, stylesheet) {
    /** @type {import('./private.js').CssNode} */
    __publicField(this, "node");
    /** @type {import('./Stylesheet.js').default} */
    __publicField(this, "stylesheet");
    /** @type {Block[]} */
    __publicField(this, "blocks");
    /** @type {Block[]} */
    __publicField(this, "local_blocks");
    /** @type {boolean} */
    __publicField(this, "used");
    this.node = node;
    this.stylesheet = stylesheet;
    this.blocks = group_selectors(node);
    let i = this.blocks.length;
    while (i > 0) {
      if (!this.blocks[i - 1].global)
        break;
      i -= 1;
    }
    this.local_blocks = this.blocks.slice(0, i);
    const host_only = this.blocks.length === 1 && this.blocks[0].host;
    const root_only = this.blocks.length === 1 && this.blocks[0].root;
    this.used = this.local_blocks.length === 0 || host_only || root_only;
  }
  /** @param {import('../nodes/Element.js').default} node */
  apply(node) {
    const to_encapsulate = [];
    apply_selector(this.local_blocks.slice(), node, to_encapsulate);
    if (to_encapsulate.length > 0) {
      to_encapsulate.forEach(({ node: node2, block }) => {
        this.stylesheet.nodes_with_css_class.add(node2);
        block.should_encapsulate = true;
      });
      this.used = true;
    }
  }
  /** @param {import('magic-string').default} code */
  minify(code) {
    let c = null;
    this.blocks.forEach((block, i) => {
      if (i > 0) {
        if (block.start - c > 1) {
          code.update(c, block.start, block.combinator.name || " ");
        }
      }
      c = block.end;
    });
  }
  /**
   * @param {import('magic-string').default} code
   * @param {string} attr
   * @param {number} max_amount_class_specificity_increased
   */
  transform(code, attr, max_amount_class_specificity_increased) {
    const amount_class_specificity_to_increase = max_amount_class_specificity_increased - this.blocks.filter((block) => block.should_encapsulate).length;
    function remove_global_pseudo_class(selector) {
      const first = selector.children[0];
      const last = selector.children[selector.children.length - 1];
      code.remove(selector.start, first.start).remove(last.end, selector.end);
    }
    function encapsulate_block(block, attr2) {
      for (const selector of block.selectors) {
        if (selector.type === "PseudoClassSelector" && selector.name === "global") {
          remove_global_pseudo_class(selector);
        }
      }
      let i = block.selectors.length;
      while (i--) {
        const selector = block.selectors[i];
        if (selector.type === "PseudoElementSelector" || selector.type === "PseudoClassSelector") {
          if (selector.name !== "root" && selector.name !== "host") {
            if (i === 0)
              code.prependRight(selector.start, attr2);
          }
          continue;
        }
        if (selector.type === "TypeSelector" && selector.name === "*") {
          code.update(selector.start, selector.end, attr2);
        } else {
          code.appendLeft(selector.end, attr2);
        }
        break;
      }
    }
    this.blocks.forEach((block, index) => {
      if (block.global) {
        remove_global_pseudo_class(block.selectors[0]);
      }
      if (block.should_encapsulate)
        encapsulate_block(
          block,
          index === this.blocks.length - 1 ? attr.repeat(amount_class_specificity_to_increase + 1) : attr
        );
    });
  }
  /** @param {import('../Component.js').default} component */
  validate(component) {
    let start = 0;
    let end = this.blocks.length;
    for (; start < end; start += 1) {
      if (!this.blocks[start].global)
        break;
    }
    for (; end > start; end -= 1) {
      if (!this.blocks[end - 1].global)
        break;
    }
    for (let i = start; i < end; i += 1) {
      if (this.blocks[i].global) {
        return component.error(this.blocks[i].selectors[0], compiler_errors_default.css_invalid_global);
      }
    }
    this.validate_global_with_multiple_selectors(component);
    this.validate_global_compound_selector(component);
    this.validate_invalid_combinator_without_selector(component);
  }
  /** @param {import('../Component.js').default} component */
  validate_global_with_multiple_selectors(component) {
    if (this.blocks.length === 1 && this.blocks[0].selectors.length === 1) {
      return;
    }
    for (const block of this.blocks) {
      for (const selector of block.selectors) {
        if (selector.type === "PseudoClassSelector" && selector.name === "global") {
          if (regex_is_single_css_selector.test(selector.children[0].value)) {
            component.error(selector, compiler_errors_default.css_invalid_global_selector);
          }
        }
      }
    }
  }
  /** @param {import('../Component.js').default} component */
  validate_invalid_combinator_without_selector(component) {
    for (let i = 0; i < this.blocks.length; i++) {
      const block = this.blocks[i];
      if (block.combinator && block.selectors.length === 0) {
        component.error(
          this.node,
          compiler_errors_default.css_invalid_selector(
            component.source.slice(this.node.start, this.node.end)
          )
        );
      }
      if (!block.combinator && block.selectors.length === 0) {
        component.error(
          this.node,
          compiler_errors_default.css_invalid_selector(
            component.source.slice(this.node.start, this.node.end)
          )
        );
      }
    }
  }
  /** @param {import('../Component.js').default} component */
  validate_global_compound_selector(component) {
    for (const block of this.blocks) {
      for (let index = 0; index < block.selectors.length; index++) {
        const selector = block.selectors[index];
        if (selector.type === "PseudoClassSelector" && selector.name === "global" && index !== 0 && selector.children && selector.children.length > 0 && !/[.:#\s]/.test(selector.children[0].value[0])) {
          component.error(selector, compiler_errors_default.css_invalid_global_selector_position);
        }
      }
    }
  }
  get_amount_class_specificity_increased() {
    let count = 0;
    for (const block of this.blocks) {
      if (block.should_encapsulate) {
        count++;
      }
    }
    return count;
  }
};
function apply_selector(blocks, node, to_encapsulate) {
  const block = blocks.pop();
  if (!block)
    return false;
  if (!node) {
    return block.global && blocks.every((block2) => block2.global) || block.host && blocks.length === 0;
  }
  switch (block_might_apply_to_node(block, node)) {
    case BlockAppliesToNode.NotPossible:
      return false;
    case BlockAppliesToNode.UnknownSelectorType:
      to_encapsulate.push({ node, block });
      return true;
  }
  if (block.combinator) {
    if (block.combinator.type === "Combinator" && block.combinator.name === " ") {
      for (const ancestor_block of blocks) {
        if (ancestor_block.global) {
          continue;
        }
        if (ancestor_block.host) {
          to_encapsulate.push({ node, block });
          return true;
        }
        let parent = node;
        while (parent = get_element_parent(parent)) {
          if (block_might_apply_to_node(ancestor_block, parent) !== BlockAppliesToNode.NotPossible) {
            to_encapsulate.push({ node: parent, block: ancestor_block });
          }
        }
        if (to_encapsulate.length) {
          to_encapsulate.push({ node, block });
          return true;
        }
      }
      if (blocks.every((block2) => block2.global)) {
        to_encapsulate.push({ node, block });
        return true;
      }
      return false;
    } else if (block.combinator.name === ">") {
      const has_global_parent = blocks.every((block2) => block2.global);
      if (has_global_parent || apply_selector(blocks, get_element_parent(node), to_encapsulate)) {
        to_encapsulate.push({ node, block });
        return true;
      }
      return false;
    } else if (block.combinator.name === "+" || block.combinator.name === "~") {
      const siblings = get_possible_element_siblings(node, block.combinator.name === "+");
      let has_match = false;
      const has_global = blocks.some((block2) => block2.global);
      if (has_global) {
        if (siblings.size === 0 && get_element_parent(node) !== null) {
          return false;
        }
        to_encapsulate.push({ node, block });
        return true;
      }
      for (const possible_sibling of siblings.keys()) {
        if (apply_selector(blocks.slice(), possible_sibling, to_encapsulate)) {
          to_encapsulate.push({ node, block });
          has_match = true;
        }
      }
      return has_match;
    }
    to_encapsulate.push({ node, block });
    return true;
  }
  to_encapsulate.push({ node, block });
  return true;
}
var regex_backslash_and_following_character = /\\(.)/g;
function block_might_apply_to_node(block, node) {
  let i = block.selectors.length;
  while (i--) {
    const selector = block.selectors[i];
    const name8 = typeof selector.name === "string" && selector.name.replace(regex_backslash_and_following_character, "$1");
    if (selector.type === "PseudoClassSelector" && (name8 === "host" || name8 === "root")) {
      return BlockAppliesToNode.NotPossible;
    }
    if (block.selectors.length === 1 && selector.type === "PseudoClassSelector" && name8 === "global") {
      return BlockAppliesToNode.NotPossible;
    }
    if (selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector") {
      continue;
    }
    if (selector.type === "ClassSelector") {
      if (!attribute_matches(node, "class", name8, "~=", false) && !node.classes.some((c) => c.name === name8))
        return BlockAppliesToNode.NotPossible;
    } else if (selector.type === "IdSelector") {
      if (!attribute_matches(node, "id", name8, "=", false))
        return BlockAppliesToNode.NotPossible;
    } else if (selector.type === "AttributeSelector") {
      if (!(whitelist_attribute_selector.has(node.name.toLowerCase()) && whitelist_attribute_selector.get(node.name.toLowerCase()).has(selector.name.name.toLowerCase())) && !attribute_matches(
        node,
        selector.name.name,
        selector.value && unquote(selector.value),
        selector.matcher,
        selector.flags
      )) {
        return BlockAppliesToNode.NotPossible;
      }
    } else if (selector.type === "TypeSelector") {
      if (node.name.toLowerCase() !== name8.toLowerCase() && name8 !== "*" && !node.is_dynamic_element)
        return BlockAppliesToNode.NotPossible;
    } else {
      return BlockAppliesToNode.UnknownSelectorType;
    }
  }
  return BlockAppliesToNode.Possible;
}
function test_attribute(operator, expected_value, case_insensitive, value) {
  if (case_insensitive) {
    expected_value = expected_value.toLowerCase();
    value = value.toLowerCase();
  }
  switch (operator) {
    case "=":
      return value === expected_value;
    case "~=":
      return value.split(/\s/).includes(expected_value);
    case "|=":
      return `${value}-`.startsWith(`${expected_value}-`);
    case "^=":
      return value.startsWith(expected_value);
    case "$=":
      return value.endsWith(expected_value);
    case "*=":
      return value.includes(expected_value);
    default:
      throw new Error("this shouldn't happen");
  }
}
function attribute_matches(node, name8, expected_value, operator, case_insensitive) {
  const spread = node.attributes.find((attr2) => attr2.type === "Spread");
  if (spread)
    return true;
  if (node.bindings.some((binding) => binding.name === name8))
    return true;
  const attr = node.attributes.find((attr2) => attr2.name === name8);
  if (!attr)
    return false;
  if (attr.is_true)
    return operator === null;
  if (expected_value == null)
    return true;
  if (attr.chunks.length === 1) {
    const value = attr.chunks[0];
    if (!value)
      return false;
    if (value.type === "Text")
      return test_attribute(operator, expected_value, case_insensitive, value.data);
  }
  const possible_values = /* @__PURE__ */ new Set();
  let prev_values = [];
  for (const chunk of attr.chunks) {
    const current_possible_values = /* @__PURE__ */ new Set();
    if (chunk.type === "Text") {
      current_possible_values.add(chunk.data);
    } else {
      gather_possible_values(chunk.node, current_possible_values);
    }
    if (current_possible_values.has(UNKNOWN))
      return true;
    if (prev_values.length > 0) {
      const start_with_space = [];
      const remaining = [];
      current_possible_values.forEach((current_possible_value) => {
        if (regex_starts_with_whitespace.test(current_possible_value)) {
          start_with_space.push(current_possible_value);
        } else {
          remaining.push(current_possible_value);
        }
      });
      if (remaining.length > 0) {
        if (start_with_space.length > 0) {
          prev_values.forEach((prev_value) => possible_values.add(prev_value));
        }
        const combined = [];
        prev_values.forEach((prev_value) => {
          remaining.forEach((value) => {
            combined.push(prev_value + value);
          });
        });
        prev_values = combined;
        start_with_space.forEach((value) => {
          if (regex_ends_with_whitespace.test(value)) {
            possible_values.add(value);
          } else {
            prev_values.push(value);
          }
        });
        continue;
      } else {
        prev_values.forEach((prev_value) => possible_values.add(prev_value));
        prev_values = [];
      }
    }
    current_possible_values.forEach((current_possible_value) => {
      if (regex_ends_with_whitespace.test(current_possible_value)) {
        possible_values.add(current_possible_value);
      } else {
        prev_values.push(current_possible_value);
      }
    });
    if (prev_values.length < current_possible_values.size) {
      prev_values.push(" ");
    }
    if (prev_values.length > 20) {
      return true;
    }
  }
  prev_values.forEach((prev_value) => possible_values.add(prev_value));
  if (possible_values.has(UNKNOWN))
    return true;
  for (const value of possible_values) {
    if (test_attribute(operator, expected_value, case_insensitive, value))
      return true;
  }
  return false;
}
function unquote(value) {
  if (value.type === "Identifier")
    return value.name;
  const str = value.value;
  if (str[0] === str[str.length - 1] && str[0] === "'" || str[0] === '"') {
    return str.slice(1, str.length - 1);
  }
  return str;
}
function get_element_parent(node) {
  let parent = node;
  while ((parent = parent.parent) && parent.type !== "Element")
    ;
  return (
    /** @type {import('../nodes/Element.js').default | null} */
    parent
  );
}
function find_previous_sibling(node) {
  let current_node = node;
  do {
    if (current_node.type === "Slot") {
      const slot_children = current_node.children;
      if (slot_children.length > 0) {
        current_node = slot_children.slice(-1)[0];
        continue;
      }
    }
    while (!current_node.prev && current_node.parent && current_node.parent.type === "Slot") {
      current_node = current_node.parent;
    }
    current_node = current_node.prev;
  } while (current_node && current_node.type === "Slot");
  return current_node;
}
function get_possible_element_siblings(node, adjacent_only) {
  const result = /* @__PURE__ */ new Map();
  let prev = node;
  while (prev = find_previous_sibling(prev)) {
    if (prev.type === "Element") {
      if (!prev.attributes.find(
        (attr) => attr.type === "Attribute" && attr.name.toLowerCase() === "slot"
      )) {
        result.set(prev, NodeExist.Definitely);
      }
      if (adjacent_only) {
        break;
      }
    } else if (prev.type === "EachBlock" || prev.type === "IfBlock" || prev.type === "AwaitBlock") {
      const possible_last_child = get_possible_last_child(prev, adjacent_only);
      add_to_map(possible_last_child, result);
      if (adjacent_only && has_definite_elements(possible_last_child)) {
        return result;
      }
    }
  }
  if (!prev || !adjacent_only) {
    let parent = node;
    let skip_each_for_last_child = node.type === "ElseBlock";
    while ((parent = parent.parent) && (parent.type === "EachBlock" || parent.type === "IfBlock" || parent.type === "ElseBlock" || parent.type === "AwaitBlock")) {
      const possible_siblings = get_possible_element_siblings(parent, adjacent_only);
      add_to_map(possible_siblings, result);
      if (parent.type === "EachBlock") {
        if (skip_each_for_last_child) {
          skip_each_for_last_child = false;
        } else {
          add_to_map(get_possible_last_child(parent, adjacent_only), result);
        }
      } else if (parent.type === "ElseBlock") {
        skip_each_for_last_child = true;
        parent = parent.parent;
      }
      if (adjacent_only && has_definite_elements(possible_siblings)) {
        break;
      }
    }
  }
  return result;
}
function get_possible_last_child(block, adjacent_only) {
  const result = /* @__PURE__ */ new Map();
  if (block.type === "EachBlock") {
    const each_result = loop_child(block.children, adjacent_only);
    const else_result = block.else ? loop_child(block.else.children, adjacent_only) : /* @__PURE__ */ new Map();
    const not_exhaustive = !has_definite_elements(else_result);
    if (not_exhaustive) {
      mark_as_probably(each_result);
      mark_as_probably(else_result);
    }
    add_to_map(each_result, result);
    add_to_map(else_result, result);
  } else if (block.type === "IfBlock") {
    const if_result = loop_child(block.children, adjacent_only);
    const else_result = block.else ? loop_child(block.else.children, adjacent_only) : /* @__PURE__ */ new Map();
    const not_exhaustive = !has_definite_elements(if_result) || !has_definite_elements(else_result);
    if (not_exhaustive) {
      mark_as_probably(if_result);
      mark_as_probably(else_result);
    }
    add_to_map(if_result, result);
    add_to_map(else_result, result);
  } else if (block.type === "AwaitBlock") {
    const pending_result = block.pending ? loop_child(block.pending.children, adjacent_only) : /* @__PURE__ */ new Map();
    const then_result = block.then ? loop_child(block.then.children, adjacent_only) : /* @__PURE__ */ new Map();
    const catch_result = block.catch ? loop_child(block.catch.children, adjacent_only) : /* @__PURE__ */ new Map();
    const not_exhaustive = !has_definite_elements(pending_result) || !has_definite_elements(then_result) || !has_definite_elements(catch_result);
    if (not_exhaustive) {
      mark_as_probably(pending_result);
      mark_as_probably(then_result);
      mark_as_probably(catch_result);
    }
    add_to_map(pending_result, result);
    add_to_map(then_result, result);
    add_to_map(catch_result, result);
  }
  return result;
}
function has_definite_elements(result) {
  if (result.size === 0)
    return false;
  for (const exist of result.values()) {
    if (exist === NodeExist.Definitely) {
      return true;
    }
  }
  return false;
}
function add_to_map(from, to) {
  from.forEach((exist, element) => {
    to.set(element, higher_existence(exist, to.get(element)));
  });
}
function higher_existence(exist1, exist2) {
  if (exist1 === void 0 || exist2 === void 0)
    return exist1 || exist2;
  return exist1 > exist2 ? exist1 : exist2;
}
function mark_as_probably(result) {
  for (const key of result.keys()) {
    result.set(key, NodeExist.Probably);
  }
}
function loop_child(children, adjacent_only) {
  const result = /* @__PURE__ */ new Map();
  for (let i = children.length - 1; i >= 0; i--) {
    const child = children[i];
    if (child.type === "Element") {
      result.set(child, NodeExist.Definitely);
      if (adjacent_only) {
        break;
      }
    } else if (child.type === "EachBlock" || child.type === "IfBlock" || child.type === "AwaitBlock") {
      const child_result = get_possible_last_child(child, adjacent_only);
      add_to_map(child_result, result);
      if (adjacent_only && has_definite_elements(child_result)) {
        break;
      }
    }
  }
  return result;
}
var Block2 = class {
  /** @param {import('./private.js').CssNode} combinator */
  constructor(combinator) {
    /** @type {boolean} */
    __publicField(this, "host");
    /** @type {boolean} */
    __publicField(this, "root");
    /** @type {import('./private.js').CssNode} */
    __publicField(this, "combinator");
    /** @type {import('./private.js').CssNode[]} */
    __publicField(this, "selectors");
    /** @type {number} */
    __publicField(this, "start");
    /** @type {number} */
    __publicField(this, "end");
    /** @type {boolean} */
    __publicField(this, "should_encapsulate");
    this.combinator = combinator;
    this.host = false;
    this.root = false;
    this.selectors = [];
    this.start = null;
    this.end = null;
    this.should_encapsulate = false;
  }
  /** @param {import('./private.js').CssNode} selector */
  add(selector) {
    if (this.selectors.length === 0) {
      this.start = selector.start;
      this.host = selector.type === "PseudoClassSelector" && selector.name === "host";
    }
    this.root = this.root || selector.type === "PseudoClassSelector" && selector.name === "root";
    this.selectors.push(selector);
    this.end = selector.end;
  }
  get global() {
    return this.selectors.length >= 1 && this.selectors[0].type === "PseudoClassSelector" && this.selectors[0].name === "global" && this.selectors.every(
      (selector) => selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector"
    );
  }
};
function group_selectors(selector) {
  let block = new Block2(null);
  const blocks = [block];
  selector.children.forEach((child) => {
    if (child.type === "WhiteSpace" || child.type === "Combinator") {
      block = new Block2(child);
      blocks.push(block);
    } else {
      block.add(child);
    }
  });
  return blocks;
}

// node_modules/svelte/src/compiler/compile/css/Stylesheet.js
var regex_css_browser_prefix = /^-((webkit)|(moz)|(o)|(ms))-/;
function remove_css_prefix(name8) {
  return name8.replace(regex_css_browser_prefix, "");
}
var is_keyframes_node = (node) => remove_css_prefix(node.name) === "keyframes";
var at_rule_has_declaration = ({ block }) => block && block.children && block.children.find((node) => node.type === "Declaration");
function minify_declarations(code, start, declarations) {
  let c = start;
  declarations.forEach((declaration, i) => {
    const separator = i > 0 ? ";" : "";
    if (declaration.node.start - c > separator.length) {
      code.update(c, declaration.node.start, separator);
    }
    declaration.minify(code);
    c = declaration.node.end;
  });
  return c;
}
var Rule = class {
  /**
   * @param {import('./private.js').CssNode} node
   * @param {any} stylesheet
   * @param {Atrule} [parent]
   */
  constructor(node, stylesheet, parent) {
    /** @type {import('./Selector.js').default[]} */
    __publicField(this, "selectors");
    /** @type {Declaration[]} */
    __publicField(this, "declarations");
    /** @type {import('./private.js').CssNode} */
    __publicField(this, "node");
    /** @type {Atrule} */
    __publicField(this, "parent");
    this.node = node;
    this.parent = parent;
    this.selectors = node.prelude.children.map((node2) => new Selector(node2, stylesheet));
    this.declarations = node.block.children.map((node2) => new Declaration(node2));
  }
  /** @param {import('../nodes/Element.js').default} node */
  apply(node) {
    this.selectors.forEach((selector) => selector.apply(node));
  }
  /** @param {boolean} dev */
  is_used(dev) {
    if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node))
      return true;
    if (this.declarations.length === 0)
      return dev;
    return this.selectors.some((s) => s.used);
  }
  /**
   * @param {import('magic-string').default} code
   * @param {boolean} _dev
   */
  minify(code, _dev) {
    let c = this.node.start;
    let started = false;
    this.selectors.forEach((selector) => {
      if (selector.used) {
        const separator = started ? "," : "";
        if (selector.node.start - c > separator.length) {
          code.update(c, selector.node.start, separator);
        }
        selector.minify(code);
        c = selector.node.end;
        started = true;
      }
    });
    code.remove(c, this.node.block.start);
    c = this.node.block.start + 1;
    c = minify_declarations(code, c, this.declarations);
    code.remove(c, this.node.block.end - 1);
  }
  /**
   * @param {import('magic-string').default} code
   * @param {string} id
   * @param {Map<string, string>} keyframes
   * @param {number} max_amount_class_specificity_increased
   */
  transform(code, id, keyframes, max_amount_class_specificity_increased) {
    if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node))
      return true;
    const attr = `.${id}`;
    this.selectors.forEach(
      (selector) => selector.transform(code, attr, max_amount_class_specificity_increased)
    );
    this.declarations.forEach((declaration) => declaration.transform(code, keyframes));
  }
  /** @param {import('../Component.js').default} component */
  validate(component) {
    this.selectors.forEach((selector) => {
      selector.validate(component);
    });
  }
  /** @param {(selector: import('./Selector.js').default) => void} handler */
  warn_on_unused_selector(handler) {
    this.selectors.forEach((selector) => {
      if (!selector.used)
        handler(selector);
    });
  }
  get_max_amount_class_specificity_increased() {
    return Math.max(
      ...this.selectors.map((selector) => selector.get_amount_class_specificity_increased())
    );
  }
};
var Declaration = class {
  /** @param {import('./private.js').CssNode} node */
  constructor(node) {
    /** @type {import('./private.js').CssNode} */
    __publicField(this, "node");
    this.node = node;
  }
  /**
   * @param {import('magic-string').default} code
   * @param {Map<string, string>} keyframes
   */
  transform(code, keyframes) {
    const property = this.node.property && remove_css_prefix(this.node.property.toLowerCase());
    if (property === "animation" || property === "animation-name") {
      this.node.value.children.forEach((block) => {
        if (block.type === "Identifier") {
          const name8 = block.name;
          if (keyframes.has(name8)) {
            code.update(block.start, block.end, keyframes.get(name8));
          }
        }
      });
    }
  }
  /** @param {import('magic-string').default} code */
  minify(code) {
    if (!this.node.property)
      return;
    const c = this.node.start + this.node.property.length;
    const first = this.node.value.children ? this.node.value.children[0] : this.node.value;
    if (first.type === "Raw" && regex_only_whitespaces.test(first.value))
      return;
    let start = first.start;
    while (regex_whitespace.test(code.original[start]))
      start += 1;
    if (start - c > 1) {
      code.update(c, start, ":");
    }
  }
};
var Atrule = class {
  /** @param {import('./private.js').CssNode} node */
  constructor(node) {
    /** @type {import('./private.js').CssNode} */
    __publicField(this, "node");
    /** @type {Array<Atrule | Rule>} */
    __publicField(this, "children");
    /** @type {Declaration[]} */
    __publicField(this, "declarations");
    this.node = node;
    this.children = [];
    this.declarations = [];
  }
  /** @param {import('../nodes/Element.js').default} node */
  apply(node) {
    if (this.node.name === "container" || this.node.name === "media" || this.node.name === "supports" || this.node.name === "layer") {
      this.children.forEach((child) => {
        child.apply(node);
      });
    } else if (is_keyframes_node(this.node)) {
      this.children.forEach((rule) => {
        rule.selectors.forEach((selector) => {
          selector.used = true;
        });
      });
    }
  }
  /** @param {boolean} _dev */
  is_used(_dev) {
    return true;
  }
  /**
   * @param {import('magic-string').default} code
   * @param {boolean} dev
   */
  minify(code, dev) {
    if (this.node.name === "media") {
      const expression_char = code.original[this.node.prelude.start];
      let c = this.node.start + (expression_char === "(" ? 6 : 7);
      if (this.node.prelude.start > c)
        code.remove(c, this.node.prelude.start);
      this.node.prelude.children.forEach((query) => {
        c = query.end;
      });
      code.remove(c, this.node.block.start);
    } else if (this.node.name === "supports") {
      let c = this.node.start + 9;
      if (this.node.prelude.start - c > 1)
        code.update(c, this.node.prelude.start, " ");
      this.node.prelude.children.forEach((query) => {
        c = query.end;
      });
      code.remove(c, this.node.block.start);
    } else {
      let c = this.node.start + this.node.name.length + 1;
      if (this.node.prelude) {
        if (this.node.prelude.start - c > 1)
          code.update(c, this.node.prelude.start, " ");
        c = this.node.prelude.end;
      }
      if (this.node.block && this.node.block.start - c > 0) {
        code.remove(c, this.node.block.start);
      }
    }
    if (this.node.block) {
      let c = this.node.block.start + 1;
      if (this.declarations.length) {
        c = minify_declarations(code, c, this.declarations);
        if (this.children.length)
          c++;
      }
      this.children.forEach((child) => {
        if (child.is_used(dev)) {
          code.remove(c, child.node.start);
          child.minify(code, dev);
          c = child.node.end;
        }
      });
      code.remove(c, this.node.block.end - 1);
    }
  }
  /**
   * @param {import('magic-string').default} code
   * @param {string} id
   * @param {Map<string, string>} keyframes
   * @param {number} max_amount_class_specificity_increased
   */
  transform(code, id, keyframes, max_amount_class_specificity_increased) {
    if (is_keyframes_node(this.node)) {
      this.node.prelude.children.forEach(({ type, name: name8, start, end }) => {
        if (type === "Identifier") {
          if (name8.startsWith("-global-")) {
            code.remove(start, start + 8);
            this.children.forEach((rule) => {
              rule.selectors.forEach((selector) => {
                selector.used = true;
              });
            });
          } else {
            code.update(start, end, keyframes.get(name8));
          }
        }
      });
    }
    this.children.forEach((child) => {
      child.transform(code, id, keyframes, max_amount_class_specificity_increased);
    });
  }
  /** @param {import('../Component.js').default} component */
  validate(component) {
    this.children.forEach((child) => {
      child.validate(component);
    });
  }
  /** @param {(selector: import('./Selector.js').default) => void} handler */
  warn_on_unused_selector(handler) {
    if (this.node.name !== "media")
      return;
    this.children.forEach((child) => {
      child.warn_on_unused_selector(handler);
    });
  }
  get_max_amount_class_specificity_increased() {
    return Math.max(
      ...this.children.map((rule) => rule.get_max_amount_class_specificity_increased())
    );
  }
};
var get_default_css_hash = ({ css, hash: hash2 }) => {
  return `svelte-${hash2(css)}`;
};
var Stylesheet = class {
  /**
   * @param {{
   * 		source: string;
   * 		ast: import('../../interfaces.js').Ast;
   * 		filename: string | undefined;
   * 		component_name: string | undefined;
   * 		dev: boolean;
   * 		get_css_hash: import('../../interfaces.js').CssHashGetter;
   * 	}} params
   */
  constructor({ source, ast, component_name, filename, dev, get_css_hash = get_default_css_hash }) {
    /** @type {string} */
    __publicField(this, "source");
    /** @type {import('../../interfaces.js').Ast} */
    __publicField(this, "ast");
    /** @type {string} */
    __publicField(this, "filename");
    /** @type {boolean} */
    __publicField(this, "dev");
    /** @type {boolean} */
    __publicField(this, "has_styles");
    /** @type {string} */
    __publicField(this, "id");
    /** @type {Array<Rule | Atrule>} */
    __publicField(this, "children", []);
    /** @type {Map<string, string>} */
    __publicField(this, "keyframes", /* @__PURE__ */ new Map());
    /** @type {Set<import('./private.js').CssNode>} */
    __publicField(this, "nodes_with_css_class", /* @__PURE__ */ new Set());
    this.source = source;
    this.ast = ast;
    this.filename = filename;
    this.dev = dev;
    if (ast.css && ast.css.children.length) {
      this.id = get_css_hash({
        filename,
        name: component_name,
        css: ast.css.content.styles,
        hash
      });
      this.has_styles = true;
      const stack = [];
      let depth = 0;
      let current_atrule = null;
      walk(
        /** @type {any} */
        ast.css,
        {
          enter: (node) => {
            if (node.type === "Atrule") {
              const atrule = new Atrule(node);
              stack.push(atrule);
              if (current_atrule) {
                current_atrule.children.push(atrule);
              } else if (depth <= 1) {
                this.children.push(atrule);
              }
              if (is_keyframes_node(node)) {
                node.prelude.children.forEach((expression) => {
                  if (expression.type === "Identifier" && !expression.name.startsWith("-global-")) {
                    this.keyframes.set(expression.name, `${this.id}-${expression.name}`);
                  }
                });
              } else if (at_rule_has_declaration(node)) {
                const at_rule_declarations = node.block.children.filter((node2) => node2.type === "Declaration").map((node2) => new Declaration(node2));
                push_array(atrule.declarations, at_rule_declarations);
              }
              current_atrule = atrule;
            }
            if (node.type === "Rule") {
              const rule = new Rule(node, this, current_atrule);
              if (current_atrule) {
                current_atrule.children.push(rule);
              } else if (depth <= 1) {
                this.children.push(rule);
              }
            }
            depth += 1;
          },
          leave: (node) => {
            if (node.type === "Atrule") {
              stack.pop();
              current_atrule = stack[stack.length - 1];
            }
            depth -= 1;
          }
        }
      );
    } else {
      this.has_styles = false;
    }
  }
  /** @param {import('../nodes/Element.js').default} node */
  apply(node) {
    if (!this.has_styles)
      return;
    for (let i = 0; i < this.children.length; i += 1) {
      const child = this.children[i];
      child.apply(node);
    }
  }
  reify() {
    this.nodes_with_css_class.forEach((node) => {
      node.add_css_class();
    });
  }
  /** @param {string} file */
  render(file) {
    if (!this.has_styles) {
      return { code: null, map: null };
    }
    const code = new MagicString(this.source);
    walk(
      /** @type {any} */
      this.ast.css,
      {
        enter: (node) => {
          code.addSourcemapLocation(node.start);
          code.addSourcemapLocation(node.end);
        }
      }
    );
    const max = Math.max(
      ...this.children.map((rule) => rule.get_max_amount_class_specificity_increased())
    );
    this.children.forEach((child) => {
      child.transform(code, this.id, this.keyframes, max);
    });
    let c = 0;
    this.children.forEach((child) => {
      if (child.is_used(this.dev)) {
        code.remove(c, child.node.start);
        child.minify(code, this.dev);
        c = child.node.end;
      }
    });
    code.remove(c, this.source.length);
    return {
      code: code.toString(),
      map: code.generateMap({
        includeContent: true,
        source: this.filename,
        file
      })
    };
  }
  /** @param {import('../Component.js').default} component */
  validate(component) {
    this.children.forEach((child) => {
      child.validate(component);
    });
  }
  /** @param {import('../Component.js').default} component */
  warn_on_unused_selectors(component) {
    const ignores = !this.ast.css ? [] : extract_ignores_above_position(this.ast.css.start, this.ast.html.children);
    component.push_ignores(ignores);
    this.children.forEach((child) => {
      child.warn_on_unused_selector((selector) => {
        component.warn(
          selector.node,
          compiler_warnings_default.css_unused_selector(
            this.source.slice(selector.node.start, selector.node.end)
          )
        );
      });
    });
    component.pop_ignores();
  }
};

// node_modules/svelte/src/compiler/compile/nodes/shared/TemplateScope.js
var TemplateScope = class _TemplateScope {
  /** @param {TemplateScope} [parent]  undefined */
  constructor(parent) {
    /**
     * @typedef {import('../EachBlock').default
     * 	| import('../ThenBlock').default
     * 	| import('../CatchBlock').default
     * 	| import('../InlineComponent').default
     * 	| import('../Element').default
     * 	| import('../SlotTemplate').default
     * 	| import('../ConstTag').default} NodeWithScope
     */
    /** @type {Set<string>} */
    __publicField(this, "names");
    /** @type {Map<string, Set<string>>} */
    __publicField(this, "dependencies_for_name");
    /** @type {Map<string, NodeWithScope>} */
    __publicField(this, "owners", /* @__PURE__ */ new Map());
    /** @type {TemplateScope} */
    __publicField(this, "parent");
    this.parent = parent;
    this.names = new Set(parent ? parent.names : []);
    this.dependencies_for_name = new Map(parent ? parent.dependencies_for_name : []);
  }
  /**
   * @param {any} name
   * @param {Set<string>} dependencies
   * @param {any} owner
   */
  add(name8, dependencies, owner) {
    this.names.add(name8);
    this.dependencies_for_name.set(name8, dependencies);
    this.owners.set(name8, owner);
    return this;
  }
  child() {
    const child = new _TemplateScope(this);
    return child;
  }
  /** @param {string} name */
  is_top_level(name8) {
    return !this.parent || !this.names.has(name8) && this.parent.is_top_level(name8);
  }
  /**
   * @param {string} name
   * @returns {NodeWithScope}
   */
  get_owner(name8) {
    return this.owners.get(name8) || this.parent && this.parent.get_owner(name8);
  }
  /** @param {string} name */
  is_let(name8) {
    const owner = this.get_owner(name8);
    return owner && (owner.type === "Element" || owner.type === "InlineComponent" || owner.type === "SlotTemplate");
  }
  /** @param {string} name */
  is_await(name8) {
    const owner = this.get_owner(name8);
    return owner && (owner.type === "ThenBlock" || owner.type === "CatchBlock");
  }
  /** @param {string} name */
  is_const(name8) {
    const owner = this.get_owner(name8);
    return owner && owner.type === "ConstTag";
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Fragment.js
var Fragment = class extends Node {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, info) {
    const scope = new TemplateScope();
    super(component, null, scope, info);
    /** @type {import('../render_dom/Block.js').default} */
    __publicField(this, "block");
    /** @type {import('./interfaces.js').INode[]} */
    __publicField(this, "children");
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    this.scope = scope;
    this.children = map_children(component, this, scope, info.children);
  }
};

// node_modules/svelte/src/compiler/compile/internal_exports.js
var internal_exports_default = /* @__PURE__ */ new Set(["HtmlTag", "HtmlTagHydration", "ResizeObserverSingleton", "SvelteComponent", "SvelteComponentDev", "SvelteComponentTyped", "SvelteElement", "action_destroyer", "add_attribute", "add_classes", "add_flush_callback", "add_iframe_resize_listener", "add_location", "add_render_callback", "add_styles", "add_transform", "afterUpdate", "append", "append_dev", "append_empty_stylesheet", "append_hydration", "append_hydration_dev", "append_styles", "assign", "attr", "attr_dev", "attribute_to_object", "beforeUpdate", "bind", "binding_callbacks", "blank_object", "bubble", "check_outros", "children", "claim_comment", "claim_component", "claim_element", "claim_html_tag", "claim_space", "claim_svg_element", "claim_text", "clear_loops", "comment", "component_subscribe", "compute_rest_props", "compute_slots", "construct_svelte_component", "construct_svelte_component_dev", "contenteditable_truthy_values", "createEventDispatcher", "create_animation", "create_bidirectional_transition", "create_component", "create_custom_element", "create_in_transition", "create_out_transition", "create_slot", "create_ssr_component", "current_component", "custom_event", "dataset_dev", "debug", "destroy_block", "destroy_component", "destroy_each", "detach", "detach_after_dev", "detach_before_dev", "detach_between_dev", "detach_dev", "dirty_components", "dispatch_dev", "each", "element", "element_is", "empty", "end_hydrating", "ensure_array_like", "ensure_array_like_dev", "escape", "escape_attribute_value", "escape_object", "exclude_internal_props", "fix_and_destroy_block", "fix_and_outro_and_destroy_block", "fix_position", "flush", "flush_render_callbacks", "getAllContexts", "getContext", "get_all_dirty_from_scope", "get_binding_group_value", "get_current_component", "get_custom_elements_slots", "get_root_for_style", "get_slot_changes", "get_spread_object", "get_spread_update", "get_store_value", "get_svelte_dataset", "globals", "group_outros", "handle_promise", "hasContext", "has_prop", "head_selector", "identity", "init", "init_binding_group", "init_binding_group_dynamic", "insert", "insert_dev", "insert_hydration", "insert_hydration_dev", "intros", "invalid_attribute_name_character", "is_client", "is_crossorigin", "is_empty", "is_function", "is_promise", "is_void", "listen", "listen_dev", "loop", "loop_guard", "merge_ssr_styles", "missing_component", "mount_component", "noop", "not_equal", "now", "null_to_empty", "object_without_properties", "onDestroy", "onMount", "once", "outro_and_destroy_block", "prevent_default", "prop_dev", "query_selector_all", "raf", "resize_observer_border_box", "resize_observer_content_box", "resize_observer_device_pixel_content_box", "run", "run_all", "safe_not_equal", "schedule_update", "select_multiple_value", "select_option", "select_options", "select_value", "self", "setContext", "set_attributes", "set_current_component", "set_custom_element_data", "set_custom_element_data_map", "set_data", "set_data_contenteditable", "set_data_contenteditable_dev", "set_data_dev", "set_data_maybe_contenteditable", "set_data_maybe_contenteditable_dev", "set_dynamic_element_data", "set_input_type", "set_input_value", "set_now", "set_raf", "set_store_value", "set_style", "set_svg_attributes", "space", "split_css_unit", "spread", "src_url_equal", "srcset_url_equal", "start_hydrating", "stop_immediate_propagation", "stop_propagation", "stringify_spread", "subscribe", "svg_element", "text", "tick", "time_ranges_to_array", "to_number", "toggle_class", "transition_in", "transition_out", "trusted", "update_await_block_branch", "update_keyed_each", "update_slot", "update_slot_base", "validate_component", "validate_dynamic_element", "validate_each_keys", "validate_slots", "validate_store", "validate_void_dynamic_element", "xlink_attr"]);

// node_modules/svelte/src/compiler/compile/utils/is_used_as_reference.js
function is_used_as_reference(node, parent) {
  if (!is_reference(
    /** @type {import('is-reference').NodeWithPropertyDefinition} */
    node,
    /** @type {import('is-reference').NodeWithPropertyDefinition} */
    parent
  )) {
    return false;
  }
  if (!parent) {
    return true;
  }
  switch (parent.type) {
    case "VariableDeclarator":
      return node !== parent.id;
    case "FunctionDeclaration":
    case "ImportSpecifier":
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ExportSpecifier":
      return false;
    default:
      return true;
  }
}

// node_modules/svelte/src/compiler/compile/Component.js
var regex_leading_directory_separator = /^[/\\]/;
var regex_starts_with_term_export = /^Export/;
var regex_contains_term_function = /Function/;
var Component = class {
  /**
   * @param {import('../interfaces.js').Ast} ast
   * @param {string} source
   * @param {string} name
   * @param {import('../interfaces.js').CompileOptions} compile_options
   * @param {import('../Stats.js').default} stats
   * @param {import('../interfaces.js').Warning[]} warnings
   */
  constructor(ast, source, name8, compile_options, stats, warnings) {
    /** @type {import('../Stats.js').default} */
    __publicField(this, "stats");
    /** @type {import('../interfaces.js').Warning[]} */
    __publicField(this, "warnings");
    /** @type {Set<string>} */
    __publicField(this, "ignores");
    /** @type {Array<Set<string>>} */
    __publicField(this, "ignore_stack", []);
    /** @type {import('../interfaces.js').Ast} */
    __publicField(this, "ast");
    /** @type {import('../interfaces.js').Ast} */
    __publicField(this, "original_ast");
    /** @type {string} */
    __publicField(this, "source");
    /** @type {import('estree').Identifier} */
    __publicField(this, "name");
    /** @type {import('../interfaces.js').CompileOptions} */
    __publicField(this, "compile_options");
    /** @type {import('./nodes/Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {import('./utils/scope.js').Scope} */
    __publicField(this, "module_scope");
    /** @type {import('./utils/scope.js').Scope} */
    __publicField(this, "instance_scope");
    /** @type {WeakMap<import('estree').Node, import('./utils/scope.js').Scope>} */
    __publicField(this, "instance_scope_map");
    /** @type {ComponentOptions} */
    __publicField(this, "component_options");
    /** @type {string} */
    __publicField(this, "namespace");
    /** @type {string} */
    __publicField(this, "tag");
    /** @type {boolean} */
    __publicField(this, "accessors");
    /** @type {import('../interfaces.js').Var[]} */
    __publicField(this, "vars", []);
    /** @type {Map<string, import('../interfaces.js').Var>} */
    __publicField(this, "var_lookup", /* @__PURE__ */ new Map());
    /** @type {import('estree').ImportDeclaration[]} */
    __publicField(this, "imports", []);
    /** @type {import('estree').ExportNamedDeclaration[]} */
    __publicField(this, "exports_from", []);
    /** @type {import('estree').ExportNamedDeclaration[]} */
    __publicField(this, "instance_exports_from", []);
    /** @type {Set<import('estree').Node>} */
    __publicField(this, "hoistable_nodes", /* @__PURE__ */ new Set());
    /** @type {Map<string, import('estree').Node>} */
    __publicField(this, "node_for_declaration", /* @__PURE__ */ new Map());
    /** @type {Array<import('estree').Node | import('estree').Node[]>} */
    __publicField(this, "partly_hoisted", []);
    /** @type {Array<import('estree').Node | import('estree').Node[]>} */
    __publicField(this, "fully_hoisted", []);
    /**
     * @type {Array<{
     * 		assignees: Set<string>;
     * 		dependencies: Set<string>;
     * 		node: import('estree').Node;
     * 		declaration: import('estree').Node;
     * 	}>}
     */
    __publicField(this, "reactive_declarations", []);
    /** @type {Set<import('estree').Node>} */
    __publicField(this, "reactive_declaration_nodes", /* @__PURE__ */ new Set());
    /** */
    __publicField(this, "has_reactive_assignments", false);
    /** @type {Set<string>} */
    __publicField(this, "injected_reactive_declaration_vars", /* @__PURE__ */ new Set());
    /** @type {Map<string, import('estree').Identifier>} */
    __publicField(this, "helpers", /* @__PURE__ */ new Map());
    /** @type {Map<string, import('estree').Identifier>} */
    __publicField(this, "globals", /* @__PURE__ */ new Map());
    /** @type {Map<string, Set<string>>} */
    __publicField(this, "indirect_dependencies", /* @__PURE__ */ new Map());
    /** @type {string} */
    __publicField(this, "file");
    /**
     * Use this for stack traces. It is 1-based and acts on pre-processed sources.
     * Use `meta_locate` for metadata on DOM elements.
     * @type {(c: number) => { line: number; column: number }}
     */
    __publicField(this, "locate");
    /**
     * Use this for metadata on DOM elements. It is 1-based and acts on sources that have not been pre-processed.
     * Use `locate` for source mappings.
     * @type {(c: number) => { line: number; column: number }}
     */
    __publicField(this, "meta_locate");
    /** @type {import('./nodes/Element.js').default[]} */
    __publicField(this, "elements", []);
    /** @type {import('./css/Stylesheet.js').default} */
    __publicField(this, "stylesheet");
    /** @type {Map<string, import('estree').Identifier>} */
    __publicField(this, "aliases", /* @__PURE__ */ new Map());
    /** @type {Set<string>} */
    __publicField(this, "used_names", /* @__PURE__ */ new Set());
    /** @type {Set<string>} */
    __publicField(this, "globally_used_names", /* @__PURE__ */ new Set());
    /** @type {Map<string, import('./nodes/Slot.js').default>} */
    __publicField(this, "slots", /* @__PURE__ */ new Map());
    /** @type {Set<string>} */
    __publicField(this, "slot_outlets", /* @__PURE__ */ new Set());
    /** @type {import('./nodes/shared/Tag.js').default[]} */
    __publicField(this, "tags", []);
    var _a;
    this.name = { type: "Identifier", name: name8 };
    this.stats = stats;
    this.warnings = warnings;
    this.ast = ast;
    this.source = source;
    this.compile_options = compile_options;
    this.original_ast = clone({
      html: ast.html,
      css: ast.css,
      instance: ast.instance,
      module: ast.module
    });
    this.file = compile_options.filename && (typeof process !== "undefined" ? compile_options.filename.replace(process.cwd(), "").replace(regex_leading_directory_separator, "") : compile_options.filename);
    this.locate = getLocator(this.source, { offsetLine: 1 });
    let tracer;
    this.meta_locate = (c) => {
      let location = this.locate(c);
      if (tracer === void 0) {
        tracer = compile_options.sourcemap ? new import_trace_mapping.TraceMap(compile_options.sourcemap) : null;
      }
      if (tracer) {
        location = (0, import_trace_mapping.originalPositionFor)(tracer, location);
      }
      return location;
    };
    this.stylesheet = new Stylesheet({
      source,
      ast,
      filename: compile_options.filename,
      component_name: name8,
      dev: compile_options.dev,
      get_css_hash: compile_options.cssHash
    });
    this.stylesheet.validate(this);
    this.component_options = process_component_options(this, this.ast.html.children);
    this.namespace = namespaces[this.component_options.namespace] || this.component_options.namespace;
    if (compile_options.customElement) {
      this.tag = ((_a = this.component_options.customElement) == null ? void 0 : _a.tag) || compile_options.tag || this.name.name;
    } else {
      this.tag = this.name.name;
    }
    this.walk_module_js();
    this.push_ignores(
      this.ast.instance ? extract_ignores_above_position(this.ast.instance.start, this.ast.html.children) : []
    );
    this.walk_instance_js_pre_template();
    this.pop_ignores();
    this.fragment = new Fragment(this, ast.html);
    this.name = this.get_unique_name(name8);
    this.push_ignores(
      this.ast.instance ? extract_ignores_above_position(this.ast.instance.start, this.ast.html.children) : []
    );
    this.walk_instance_js_post_template();
    this.pop_ignores();
    this.elements.forEach((element) => this.stylesheet.apply(element));
    this.stylesheet.reify();
    this.stylesheet.warn_on_unused_selectors(this);
  }
  /**
   * @param {import('estree').Node} node
   * @param {import('../interfaces.js').Var} variable
   * @param {any} add_to_lookup
   */
  add_var(node, variable, add_to_lookup = true) {
    this.vars.push(variable);
    if (add_to_lookup) {
      if (this.var_lookup.has(variable.name)) {
        const exists_var = this.var_lookup.get(variable.name);
        if (exists_var.module && exists_var.imported) {
          this.error(
            /** @type {any} */
            node,
            compiler_errors_default.illegal_variable_declaration
          );
        }
      }
      this.var_lookup.set(variable.name, variable);
    }
  }
  /**
   * @param {import('estree').Node} node
   * @param {string} name
   */
  add_reference(node, name8) {
    const variable = this.var_lookup.get(name8);
    if (variable) {
      variable.referenced = true;
    } else if (is_reserved_keyword(name8)) {
      this.add_var(node, {
        name: name8,
        injected: true,
        referenced: true
      });
    } else if (name8[0] === "$") {
      this.add_var(node, {
        name: name8,
        injected: true,
        referenced: true,
        mutated: true,
        writable: true
      });
      const subscribable_name = name8.slice(1);
      const variable2 = this.var_lookup.get(subscribable_name);
      if (variable2) {
        variable2.referenced = true;
        variable2.subscribable = true;
      }
    } else {
      if (this.compile_options.varsReport === "full") {
        this.add_var(node, { name: name8, referenced: true }, false);
      }
      this.used_names.add(name8);
    }
  }
  /** @param {string} name */
  alias(name8) {
    if (!this.aliases.has(name8)) {
      this.aliases.set(name8, this.get_unique_name(name8));
    }
    return this.aliases.get(name8);
  }
  /** @param {import('./nodes/Element.js').default} element */
  apply_stylesheet(element) {
    this.elements.push(element);
  }
  /** @param {string} name */
  global(name8) {
    const alias = this.alias(name8);
    this.globals.set(name8, alias);
    return alias;
  }
  /**
   * @param {{ js: import('estree').Node[]; css: import('../interfaces.js').CssResult }} [result]
   * @returns {import('../interfaces.js').CompileResult}
   */
  generate(result) {
    let js = null;
    let css = null;
    if (result) {
      const { compile_options, name: name8 } = this;
      const banner = `${this.file ? `${this.file} ` : ""}generated by Svelte v${VERSION}`;
      const program = { type: "Program", body: result.js };
      walk(program, {
        enter: (
          /**
          * @param {import('estree').Node} node
          * @param {import('estree').Node} parent
          * @param {any} key
          */
          (node, parent, key) => {
            if (node.type === "Identifier") {
              if (node.name[0] === "@") {
                if (node.name[1] === "_") {
                  const alias = this.global(node.name.slice(2));
                  node.name = alias.name;
                } else {
                  let name9 = node.name.slice(1);
                  if (compile_options.hydratable) {
                    if (internal_exports_default.has(`${name9}_hydration`)) {
                      name9 += "_hydration";
                    } else if (internal_exports_default.has(`${name9}Hydration`)) {
                      name9 += "Hydration";
                    }
                  }
                  if (compile_options.dev) {
                    if (internal_exports_default.has(`${name9}_dev`)) {
                      name9 += "_dev";
                    } else if (internal_exports_default.has(`${name9}Dev`)) {
                      name9 += "Dev";
                    }
                  }
                  const alias = this.alias(name9);
                  this.helpers.set(name9, alias);
                  node.name = alias.name;
                }
              } else if (node.name[0] !== "#" && !is_valid(node.name)) {
                const literal = { type: "Literal", value: node.name };
                if (parent.type === "Property" && key === "key") {
                  parent.key = literal;
                } else if (parent.type === "MemberExpression" && key === "property") {
                  parent.property = literal;
                  parent.computed = true;
                }
              }
            }
          }
        )
      });
      const referenced_globals = Array.from(
        this.globals,
        ([name9, alias]) => name9 !== alias.name && { name: name9, alias }
      ).filter(Boolean);
      if (referenced_globals.length) {
        this.helpers.set("globals", this.alias("globals"));
      }
      const imported_helpers = Array.from(this.helpers, ([name9, alias]) => ({
        name: name9,
        alias
      }));
      create_module(
        program,
        name8,
        banner,
        compile_options.sveltePath,
        imported_helpers,
        referenced_globals,
        this.imports,
        this.vars.filter((variable) => variable.module && variable.export_name).map((variable) => ({
          name: variable.name,
          as: variable.export_name
        })),
        this.exports_from
      );
      css = compile_options.customElement ? { code: null, map: null } : result.css;
      const js_sourcemap_enabled = check_enable_sourcemap(compile_options.enableSourcemap, "js");
      if (!js_sourcemap_enabled) {
        js = print(program);
        js.map = null;
      } else {
        const sourcemap_source_filename = get_sourcemap_source_filename(compile_options);
        js = print(program, {
          sourceMapSource: sourcemap_source_filename
        });
        js.map.sources = [sourcemap_source_filename];
        js.map.sourcesContent = [this.source];
        js.map = apply_preprocessor_sourcemap(
          sourcemap_source_filename,
          js.map,
          /** @type {string | import('@ampproject/remapping').RawSourceMap | import('@ampproject/remapping').DecodedSourceMap} */
          compile_options.sourcemap
        );
      }
    }
    return {
      js,
      css,
      ast: this.original_ast,
      warnings: this.warnings,
      vars: this.get_vars_report(),
      stats: this.stats.render()
    };
  }
  /**
   * @param {string} name
   * @param {import('./utils/scope.js').Scope} [scope]
   * @returns {import('estree').Identifier}
   */
  get_unique_name(name8, scope) {
    let alias = name8;
    for (let i = 1; reserved.has(alias) || this.var_lookup.has(alias) || this.used_names.has(alias) || this.globally_used_names.has(alias) || scope && scope.has(alias); ) {
      alias = `${name8}_${i++}`;
    }
    this.used_names.add(alias);
    return { type: "Identifier", name: alias };
  }
  get_unique_name_maker() {
    const local_used_names = /* @__PURE__ */ new Set();
    function add(name8) {
      local_used_names.add(name8);
    }
    reserved.forEach(add);
    internal_exports_default.forEach(add);
    this.var_lookup.forEach((_value, key) => add(key));
    return (name8) => {
      let alias = name8;
      for (let i = 1; this.used_names.has(alias) || local_used_names.has(alias); alias = `${name8}_${i++}`)
        ;
      local_used_names.add(alias);
      this.globally_used_names.add(alias);
      return {
        type: "Identifier",
        name: alias
      };
    };
  }
  /** @returns {import('../interfaces.js').Var[]} */
  get_vars_report() {
    const { compile_options, vars } = this;
    const vars_report = compile_options.varsReport === false ? [] : compile_options.varsReport === "full" ? vars : vars.filter((v) => !v.global && !v.internal);
    return vars_report.map((v) => ({
      name: v.name,
      export_name: v.export_name || null,
      injected: v.injected || false,
      module: v.module || false,
      mutated: v.mutated || false,
      reassigned: v.reassigned || false,
      referenced: v.referenced || false,
      writable: v.writable || false,
      referenced_from_script: v.referenced_from_script || false
    }));
  }
  /**
   * @param {{
   * 			start: number;
   * 			end: number;
   * 		}} pos
   * @param {{
   * 			code: string;
   * 			message: string;
   * 		}} e
   */
  error(pos, e) {
    if (this.compile_options.errorMode === "warn") {
      this.warn(pos, e);
    } else {
      error(e.message, {
        name: "ValidationError",
        code: e.code,
        source: this.source,
        start: pos.start,
        end: pos.end,
        filename: this.compile_options.filename
      });
    }
  }
  /**
   * @param {{
   * 			start: number;
   * 			end: number;
   * 		}} pos
   * @param {{
   * 			code: string;
   * 			message: string;
   * 		}} warning
   */
  warn(pos, warning) {
    if (this.ignores && this.ignores.has(warning.code)) {
      return;
    }
    const start = this.locate(pos.start);
    const end = this.locate(pos.end);
    const frame = get_code_frame(this.source, start.line - 1, start.column);
    this.warnings.push({
      code: warning.code,
      message: warning.message,
      frame,
      start,
      end,
      pos: pos.start,
      filename: this.compile_options.filename,
      toString: () => `${warning.message} (${start.line}:${start.column})
${frame}`
    });
  }
  /** @param {any} node */
  extract_imports(node) {
    this.imports.push(node);
  }
  /**
   * @param {any} node
   * @param {any} module_script
   */
  extract_exports(node, module_script = false) {
    const ignores = extract_svelte_ignore_from_comments(node);
    if (ignores.length)
      this.push_ignores(ignores);
    const result = this._extract_exports(node, module_script);
    if (ignores.length)
      this.pop_ignores();
    return result;
  }
  /**
   * @private
   * @param {import('estree').ExportDefaultDeclaration | import('estree').ExportNamedDeclaration | import('estree').ExportAllDeclaration} node
   * @param {boolean} module_script
   */
  _extract_exports(node, module_script) {
    if (node.type === "ExportDefaultDeclaration") {
      return this.error(
        /** @type {any} */
        node,
        compiler_errors_default.default_export
      );
    }
    if (node.type === "ExportNamedDeclaration") {
      if (node.source) {
        if (module_script) {
          this.exports_from.push(node);
        } else {
          this.instance_exports_from.push(node);
        }
        return null;
      }
      if (node.declaration) {
        if (node.declaration.type === "VariableDeclaration") {
          node.declaration.declarations.forEach((declarator) => {
            extract_names(declarator.id).forEach((name8) => {
              var _a;
              const variable = this.var_lookup.get(name8);
              variable.export_name = name8;
              if (((_a = declarator.init) == null ? void 0 : _a.type) === "Literal" && typeof declarator.init.value === "boolean") {
                variable.is_boolean = true;
              }
              if (!module_script && variable.writable && !(variable.referenced || variable.referenced_from_script || variable.subscribable)) {
                this.warn(
                  /** @type {any} */
                  declarator,
                  compiler_warnings_default.unused_export_let(this.name.name, name8)
                );
              }
            });
          });
        } else {
          const { name: name8 } = node.declaration.id;
          const variable = this.var_lookup.get(name8);
          variable.export_name = name8;
        }
        return node.declaration;
      } else {
        node.specifiers.forEach((specifier) => {
          const variable = this.var_lookup.get(specifier.local.name);
          if (variable) {
            variable.export_name = specifier.exported.name;
            if (!module_script && variable.writable && !(variable.referenced || variable.referenced_from_script || variable.subscribable)) {
              this.warn(
                /** @type {any} */
                specifier,
                compiler_warnings_default.unused_export_let(this.name.name, specifier.exported.name)
              );
            }
          }
        });
        return null;
      }
    }
  }
  /** @param {any} script */
  extract_javascript(script) {
    if (!script)
      return null;
    return script.content.body.filter((node) => {
      if (!node)
        return false;
      if (this.hoistable_nodes.has(node))
        return false;
      if (this.reactive_declaration_nodes.has(node))
        return false;
      if (node.type === "ImportDeclaration")
        return false;
      if (node.type === "ExportDeclaration" && node.specifiers.length > 0)
        return false;
      return true;
    });
  }
  walk_module_js() {
    const component = this;
    const script = this.ast.module;
    if (!script)
      return;
    walk(script.content, {
      /** @param {import('estree').Node} node */
      enter(node) {
        if (node.type === "LabeledStatement" && node.label.name === "$") {
          component.warn(
            /** @type {any} */
            node,
            compiler_warnings_default.module_script_reactive_declaration
          );
        }
      }
    });
    const { scope, globals } = create_scopes(script.content);
    this.module_scope = scope;
    scope.declarations.forEach((node, name8) => {
      if (name8[0] === "$") {
        return this.error(
          /** @type {any} */
          node,
          compiler_errors_default.illegal_declaration
        );
      }
      const writable = node.type === "VariableDeclaration" && (node.kind === "var" || node.kind === "let");
      const imported = node.type.startsWith("Import");
      this.add_var(node, {
        name: name8,
        module: true,
        hoistable: true,
        writable,
        imported
      });
    });
    globals.forEach((node, name8) => {
      if (name8[0] === "$") {
        return this.error(
          /** @type {any} */
          node,
          compiler_errors_default.illegal_subscription
        );
      } else {
        this.add_var(node, {
          name: name8,
          global: true,
          hoistable: true
        });
      }
    });
    const { body } = script.content;
    let i = body.length;
    while (--i >= 0) {
      const node = body[i];
      if (node.type === "ImportDeclaration") {
        this.extract_imports(node);
        body.splice(i, 1);
      }
      if (regex_starts_with_term_export.test(node.type)) {
        const replacement = this.extract_exports(node, true);
        if (replacement) {
          body[i] = replacement;
        } else {
          body.splice(i, 1);
        }
      }
    }
  }
  walk_instance_js_pre_template() {
    const script = this.ast.instance;
    if (!script)
      return;
    script.content.body.forEach((node) => {
      if (node.type !== "LabeledStatement")
        return;
      if (node.body.type !== "ExpressionStatement")
        return;
      const { expression } = node.body;
      if (expression.type !== "AssignmentExpression")
        return;
      if (expression.left.type === "MemberExpression")
        return;
      extract_names(expression.left).forEach((name8) => {
        if (!this.var_lookup.has(name8) && name8[0] !== "$") {
          this.injected_reactive_declaration_vars.add(name8);
        }
      });
    });
    const { scope: instance_scope, map, globals } = create_scopes(script.content);
    this.instance_scope = instance_scope;
    this.instance_scope_map = map;
    instance_scope.declarations.forEach((node, name8) => {
      if (name8[0] === "$") {
        return this.error(
          /** @type {any} */
          node,
          compiler_errors_default.illegal_declaration
        );
      }
      const { type } = node;
      this.add_var(node, {
        name: name8,
        initialised: instance_scope.initialised_declarations.has(name8),
        imported: type.startsWith("Import"),
        writable: type === "VariableDeclaration" && (node.kind === "var" || node.kind === "let")
      });
      this.node_for_declaration.set(name8, node);
    });
    const global_keys = Array.from(globals.keys());
    const sorted_globals = [
      ...global_keys.filter((key) => key[0] !== "$"),
      ...global_keys.filter((key) => key[0] === "$")
    ];
    sorted_globals.forEach((name8) => {
      if (this.var_lookup.has(name8))
        return;
      const node = globals.get(name8);
      if (this.injected_reactive_declaration_vars.has(name8)) {
        this.add_var(node, {
          name: name8,
          injected: true,
          writable: true,
          reassigned: true,
          initialised: true
        });
      } else if (is_reserved_keyword(name8)) {
        this.add_var(node, {
          name: name8,
          injected: true
        });
      } else if (name8[0] === "$") {
        if (name8 === "$" || name8[1] === "$") {
          return this.error(
            /** @type {any} */
            node,
            compiler_errors_default.illegal_global(name8)
          );
        }
        this.add_var(node, {
          name: name8,
          injected: true,
          mutated: true,
          writable: true
        });
        this.add_reference(node, name8.slice(1));
        const variable = this.var_lookup.get(name8.slice(1));
        if (variable) {
          variable.subscribable = true;
          variable.referenced_from_script = true;
        }
      } else {
        this.add_var(node, {
          name: name8,
          global: true,
          hoistable: true
        });
      }
    });
    this.track_references_and_mutations();
  }
  walk_instance_js_post_template() {
    const script = this.ast.instance;
    if (!script)
      return;
    this.post_template_walk();
    this.hoist_instance_declarations();
    this.extract_reactive_declarations();
    this.check_if_tags_content_dynamic();
  }
  post_template_walk() {
    const script = this.ast.instance;
    if (!script)
      return;
    const component = this;
    const { content } = script;
    const { instance_scope, instance_scope_map: map } = this;
    let scope = instance_scope;
    const to_remove = [];
    const remove = (parent, prop, index) => {
      to_remove.unshift([parent, prop, index]);
    };
    let scope_updated = false;
    const current_function_stack = [];
    let current_function = null;
    walk(content, {
      /** @type {import('estree-walker').SyncHandler} */
      enter(node, parent, prop, index) {
        if (node.type === "FunctionDeclaration" || node.type === "FunctionExpression") {
          current_function_stack.push(current_function = node);
        }
        if (map.has(node)) {
          scope = map.get(node);
        }
        let deep = false;
        let names = [];
        if (node.type === "AssignmentExpression") {
          if (node.left.type === "ArrayPattern") {
            walk(node.left, {
              /**
               * @param {import('estree').Node} node
               * @param {import('estree').Node} parent
               */
              enter(node2, parent2) {
                if (node2.type === "Identifier" && parent2.type !== "MemberExpression" && (parent2.type !== "AssignmentPattern" || parent2.right !== node2)) {
                  names.push(node2.name);
                }
              }
            });
          } else {
            deep = node.left.type === "MemberExpression";
            names = deep ? [get_object(node.left).name] : extract_names(node.left);
          }
        } else if (node.type === "UpdateExpression") {
          deep = node.argument.type === "MemberExpression";
          const { name: name8 } = get_object(node.argument);
          names.push(name8);
        }
        if (names.length > 0) {
          names.forEach((name8) => {
            let current_scope = scope;
            let declaration;
            while (current_scope) {
              if (current_scope.declarations.has(name8)) {
                declaration = current_scope.declarations.get(name8);
                break;
              }
              current_scope = current_scope.parent;
            }
            if (declaration && /** @type {import('estree').VariableDeclaration} */
            declaration.kind === "const" && !deep) {
              component.error(
                /** @type {any} */
                node,
                {
                  code: "assignment-to-const",
                  message: "You are assigning to a const"
                }
              );
            }
          });
        }
        if (node.type === "ImportDeclaration") {
          component.extract_imports(node);
          remove(parent, prop, index);
          return this.skip();
        }
        if (regex_starts_with_term_export.test(node.type)) {
          const replacement = component.extract_exports(node);
          if (replacement) {
            this.replace(replacement);
          } else {
            remove(parent, prop, index);
          }
          return this.skip();
        }
        component.warn_on_undefined_store_value_references(node, parent, prop, scope);
      },
      /** @param {import('estree').Node} node */
      leave(node) {
        if (node.type === "FunctionDeclaration" || node.type === "FunctionExpression") {
          current_function_stack.pop();
          current_function = current_function_stack[current_function_stack.length - 1];
        }
        if (component.compile_options.dev && component.compile_options.loopGuardTimeout > 0 && (!current_function || !current_function.generator && !current_function.async)) {
          const to_replace_for_loop_protect = component.loop_protect(
            node,
            scope,
            component.compile_options.loopGuardTimeout
          );
          if (to_replace_for_loop_protect) {
            this.replace(to_replace_for_loop_protect);
            scope_updated = true;
          }
        }
        if (map.has(node)) {
          scope = scope.parent;
        }
      }
    });
    for (const [parent, prop, index] of to_remove) {
      if (parent) {
        if (index !== null) {
          parent[prop].splice(index, 1);
        } else {
          delete parent[prop];
        }
      }
    }
    if (scope_updated) {
      const { scope: scope2, map: map2 } = create_scopes(script.content);
      this.instance_scope = scope2;
      this.instance_scope_map = map2;
    }
  }
  track_references_and_mutations() {
    const script = this.ast.instance;
    if (!script)
      return;
    const component = this;
    const { content } = script;
    const { instance_scope, module_scope, instance_scope_map: map } = this;
    let scope = instance_scope;
    walk(content, {
      /**
       * @param {import('estree').Node} node
       * @param {import('estree').Node} parent
       */
      enter(node, parent) {
        if (map.has(node)) {
          scope = map.get(node);
        }
        if (node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
          const assignee = node.type === "AssignmentExpression" ? node.left : node.argument;
          const names = extract_names(
            /** @type {import('estree').Node} */
            assignee
          );
          const deep = assignee.type === "MemberExpression";
          names.forEach((name8) => {
            const scope_owner = scope.find_owner(name8);
            if (scope_owner !== null ? scope_owner === instance_scope : module_scope && module_scope.has(name8)) {
              const variable = component.var_lookup.get(name8);
              variable[deep ? "mutated" : "reassigned"] = true;
            }
          });
        }
        if (is_used_as_reference(node, parent)) {
          const object = get_object(node);
          if (scope.find_owner(object.name) === instance_scope) {
            const variable = component.var_lookup.get(object.name);
            variable.referenced_from_script = true;
          }
        }
      },
      /** @param {import('estree').Node} node */
      leave(node) {
        if (map.has(node)) {
          scope = scope.parent;
        }
      }
    });
  }
  /**
   * @param {import('estree').Node} node
   * @param {import('estree').Node} parent
   * @param {string | number | symbol} prop
   * @param {import('./utils/scope.js').Scope} scope
   */
  warn_on_undefined_store_value_references(node, parent, prop, scope) {
    if (node.type === "LabeledStatement" && node.label.name === "$" && parent.type !== "Program") {
      this.warn(
        /** @type {any} */
        node,
        compiler_warnings_default.non_top_level_reactive_declaration
      );
    }
    if (is_reference(
      /** @type {import('is-reference').NodeWithPropertyDefinition} */
      node,
      /** @type {import('is-reference').NodeWithPropertyDefinition} */
      parent
    )) {
      const object = get_object(node);
      const { name: name8 } = object;
      if (name8[0] === "$") {
        if (!scope.has(name8)) {
          this.warn_if_undefined(name8, object, null);
        }
        if (name8[1] !== "$" && scope.has(name8.slice(1)) && scope.find_owner(name8.slice(1)) !== this.instance_scope) {
          if (!(regex_contains_term_function.test(parent.type) && prop === "params" || parent.type === "VariableDeclarator" && prop === "id")) {
            return this.error(
              /** @type {any} */
              node,
              compiler_errors_default.contextual_store
            );
          }
        }
      }
    }
  }
  /**
   * @param {any} node
   * @param {import('./utils/scope.js').Scope} scope
   * @param {number} timeout
   * @returns {import('estree').Node}
   */
  loop_protect(node, scope, timeout) {
    if (node.type === "WhileStatement" || node.type === "ForStatement" || node.type === "DoWhileStatement") {
      const guard = this.get_unique_name("guard", scope);
      this.used_names.add(guard.name);
      const before = b`const ${guard} = @loop_guard(${timeout})`;
      const inside = b`${guard}();`;
      if (node.body.type !== "BlockStatement") {
        node.body = {
          type: "BlockStatement",
          body: [node.body]
        };
      }
      node.body.body.push(inside[0]);
      return {
        type: "BlockStatement",
        body: [before[0], node]
      };
    }
    return null;
  }
  /** @param {(variable: import('../interfaces.js').Var) => import('estree').Node[]} get_insert */
  rewrite_props(get_insert) {
    if (!this.ast.instance)
      return;
    const component = this;
    const { instance_scope, instance_scope_map: map } = this;
    let scope = instance_scope;
    walk(this.ast.instance.content, {
      /** @param {import('estree').Node} node */
      enter(node) {
        if (regex_contains_term_function.test(node.type)) {
          return this.skip();
        }
        if (map.has(node)) {
          scope = map.get(node);
        }
        if (node.type === "ExportNamedDeclaration" && node.declaration) {
          return this.replace(node.declaration);
        }
        if (node.type === "VariableDeclaration") {
          if (node.kind === "var" || scope === instance_scope) {
            let add_new_props = function(exported, local, default_value) {
              props.push({
                type: "Property",
                method: false,
                shorthand: false,
                computed: false,
                kind: "init",
                key: exported,
                value: default_value ? {
                  type: "AssignmentPattern",
                  left: local,
                  right: default_value
                } : local
              });
            };
            const inserts = [];
            const props = [];
            for (let index = 0; index < node.declarations.length; index++) {
              const declarator = node.declarations[index];
              if (declarator.id.type !== "Identifier") {
                let get_new_name = function(local) {
                  const variable = component.var_lookup.get(local.name);
                  if (variable.subscribable) {
                    inserts.push(get_insert(variable));
                  }
                  if (variable.export_name && variable.writable) {
                    const alias_name = component.get_unique_name(local.name);
                    add_new_props(
                      { type: "Identifier", name: variable.export_name },
                      local,
                      alias_name
                    );
                    return alias_name;
                  }
                  return local;
                }, rename_identifiers = function(param) {
                  switch (param.type) {
                    case "ObjectPattern": {
                      const handle_prop = (prop) => {
                        if (prop.type === "RestElement") {
                          rename_identifiers(prop);
                        } else if (prop.value.type === "Identifier") {
                          prop.value = get_new_name(prop.value);
                        } else {
                          rename_identifiers(
                            /** @type {import('estree').Pattern} */
                            prop.value
                          );
                        }
                      };
                      param.properties.forEach(handle_prop);
                      break;
                    }
                    case "ArrayPattern": {
                      const handle_element = (element, index2, array) => {
                        if (element) {
                          if (element.type === "Identifier") {
                            array[index2] = get_new_name(element);
                          } else {
                            rename_identifiers(element);
                          }
                        }
                      };
                      param.elements.forEach(handle_element);
                      break;
                    }
                    case "RestElement":
                      if (param.argument.type === "Identifier") {
                        param.argument = get_new_name(param.argument);
                      } else {
                        rename_identifiers(param.argument);
                      }
                      break;
                    case "AssignmentPattern":
                      if (param.left.type === "Identifier") {
                        param.left = get_new_name(param.left);
                      } else {
                        rename_identifiers(param.left);
                      }
                      break;
                  }
                };
                rename_identifiers(declarator.id);
              } else {
                const { name: name8 } = declarator.id;
                const variable = component.var_lookup.get(name8);
                const is_props = variable.export_name && variable.writable;
                if (is_props) {
                  add_new_props(
                    { type: "Identifier", name: variable.export_name },
                    declarator.id,
                    declarator.init
                  );
                  node.declarations.splice(index--, 1);
                }
                if (variable.subscribable && (is_props || declarator.init)) {
                  inserts.push(get_insert(variable));
                }
              }
            }
            this.replace(
              /** @type {any} */
              b`
							${node.declarations.length ? node : null}
							${props.length > 0 && b`let { ${props} } = $$props;`}
							${inserts}
						`
            );
            return this.skip();
          }
        }
      },
      /** @param {import('estree').Node} node */
      leave(node) {
        if (map.has(node)) {
          scope = scope.parent;
        }
      }
    });
  }
  hoist_instance_declarations() {
    const { hoistable_nodes, var_lookup, injected_reactive_declaration_vars, imports } = this;
    const top_level_function_declarations = /* @__PURE__ */ new Map();
    const { body } = this.ast.instance.content;
    for (let i = 0; i < body.length; i += 1) {
      const node = body[i];
      if (node.type === "VariableDeclaration") {
        const all_hoistable = node.declarations.every((d) => {
          if (!d.init)
            return false;
          if (d.init.type !== "Literal")
            return false;
          if (node.kind !== "const" && this.compile_options.dev)
            return false;
          for (const name8 of extract_names(d.id)) {
            const v = this.var_lookup.get(name8);
            if (v.reassigned)
              return false;
            if (v.export_name)
              return false;
            if (this.vars.find((variable) => variable.name === name8 && variable.module)) {
              return false;
            }
          }
          return true;
        });
        if (all_hoistable) {
          node.declarations.forEach((d) => {
            for (const name8 of extract_names(d.id)) {
              this.var_lookup.get(name8).hoistable = true;
            }
          });
          hoistable_nodes.add(node);
          body.splice(i--, 1);
          this.fully_hoisted.push(node);
        }
      }
      if (node.type === "ExportNamedDeclaration" && node.declaration && node.declaration.type === "FunctionDeclaration") {
        top_level_function_declarations.set(node.declaration.id.name, node);
      }
      if (node.type === "FunctionDeclaration") {
        top_level_function_declarations.set(node.id.name, node);
      }
    }
    const checked = /* @__PURE__ */ new Set();
    const walking = /* @__PURE__ */ new Set();
    const is_hoistable = (fn_declaration) => {
      if (fn_declaration.type === "ExportNamedDeclaration") {
        fn_declaration = fn_declaration.declaration;
      }
      const instance_scope = this.instance_scope;
      let scope = this.instance_scope;
      const map = this.instance_scope_map;
      let hoistable = true;
      walking.add(fn_declaration);
      walk(fn_declaration, {
        /** @type {import('estree-walker').SyncHandler} */
        enter(node, parent) {
          if (!hoistable)
            return this.skip();
          if (map.has(node)) {
            scope = map.get(node);
          }
          if (is_reference(
            /** @type {import('is-reference').NodeWithPropertyDefinition} */
            node,
            /** @type {import('is-reference').NodeWithPropertyDefinition} */
            parent
          )) {
            const { name: name8 } = flatten_reference(node);
            const owner = scope.find_owner(name8);
            if (injected_reactive_declaration_vars.has(name8)) {
              hoistable = false;
            } else if (name8[0] === "$" && !owner) {
              hoistable = false;
            } else if (owner === instance_scope) {
              const variable = var_lookup.get(name8);
              if (variable.reassigned || variable.mutated)
                hoistable = false;
              if (name8 === fn_declaration.id.name)
                return;
              if (variable.hoistable)
                return;
              if (top_level_function_declarations.has(name8)) {
                const other_declaration = top_level_function_declarations.get(name8);
                if (walking.has(other_declaration)) {
                  hoistable = false;
                } else if (other_declaration.type === "ExportNamedDeclaration" && walking.has(other_declaration.declaration)) {
                  hoistable = false;
                } else if (!is_hoistable(other_declaration)) {
                  hoistable = false;
                }
              } else {
                hoistable = false;
              }
            }
            this.skip();
          }
        },
        /** @param {import('estree').Node} node */
        leave(node) {
          if (map.has(node)) {
            scope = scope.parent;
          }
        }
      });
      checked.add(fn_declaration);
      walking.delete(fn_declaration);
      return hoistable;
    };
    for (const [name8, node] of top_level_function_declarations) {
      if (is_hoistable(node)) {
        const variable = this.var_lookup.get(name8);
        variable.hoistable = true;
        hoistable_nodes.add(node);
        const i = body.indexOf(node);
        body.splice(i, 1);
        this.fully_hoisted.push(node);
      }
    }
    for (const { specifiers } of imports) {
      for (const specifier of specifiers) {
        const variable = var_lookup.get(specifier.local.name);
        if (!variable.mutated || variable.subscribable) {
          variable.hoistable = true;
        }
      }
    }
  }
  extract_reactive_declarations() {
    const component = this;
    const unsorted_reactive_declarations = [];
    this.ast.instance.content.body.forEach((node) => {
      const ignores = extract_svelte_ignore_from_comments(node);
      if (ignores.length)
        this.push_ignores(ignores);
      if (node.type === "LabeledStatement" && node.label.name === "$") {
        this.reactive_declaration_nodes.add(node);
        const assignees = /* @__PURE__ */ new Set();
        const assignee_nodes = /* @__PURE__ */ new Set();
        const dependencies = /* @__PURE__ */ new Set();
        const module_dependencies = /* @__PURE__ */ new Set();
        let scope = this.instance_scope;
        const { declarations: outset_scope_decalarations } = this.instance_scope;
        const map = this.instance_scope_map;
        walk(node.body, {
          /** @type {import('estree-walker').SyncHandler} */
          enter(node2, parent) {
            if (node2.type === "VariableDeclaration" && node2.kind === "var") {
              const is_var_in_outset = node2.declarations.some(
                /** @param {import('estree').VariableDeclarator} declaration */
                (declaration2) => {
                  const names = extract_names(declaration2.id);
                  return !!names.find(
                    /** @param {string} name */
                    (name8) => {
                      const var_node = outset_scope_decalarations.get(name8);
                      return var_node === node2;
                    }
                  );
                }
              );
              if (is_var_in_outset) {
                return component.error(
                  /** @type {any} */
                  node2,
                  compiler_errors_default.invalid_var_declaration
                );
              }
            }
            if (map.has(node2)) {
              scope = map.get(node2);
            }
            if (node2.type === "AssignmentExpression") {
              const left = get_object(node2.left);
              extract_identifiers(left).forEach((node3) => {
                assignee_nodes.add(node3);
                assignees.add(node3.name);
              });
              if (node2.operator !== "=") {
                dependencies.add(left.name);
              }
            } else if (node2.type === "UpdateExpression") {
              const identifier = get_object(node2.argument);
              assignees.add(identifier.name);
            } else if (is_reference(
              /** @type {import('is-reference').NodeWithPropertyDefinition} */
              node2,
              /** @type {import('is-reference').NodeWithPropertyDefinition} */
              parent
            )) {
              const identifier = get_object(node2);
              if (!assignee_nodes.has(identifier)) {
                const { name: name8 } = identifier;
                const owner = scope.find_owner(name8);
                const variable = component.var_lookup.get(name8);
                let should_add_as_dependency = true;
                if (variable) {
                  variable.is_reactive_dependency = true;
                  if (variable.module && variable.writable) {
                    should_add_as_dependency = false;
                    module_dependencies.add(name8);
                  }
                }
                const is_writable_or_mutated = variable && (variable.writable || variable.mutated);
                if (should_add_as_dependency && (!owner || owner === component.instance_scope) && (name8[0] === "$" || is_writable_or_mutated)) {
                  dependencies.add(name8);
                }
              }
              this.skip();
            }
          },
          /** @param {import('estree').Node} node */
          leave(node2) {
            if (map.has(node2)) {
              scope = scope.parent;
            }
          }
        });
        if (module_dependencies.size > 0 && dependencies.size === 0) {
          component.warn(
            /** @type {any} */
            node.body,
            compiler_warnings_default.module_script_variable_reactive_declaration(
              Array.from(module_dependencies)
            )
          );
        }
        const { expression } = (
          /** @type {import('estree').ExpressionStatement} */
          node.body
        );
        const declaration = expression && /** @type {import('estree').AssignmentExpression} */
        expression.left;
        unsorted_reactive_declarations.push({
          assignees,
          dependencies,
          node,
          declaration
        });
      }
      if (ignores.length)
        this.pop_ignores();
    });
    const lookup = /* @__PURE__ */ new Map();
    unsorted_reactive_declarations.forEach((declaration) => {
      declaration.assignees.forEach((name8) => {
        if (!lookup.has(name8)) {
          lookup.set(name8, []);
        }
        lookup.get(name8).push(declaration);
      });
    });
    const cycle = check_graph_for_cycles(
      unsorted_reactive_declarations.reduce((acc, declaration) => {
        declaration.assignees.forEach((v) => {
          declaration.dependencies.forEach((w) => {
            if (!declaration.assignees.has(w)) {
              acc.push([v, w]);
            }
          });
        });
        return acc;
      }, [])
    );
    if (cycle && cycle.length) {
      const declaration_list = lookup.get(cycle[0]);
      const declaration = declaration_list[0];
      return this.error(declaration.node, compiler_errors_default.cyclical_reactive_declaration(cycle));
    }
    const add_declaration = (declaration) => {
      if (this.reactive_declarations.includes(declaration))
        return;
      declaration.dependencies.forEach((name8) => {
        if (declaration.assignees.has(name8))
          return;
        const earlier_declarations = lookup.get(name8);
        if (earlier_declarations) {
          earlier_declarations.forEach(add_declaration);
        }
      });
      this.reactive_declarations.push(declaration);
    };
    unsorted_reactive_declarations.forEach(add_declaration);
  }
  check_if_tags_content_dynamic() {
    this.tags.forEach((tag2) => {
      tag2.check_if_content_dynamic();
    });
  }
  /**
   * @param {string} name
   * @param {any} node
   * @param {import('./nodes/shared/TemplateScope.js').default} template_scope
   * @param {import("./nodes/shared/Node.js").default} [owner]
   */
  warn_if_undefined(name8, node, template_scope, owner) {
    if (name8[0] === "$") {
      if (name8 === "$" || name8[1] === "$" && !is_reserved_keyword(name8)) {
        return this.error(node, compiler_errors_default.illegal_global(name8));
      }
      this.has_reactive_assignments = true;
      if (is_reserved_keyword(name8))
        return;
      name8 = name8.slice(1);
    }
    if (this.var_lookup.has(name8) && !this.var_lookup.get(name8).global)
      return;
    if (template_scope && template_scope.names.has(name8))
      return;
    if (globals_default.has(name8) && node.type !== "InlineComponent")
      return;
    function has_out_of_scope_let() {
      for (let parent = owner.parent; parent; parent = parent.parent) {
        if (parent.type === "InlineComponent") {
          const { let_attributes } = parent;
          for (const attr of let_attributes) {
            if (
              // @ts-expect-error
              // TODO extract_names only considers patterns but let attributes return expressions
              attr.expression && extract_names(attr.expression).includes(name8) || attr.name === name8
            )
              return true;
          }
        }
      }
      return false;
    }
    if (owner && has_out_of_scope_let()) {
      return this.warn(node, {
        code: "missing-declaration",
        message: `let:${name8} declared on parent component cannot be used inside named slot`
      });
    }
    this.warn(node, compiler_warnings_default.missing_declaration(name8, !!this.ast.instance));
  }
  /** @param {any} ignores */
  push_ignores(ignores) {
    this.ignores = new Set(this.ignores || []);
    add_to_set(this.ignores, ignores);
    this.ignore_stack.push(this.ignores);
  }
  pop_ignores() {
    this.ignore_stack.pop();
    this.ignores = this.ignore_stack[this.ignore_stack.length - 1];
  }
};
var regex_valid_tag_name = /^[a-zA-Z][a-zA-Z0-9]*-[a-zA-Z0-9-]+$/;
function process_component_options(component, nodes) {
  const component_options = {
    immutable: component.compile_options.immutable || false,
    accessors: "accessors" in component.compile_options ? component.compile_options.accessors : !!component.compile_options.customElement,
    preserveWhitespace: !!component.compile_options.preserveWhitespace,
    namespace: component.compile_options.namespace
  };
  const node = nodes.find((node2) => node2.name === "svelte:options");
  function get_value2(attribute, { code, message }) {
    const { value } = attribute;
    const chunk = value[0];
    if (!chunk)
      return true;
    if (value.length > 1) {
      return component.error(attribute, { code, message });
    }
    if (chunk.type === "Text")
      return chunk.data;
    if (chunk.expression.type !== "Literal") {
      return component.error(attribute, { code, message });
    }
    return chunk.expression.value;
  }
  if (node) {
    node.attributes.forEach((attribute) => {
      var _a, _b, _c, _d;
      if (attribute.type === "Attribute") {
        let parse_tag = function(attribute2, tag2) {
          if (typeof tag2 !== "string" && tag2 !== null) {
            return component.error(attribute2, compiler_errors_default.invalid_tag_attribute);
          }
          if (tag2 && !regex_valid_tag_name.test(tag2)) {
            return component.error(attribute2, compiler_errors_default.invalid_tag_property);
          }
          if (tag2 && !component.compile_options.customElement) {
            component.warn(attribute2, compiler_warnings_default.missing_custom_element_compile_options);
          }
          component_options.customElement = component_options.customElement || /** @type {any} */
          {};
          component_options.customElement.tag = tag2;
        };
        const { name: name8 } = attribute;
        switch (name8) {
          case "tag": {
            component.warn(attribute, compiler_warnings_default.tag_option_deprecated);
            parse_tag(attribute, get_value2(attribute, compiler_errors_default.invalid_tag_attribute));
            break;
          }
          case "customElement": {
            component_options.customElement = component_options.customElement || /** @type {any} */
            {};
            const { value } = attribute;
            if (value[0].type === "MustacheTag" && ((_a = value[0].expression) == null ? void 0 : _a.value) === null) {
              component_options.customElement.tag = null;
              break;
            } else if (value[0].type === "Text") {
              parse_tag(attribute, get_value2(attribute, compiler_errors_default.invalid_tag_attribute));
              break;
            } else if (value[0].expression.type !== "ObjectExpression") {
              return component.error(attribute, compiler_errors_default.invalid_customElement_attribute);
            }
            const tag2 = value[0].expression.properties.find((prop) => prop.key.name === "tag");
            if (tag2) {
              parse_tag(tag2, (_b = tag2.value) == null ? void 0 : _b.value);
            } else {
              return component.error(attribute, compiler_errors_default.invalid_customElement_attribute);
            }
            const props = value[0].expression.properties.find((prop) => prop.key.name === "props");
            if (props) {
              const error2 = () => component.error(attribute, compiler_errors_default.invalid_props_attribute);
              if (((_c = props.value) == null ? void 0 : _c.type) !== "ObjectExpression") {
                return error2();
              }
              component_options.customElement.props = {};
              for (
                const property of
                /** @type {import('estree').ObjectExpression} */
                props.value.properties
              ) {
                if (property.type !== "Property" || property.computed || property.key.type !== "Identifier" || property.value.type !== "ObjectExpression") {
                  return error2();
                }
                component_options.customElement.props[property.key.name] = {};
                for (const prop of property.value.properties) {
                  if (prop.type !== "Property" || prop.computed || prop.key.type !== "Identifier" || prop.value.type !== "Literal") {
                    return error2();
                  }
                  if (["reflect", "attribute", "type"].indexOf(prop.key.name) === -1 || prop.key.name === "type" && ["String", "Number", "Boolean", "Array", "Object"].indexOf(
                    /** @type {string} */
                    prop.value.value
                  ) === -1 || prop.key.name === "reflect" && typeof prop.value.value !== "boolean" || prop.key.name === "attribute" && typeof prop.value.value !== "string") {
                    return error2();
                  }
                  component_options.customElement.props[property.key.name][prop.key.name] = prop.value.value;
                }
              }
            }
            const shadow = value[0].expression.properties.find(
              (prop) => prop.key.name === "shadow"
            );
            if (shadow) {
              const shadowdom = (_d = shadow.value) == null ? void 0 : _d.value;
              if (shadowdom !== "open" && shadowdom !== "none") {
                return component.error(shadow, compiler_errors_default.invalid_shadow_attribute);
              }
              component_options.customElement.shadow = shadowdom;
            }
            const extend = value[0].expression.properties.find(
              (prop) => prop.key.name === "extend"
            );
            if (extend == null ? void 0 : extend.value) {
              component_options.customElement.extend = extend.value;
            }
            break;
          }
          case "namespace": {
            const ns = get_value2(attribute, compiler_errors_default.invalid_namespace_attribute);
            if (typeof ns !== "string") {
              return component.error(attribute, compiler_errors_default.invalid_namespace_attribute);
            }
            if (valid_namespaces.indexOf(ns) === -1) {
              const match = fuzzymatch(ns, valid_namespaces);
              return component.error(
                attribute,
                compiler_errors_default.invalid_namespace_property(ns, match)
              );
            }
            component_options.namespace = ns;
            break;
          }
          case "accessors":
          case "immutable":
          case "preserveWhitespace": {
            const value = get_value2(attribute, compiler_errors_default.invalid_attribute_value(name8));
            if (typeof value !== "boolean") {
              return component.error(attribute, compiler_errors_default.invalid_attribute_value(name8));
            }
            component_options[name8] = value;
            break;
          }
          default:
            return component.error(
              attribute,
              compiler_errors_default.invalid_options_attribute_unknown(name8)
            );
        }
      } else {
        return component.error(attribute, compiler_errors_default.invalid_options_attribute);
      }
    });
  }
  return component_options;
}
function get_relative_path(from, to) {
  const from_parts = from.split(/[/\\]/);
  const to_parts = to.split(/[/\\]/);
  from_parts.pop();
  while (from_parts[0] === to_parts[0]) {
    from_parts.shift();
    to_parts.shift();
  }
  if (from_parts.length) {
    let i = from_parts.length;
    while (i--)
      from_parts[i] = "..";
  }
  return from_parts.concat(to_parts).join("/");
}
function get_basename(filename) {
  return filename.split(/[/\\]/).pop();
}
function get_sourcemap_source_filename(compile_options) {
  if (!compile_options.filename)
    return null;
  return compile_options.outputFilename ? get_relative_path(compile_options.outputFilename, compile_options.filename) : get_basename(compile_options.filename);
}

// node_modules/svelte/src/compiler/compile/utils/get_name_from_filename.js
var regex_percentage_characters = /%/g;
var regex_file_ending = /\.[^.]+$/;
var regex_repeated_invalid_variable_identifier_characters = /[^a-zA-Z_$0-9]+/g;
var regex_starts_with_digit = /^(\d)/;
var regex_may_starts_or_ends_with_underscore = /^_?(.+?)_?$/;
function get_name_from_filename(filename) {
  if (!filename)
    return null;
  const parts = filename.split(/[/\\]/).map(encodeURI);
  if (parts.length > 1) {
    const index_match = parts[parts.length - 1].match(/^index(\.\w+)/);
    if (index_match) {
      parts.pop();
      parts[parts.length - 1] += index_match[1];
    }
  }
  const base = parts.pop().replace(regex_percentage_characters, "u").replace(regex_file_ending, "").replace(regex_repeated_invalid_variable_identifier_characters, "_").replace(regex_may_starts_or_ends_with_underscore, "$1").replace(regex_starts_with_digit, "_$1");
  if (!base) {
    throw new Error(`Could not derive component name from file ${filename}`);
  }
  return base[0].toUpperCase() + base.slice(1);
}

// node_modules/svelte/src/compiler/compile/index.js
var valid_options = [
  "name",
  "filename",
  "sourcemap",
  "enableSourcemap",
  "generate",
  "errorMode",
  "varsReport",
  "outputFilename",
  "cssOutputFilename",
  "sveltePath",
  "dev",
  "accessors",
  "immutable",
  "hydratable",
  "legacy",
  "customElement",
  "namespace",
  "tag",
  "css",
  "loopGuardTimeout",
  "preserveComments",
  "preserveWhitespace",
  "cssHash",
  "discloseVersion"
];
var valid_css_values = [true, false, "injected", "external", "none"];
var regex_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
var regex_starts_with_lowercase_character = /^[a-z]/;
var warned_of_format = false;
var warned_boolean_css = false;
function validate_options(options, warnings) {
  if (
    /** @type {any} */
    options.format
  ) {
    if (!warned_of_format) {
      warned_of_format = true;
      console.warn(
        'The format option has been removed in Svelte 4, the compiler only outputs ESM now. Remove "format" from your compiler options. If you did not set this yourself, bump the version of your bundler plugin (vite-plugin-svelte/rollup-plugin-svelte/svelte-loader)'
      );
    }
    delete /** @type {any} */
    options.format;
  }
  const { name: name8, filename, loopGuardTimeout, dev, namespace, css } = options;
  Object.keys(options).forEach((key) => {
    if (!valid_options.includes(key)) {
      const match = fuzzymatch(key, valid_options);
      let message = `Unrecognized option '${key}'`;
      if (match)
        message += ` (did you mean '${match}'?)`;
      throw new Error(message);
    }
  });
  if (name8 && !regex_valid_identifier.test(name8)) {
    throw new Error(`options.name must be a valid identifier (got '${name8}')`);
  }
  if (name8 && regex_starts_with_lowercase_character.test(name8)) {
    const message = "options.name should be capitalised";
    warnings.push({
      code: "options-lowercase-name",
      message,
      filename,
      toString: () => message
    });
  }
  if (loopGuardTimeout && !dev) {
    const message = "options.loopGuardTimeout is for options.dev = true only";
    warnings.push({
      code: "options-loop-guard-timeout",
      message,
      filename,
      toString: () => message
    });
  }
  if (css === true || css === false) {
    options.css = css === true ? "injected" : "external";
    if (!warned_boolean_css) {
      console.warn(
        `compilerOptions.css as a boolean is deprecated. Use '${options.css}' instead of ${css}.`
      );
      warned_boolean_css = true;
    }
  }
  if (!valid_css_values.includes(options.css)) {
    throw new Error(
      `compilerOptions.css must be 'injected', 'external' or 'none' (got '${options.css}').`
    );
  }
  if (namespace && valid_namespaces.indexOf(namespace) === -1) {
    const match = fuzzymatch(namespace, valid_namespaces);
    if (match) {
      throw new Error(`Invalid namespace '${namespace}' (did you mean '${match}'?)`);
    } else {
      throw new Error(`Invalid namespace '${namespace}'`);
    }
  }
  if (options.discloseVersion == void 0) {
    options.discloseVersion = true;
  }
}
function compile(source, options = {}) {
  options = Object.assign(
    { generate: "dom", dev: false, enableSourcemap: true, css: "injected" },
    options
  );
  const stats = new Stats();
  const warnings = [];
  validate_options(options, warnings);
  stats.start("parse");
  const ast = parse11(source, options);
  stats.stop("parse");
  stats.start("create component");
  const component = new Component(
    ast,
    source,
    options.name || get_name_from_filename(options.filename) || "Component",
    options,
    stats,
    warnings
  );
  stats.stop("create component");
  const result = options.generate === false ? null : options.generate === "ssr" ? ssr(component, options) : dom(component, options);
  return component.generate(result);
}

// node_modules/svelte/src/compiler/preprocess/decode_sourcemap.js
var import_sourcemap_codec = __toESM(require_sourcemap_codec_umd(), 1);
function decoded_sourcemap_from_generator(generator) {
  let previous_generated_line = 1;
  const converted_mappings = [[]];
  let result_line;
  let result_segment;
  let mapping;
  const source_idx = generator._sources.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
  const name_idx = generator._names.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
  const mappings = generator._mappings.toArray();
  result_line = converted_mappings[0];
  for (let i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    if (mapping.generatedLine > previous_generated_line) {
      while (mapping.generatedLine > previous_generated_line) {
        converted_mappings.push([]);
        previous_generated_line++;
      }
      result_line = converted_mappings[mapping.generatedLine - 1];
    } else if (i > 0) {
      const previous_mapping = mappings[i - 1];
      if (
        // sorted by selectivity
        mapping.generatedColumn === previous_mapping.generatedColumn && mapping.originalColumn === previous_mapping.originalColumn && mapping.name === previous_mapping.name && mapping.generatedLine === previous_mapping.generatedLine && mapping.originalLine === previous_mapping.originalLine && mapping.source === previous_mapping.source
      ) {
        continue;
      }
    }
    result_line.push([mapping.generatedColumn]);
    result_segment = result_line[result_line.length - 1];
    if (mapping.source != null) {
      result_segment.push(
        ...[source_idx[mapping.source], mapping.originalLine - 1, mapping.originalColumn]
      );
      if (mapping.name != null) {
        result_segment.push(name_idx[mapping.name]);
      }
    }
  }
  const map = {
    version: generator._version,
    sources: generator._sources.toArray(),
    names: generator._names.toArray(),
    mappings: converted_mappings
  };
  if (generator._file != null) {
    map.file = generator._file;
  }
  return map;
}
function decode_map(processed) {
  let decoded_map = typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map;
  if (typeof decoded_map.mappings === "string") {
    decoded_map.mappings = (0, import_sourcemap_codec.decode)(decoded_map.mappings);
  }
  if (decoded_map._mappings && decoded_map.constructor.name === "SourceMapGenerator") {
    decoded_map = decoded_sourcemap_from_generator(decoded_map);
  }
  return decoded_map;
}

// node_modules/svelte/src/compiler/preprocess/replace_in_code.js
function slice_source(code_slice, offset, { file_basename, filename, get_location }) {
  return {
    source: code_slice,
    get_location: (index) => get_location(index + offset),
    file_basename,
    filename
  };
}
function calculate_replacements(re, get_replacement, source) {
  const replacements = [];
  source.replace(re, (...match) => {
    replacements.push(
      get_replacement(...match).then((replacement) => {
        const matched_string = match[0];
        const offset = match[match.length - 2];
        return { offset, length: matched_string.length, replacement };
      })
    );
    return "";
  });
  return Promise.all(replacements);
}
function perform_replacements(replacements, source) {
  const out = new MappedCode();
  let last_end = 0;
  for (const { offset, length, replacement } of replacements) {
    const unchanged_prefix = MappedCode.from_source(
      slice_source(source.source.slice(last_end, offset), last_end, source)
    );
    out.concat(unchanged_prefix).concat(replacement);
    last_end = offset + length;
  }
  const unchanged_suffix = MappedCode.from_source(
    slice_source(source.source.slice(last_end), last_end, source)
  );
  return out.concat(unchanged_suffix);
}
async function replace_in_code(regex, get_replacement, location) {
  const replacements = await calculate_replacements(regex, get_replacement, location.source);
  return perform_replacements(replacements, location);
}

// node_modules/svelte/src/compiler/preprocess/index.js
var regex_filepath_separator = /[/\\]/;
function get_file_basename(filename) {
  return filename.split(regex_filepath_separator).pop();
}
var PreprocessResult = class {
  /**
   *
   * @param {string} source
   * @param {string} [filename]
   */
  constructor(source, filename) {
    /** @type {string} */
    __publicField(this, "source");
    /** @type {string | undefined} */
    __publicField(this, "filename");
    // sourcemap_list is sorted in reverse order from last map (index 0) to first map (index -1)
    // so we use sourcemap_list.unshift() to add new maps
    // https://github.com/ampproject/remapping#multiple-transformations-of-a-file
    /**
     * @default []
     * @type {Array<import('@ampproject/remapping').DecodedSourceMap | import('@ampproject/remapping').RawSourceMap>}
     */
    __publicField(this, "sourcemap_list", []);
    /**
     * @default []
     * @type {string[]}
     */
    __publicField(this, "dependencies", []);
    /**
     * @type {string}
     */
    __publicField(this, "file_basename");
    /**
     * @type {ReturnType<typeof getLocator>}
     */
    __publicField(this, "get_location");
    this.source = source;
    this.filename = filename;
    this.update_source({ string: source });
    this.file_basename = filename == null ? null : get_file_basename(filename);
  }
  /**
   * @param {import('./private.js').SourceUpdate} opts
   */
  update_source({ string: source, map, dependencies }) {
    if (source != null) {
      this.source = source;
      this.get_location = getLocator(source);
    }
    if (map) {
      this.sourcemap_list.unshift(map);
    }
    if (dependencies) {
      this.dependencies.push(...dependencies);
    }
  }
  /**
   * @returns {import('./public.js').Processed}
   */
  to_processed() {
    const map = combine_sourcemaps(this.file_basename, this.sourcemap_list);
    return {
      // TODO return separated output, in future version where svelte.compile supports it:
      // style: { code: styleCode, map: styleMap },
      // script { code: scriptCode, map: scriptMap },
      // markup { code: markupCode, map: markupMap },
      code: this.source,
      dependencies: [...new Set(this.dependencies)],
      map,
      toString: () => this.source
    };
  }
};
function processed_content_to_code(processed, location, file_basename) {
  let decoded_map;
  if (processed.map) {
    decoded_map = decode_map(processed);
    if (decoded_map.sources) {
      const source_index = decoded_map.sources.indexOf(file_basename);
      if (source_index !== -1) {
        sourcemap_add_offset(decoded_map, location, source_index);
      }
    }
  }
  return MappedCode.from_processed(processed.code, decoded_map);
}
function processed_tag_to_code(processed, tag_name, original_attributes, generated_attributes, source) {
  const { file_basename, get_location } = source;
  const build_mapped_code = (code, offset) => MappedCode.from_source(slice_source(code, offset, source));
  const original_tag_open = `<${tag_name}${original_attributes}>`;
  const tag_open = `<${tag_name}${generated_attributes}>`;
  let tag_open_code;
  if (original_tag_open.length !== tag_open.length) {
    const mappings = [
      [
        // start of tag
        [0, 0, 0, 0],
        // end of tag start
        [`<${tag_name}`.length, 0, 0, `<${tag_name}`.length]
      ]
    ];
    const line = tag_open.split("\n").length - 1;
    const column = tag_open.length - (line === 0 ? 0 : tag_open.lastIndexOf("\n")) - 1;
    while (mappings.length <= line) {
      mappings.push([[0, 0, 0, `<${tag_name}`.length]]);
    }
    mappings[line].push([
      column,
      0,
      original_tag_open.split("\n").length - 1,
      original_tag_open.length - original_tag_open.lastIndexOf("\n") - 1
    ]);
    const map = {
      version: 3,
      names: [],
      sources: [file_basename],
      mappings
    };
    sourcemap_add_offset(map, get_location(0), 0);
    tag_open_code = MappedCode.from_processed(tag_open, map);
  } else {
    tag_open_code = build_mapped_code(tag_open, 0);
  }
  const tag_close = `</${tag_name}>`;
  const tag_close_code = build_mapped_code(
    tag_close,
    original_tag_open.length + source.source.length
  );
  parse_attached_sourcemap(processed, tag_name);
  const content_code = processed_content_to_code(
    processed,
    get_location(original_tag_open.length),
    file_basename
  );
  return tag_open_code.concat(content_code).concat(tag_close_code);
}
var attribute_pattern = /([\w-$]+\b)(?:=(?:"([^"]*)"|'([^']*)'|(\S+)))?/g;
function parse_tag_attributes(str) {
  const attrs = {};
  let match;
  while ((match = attribute_pattern.exec(str)) !== null) {
    const name8 = match[1];
    const value = match[2] || match[3] || match[4];
    attrs[name8] = !value || value;
  }
  return attrs;
}
function stringify_tag_attributes(attributes) {
  if (!attributes)
    return;
  let value = Object.entries(attributes).map(([key, value2]) => value2 === true ? key : `${key}="${value2}"`).join(" ");
  if (value) {
    value = " " + value;
  }
  return value;
}
var regex_style_tags = /<!--[^]*?-->|<style((?:\s+[^=>'"\/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"\/]+)*\s*)(?:\/>|>([\S\s]*?)<\/style>)/g;
var regex_script_tags = /<!--[^]*?-->|<script((?:\s+[^=>'"\/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"\/]+)*\s*)(?:\/>|>([\S\s]*?)<\/script>)/g;
async function process_tag(tag_name, preprocessor, source) {
  const { filename, source: markup } = source;
  const tag_regex = tag_name === "style" ? regex_style_tags : regex_script_tags;
  const dependencies = [];
  async function process_single_tag(tag_with_content, attributes = "", content = "", tag_offset) {
    const no_change = () => MappedCode.from_source(slice_source(tag_with_content, tag_offset, source));
    if (!attributes && !content)
      return no_change();
    const processed = await preprocessor({
      content: content || "",
      attributes: parse_tag_attributes(attributes || ""),
      markup,
      filename
    });
    if (!processed)
      return no_change();
    if (processed.dependencies)
      dependencies.push(...processed.dependencies);
    if (!processed.map && processed.code === content)
      return no_change();
    return processed_tag_to_code(
      processed,
      tag_name,
      attributes,
      stringify_tag_attributes(processed.attributes) ?? attributes,
      slice_source(content, tag_offset, source)
    );
  }
  const { string, map } = await replace_in_code(tag_regex, process_single_tag, source);
  return { string, map, dependencies };
}
async function process_markup(process2, source) {
  const processed = await process2({
    content: source.source,
    filename: source.filename
  });
  if (processed) {
    return {
      string: processed.code,
      map: processed.map ? (
        // TODO: can we use decode_sourcemap?
        typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map
      ) : void 0,
      dependencies: processed.dependencies
    };
  } else {
    return {};
  }
}
async function preprocess(source, preprocessor, options) {
  const filename = options && options.filename || /** @type {any} */
  preprocessor.filename;
  const preprocessors = preprocessor ? Array.isArray(preprocessor) ? preprocessor : [preprocessor] : [];
  const result = new PreprocessResult(source, filename);
  for (const preprocessor2 of preprocessors) {
    if (preprocessor2.markup) {
      result.update_source(await process_markup(preprocessor2.markup, result));
    }
    if (preprocessor2.script) {
      result.update_source(await process_tag("script", preprocessor2.script, result));
    }
    if (preprocessor2.style) {
      result.update_source(await process_tag("style", preprocessor2.style, result));
    }
  }
  return result.to_processed();
}
export {
  VERSION,
  compile,
  parse11 as parse,
  preprocess,
  walk
};
//# sourceMappingURL=svelte_compiler.js.map
